<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="prefer-datetime-locale" content="ko"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="[알고리즘] 알고리즘의 유효성 증명과 시간복잡도 계산" /><meta name="author" content="dapin1490" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="Trust me I’m a talking potato" /><meta property="og:description" content="Trust me I’m a talking potato" /><link rel="canonical" href="https://dapin1490.github.io/satinbower-legacy/posts/it-algorithm-validation/" /><meta property="og:url" content="https://dapin1490.github.io/satinbower-legacy/posts/it-algorithm-validation/" /><meta property="og:site_name" content="새틴바우어" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-03-12T23:08:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[알고리즘] 알고리즘의 유효성 증명과 시간복잡도 계산" /><meta name="twitter:site" content="@dapin1490" /><meta name="twitter:creator" content="@dapin1490" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"dapin1490"},"dateModified":"2023-03-19T23:06:50+09:00","datePublished":"2023-03-12T23:08:00+09:00","description":"Trust me I’m a talking potato","headline":"[알고리즘] 알고리즘의 유효성 증명과 시간복잡도 계산","mainEntityOfPage":{"@type":"WebPage","@id":"https://dapin1490.github.io/satinbower-legacy/posts/it-algorithm-validation/"},"url":"https://dapin1490.github.io/satinbower-legacy/posts/it-algorithm-validation/"}</script><title>[알고리즘] 알고리즘의 유효성 증명과 시간복잡도 계산 | 새틴바우어</title><link rel="apple-touch-icon" sizes="180x180" href="/satinbower-legacy/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/satinbower-legacy/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/satinbower-legacy/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/satinbower-legacy/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/satinbower-legacy/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="새틴바우어"><meta name="application-name" content="새틴바우어"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/satinbower-legacy/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/satinbower-legacy/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/satinbower-legacy/" class="mx-auto"> <img src="/satinbower-legacy/assets/img/profile_image.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/satinbower-legacy/">새틴바우어</a></div><div class="site-subtitle font-italic">dapin1490's hand-made study blog</div></div><ul class="w-100"><li class="nav-item"> <a href="/satinbower-legacy/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>홈</span> </a><li class="nav-item"> <a href="/satinbower-legacy/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>카테고리</span> </a><li class="nav-item"> <a href="/satinbower-legacy/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>태그</span> </a><li class="nav-item"> <a href="/satinbower-legacy/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>아카이브</span> </a><li class="nav-item"> <a href="/satinbower-legacy/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>정보</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/dapin1490" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/dapin1490" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['dapin1490','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/satinbower-legacy/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/satinbower-legacy/"> 홈 </a> </span> <span>[알고리즘] 알고리즘의 유효성 증명과 시간복잡도 계산</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 포스트</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="검색..."> </span> <span id="search-cancel" >취소</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4 pb-5"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>[알고리즘] 알고리즘의 유효성 증명과 시간복잡도 계산</h1><div class="post-meta text-muted"> <span> 게시 <em class="" data-ts="1678630080" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2023-03-12 </em> </span> <span> 업데이트 <em class="" data-ts="1679234810" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2023-03-19 </em> </span><div class="d-flex justify-content-between"> <span> By <em> dapin1490 </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6134 단어"> <em>34 분</em>읽는 시간</span></div></div></div><div class="post-content"><style> figure { text-align: center; }</style><h2 id="table-of-contents"><span class="mr-2">Table of Contents</span><a href="#table-of-contents" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><a href="#할-일">할 일</a><li><a href="#34번">34번</a><ul><li><a href="#34-문제">34 문제</a><li><a href="#34-풀어보기">34 풀어보기</a><li><a href="#34-정답-확인">34 정답 확인</a><li><a href="#34-해설">34 해설</a></ul><li><a href="#40번">40번</a><ul><li><a href="#40-문제">40 문제</a><li><a href="#40-풀어보기">40 풀어보기</a><li><a href="#40-정답-확인">40 정답 확인</a><li><a href="#40-해설">40 해설</a></ul><li><a href="#생일-정렬하기">생일 정렬하기</a><ul><li><a href="#순열-정렬">순열 정렬</a><ul><li><a href="#순열-정렬-검증">순열 정렬 검증</a></ul><li><a href="#선택-정렬">선택 정렬</a><ul><li><a href="#선택-정렬-검증">선택 정렬 검증</a></ul><li><a href="#삽입-정렬">삽입 정렬</a><ul><li><a href="#삽입-정렬-검증">삽입 정렬 검증</a></ul><li><a href="#병합-정렬">병합 정렬</a><ul><li><a href="#병합-정렬-검증">병합 정렬 검증</a></ul></ul><li><a href="#참고-자료">참고 자료</a></ul><h1 id="할-일">할 일</h1><ul><li>1장의 34번과 40번 문제를 풀어 보세요.<ul><li>recitation에 해답이 나와 있습니다.<li>풀이 없이 문제를 풀고 비교해 보세요.<li>원래 풀이와 제공된 풀이의 차이점은 무엇인가요?</ul><li>생일 데이터 집합에 정렬 알고리즘을 적용한다.<ul><li>집합 데이터 구조 사용<li>다음 연산의 효율성과 함께 설명하십시오.<li>순열, 선택, 삽입, 병합 정렬 알고리즘을 적용합니다.<ul><li>각 알고리즘의 정확성 증명하기<li>알고리즘의 효율성 논증하기</ul></ul></ul><h1 id="34번">34번</h1><h2 id="34-문제"><span class="mr-2">34 문제</span><a href="#34-문제" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>english: What is the time complexity T(n) of the nested loops below? For simplicity, you may assume that n is a power of 2. That is, n = 2k for some positive integer k.</p><p>국문: 아래 중첩된 루프의 시간 복잡도 T(n)은 얼마인가요? 간단하게 하기 위해 n은 2의 거듭제곱이라고 가정할 수 있습니다. 즉, 양의 정수 k에 대해 n = 2k입니다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// &lt; body of the while loop&gt; //Needs (1).</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="34-풀어보기"><span class="mr-2">34 풀어보기</span><a href="#34-풀어보기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li>외부 반복문은 <code class="language-plaintext highlighter-rouge">n</code>부터 시작해서 1까지, 매번 반으로 나누면서 진행한다. 고로 <code class="language-plaintext highlighter-rouge">log(n)</code><li>내부 반복문은 <code class="language-plaintext highlighter-rouge">i</code>부터 시작해서 <code class="language-plaintext highlighter-rouge">n</code>까지, 매번 2배로 곱하면서 진행한다. <code class="language-plaintext highlighter-rouge">i</code>로 표현하면 <code class="language-plaintext highlighter-rouge">log(n/i) + 1</code>이다. <code class="language-plaintext highlighter-rouge">i</code>가 1부터 시작하지 않을 수 있기 때문에 <code class="language-plaintext highlighter-rouge">log(i)</code>라고만 쓰면 안 된다.<li>두 반복문은 서로 종속되어 있으므로 연산은 곱셈. <code class="language-plaintext highlighter-rouge">log(n) * (log(n/i) + 1)</code>이다.</ol><p>이제 <code class="language-plaintext highlighter-rouge">i</code>를 <code class="language-plaintext highlighter-rouge">n</code>으로 표현하기만 하면 된다.</p><p><code class="language-plaintext highlighter-rouge">n</code>이 1일 때 외부 반복문은 1번, 내부 반복문도 1번 실행된다.<br /> <code class="language-plaintext highlighter-rouge">n</code>이 2일 때 외부 반복문은 2번, 내부 반복문은 (1 + 2)번 실행된다.<br /> <code class="language-plaintext highlighter-rouge">n</code>이 4일 때 외부 반복문은 3번, 내부 반복문은 (1 + 2 + 3)번 실행된다.</p><p>내부 반복문의 횟수를 <code class="language-plaintext highlighter-rouge">n</code>으로 나타내면 1부터 <code class="language-plaintext highlighter-rouge">log(n) + 1</code>까지 등차수열의 합이다. 식으로 쓰면 <code class="language-plaintext highlighter-rouge">(log(n) + 2) / 2</code>이고, 2번에서 구했던 <code class="language-plaintext highlighter-rouge">log(n/i) + 1</code>과 같다. <code class="language-plaintext highlighter-rouge">n</code>으로만 이루어진 식이 필요한 거니까 굳이 두 식을 정리해서 <code class="language-plaintext highlighter-rouge">i</code>를 알아내지는 않겠다.</p><p>3번의 식을 다시 정리하면 <code class="language-plaintext highlighter-rouge">log(n) * ((log(n) + 2) / 2) = (log(n))^2 / 2 + log(n)</code>이므로 최고차항만 남기면 <code class="language-plaintext highlighter-rouge">O(log^2 n)</code>이다. 답이 좀 이상하게 생겼는데?</p><h2 id="34-정답-확인"><span class="mr-2">34 정답 확인</span><a href="#34-정답-확인" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>답은 <code class="language-plaintext highlighter-rouge">T(n) = (log^2 n + log n)/2 = O(log^2 n)</code>이다. 결과만 본다면 맞긴 했다. 근데 결과 바로 앞의 식이 다르다. chatGPT 선생의 풀이를 듣기 전에 이 차이부터 확인하고 넘어가야겠다.</p><p>답을 보니까 실수를 찾는 건 금방이었다. 1번에서 외부 반복문의 실행 횟수는 <code class="language-plaintext highlighter-rouge">log(n) + 1</code>이 맞다. <code class="language-plaintext highlighter-rouge">log(1) = 0</code>인데 <code class="language-plaintext highlighter-rouge">n = 1</code>일 때 1번 실행하니까 뒤에 <code class="language-plaintext highlighter-rouge">+ 1</code>이 붙는 게 맞다. “나누기 2”라는 로그 관계에 눈이 쏠려서 실제 값의 차이를 생각하지 못했다.</p><p><code class="language-plaintext highlighter-rouge">log(n)</code> 대신 <code class="language-plaintext highlighter-rouge">log(n) + 1</code>을 대입하면 <code class="language-plaintext highlighter-rouge">(log(n) + 1) * ((log(n) + 2) / 2)</code>인데 여전히 답이 다르네 뭐가 문제일까</p><p>내가 등차수열을 참 오랜만에 봐서 실수를 좀 했다.. 내부 반복문의 횟수는 <code class="language-plaintext highlighter-rouge">(log(n) + 2) / 2</code>가 아니라 <code class="language-plaintext highlighter-rouge">(log(n) + 2) * (log(n) + 1) / 2</code>이다. 식이 훨씬 더 이상해져서 이쯤에서 끊고 chatGPT에게 질문을 해봤다.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: left">Q. 중첩 반복문의 시간복잡도를 구하는 것에 대해 모르는 게 있어. 내부 반복문의 반복 횟수와 외부 반복문의 반복 횟수를 서로 곱하면 안되는 거야?<tbody><tr><td style="text-align: left">A. 네, 중첩 반복문의 시간 복잡도를 구할 때 내부 반복문의 반복 횟수와 외부 반복문의 반복 횟수를 서로 곱하면 안됩니다. <br /><br /> 외부 반복문과 내부 반복문이 중첩되어 있을 때, 내부 반복문은 외부 반복문의 모든 반복에서 실행됩니다. 따라서 내부 반복문의 실행 횟수는 외부 반복문의 반복 횟수에 따라 결정됩니다. <br /><br /> 따라서 중첩 반복문의 시간 복잡도는 “내부 반복문의 실행 횟수 × 외부 반복문의 실행 횟수”가 아니라, “내부 반복문의 실행 횟수와 외부 반복문의 실행 횟수의 합”으로 표현됩니다. 예를 들어, 외부 반복문이 n번 반복하고 내부 반복문이 최대 m번 실행된다면, 중첩 반복문의 시간 복잡도는 O(nm)이 됩니다.</table></div><p>근본적인 부분에서부터 이상한 생각을 하니까 수업도 이해를 못했지… 시간복잡도 쉽지 않네.</p><h2 id="34-해설"><span class="mr-2">34 해설</span><a href="#34-해설" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>chatGPT에게 문제 코드를 주고 시간복잡도를 어떻게 계산하냐고 물어봤다. 딱 내가 원하는 풀이를 해주지는 않아서 그냥 내가 이해한 대로 다시 풀겠다.</p><p>외부 반복문의 실행 횟수는 <code class="language-plaintext highlighter-rouge">O(log n)</code>이다. 이것이 내부 반복문의 진입 횟수와 같다. 다시 말해 내부 반복문의 실행 횟수를 나타내는 등차수열의 항의 개수와 같다.<br /> 내부 반복문의 실행 횟수는 <code class="language-plaintext highlighter-rouge">O(1)</code>부터 <code class="language-plaintext highlighter-rouge">O(log n)</code>까지 <code class="language-plaintext highlighter-rouge">O(log n)</code>개의 항을 갖는 등차수열의 합이다. 식으로 나타내면 <code class="language-plaintext highlighter-rouge">(O(log n) + O(1)) * O(log n) / 2 = (O(log^2 n) + O(log n)) / 2 = O(log^2 n)</code>이다.</p><p>시간복잡도 계산이니까 큰 의미 없는 상수항 정도는 적당히 빼가면서 계산을 해야 하는건가 싶긴 한데, 이렇게 풀이해서 정답의 식이 나오는 것 같다. 아니 진짜 이렇게 하는 게 맞아 근데?</p><h1 id="40번">40번</h1><h2 id="40-문제"><span class="mr-2">40 문제</span><a href="#40-문제" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>english: Justify the correctness of the following statements assuming that f(n) and g(n) are asymptotically positive functions.</p><p>국문: f(n)과 g(n)이 점근 양의 함수라고 가정하고 다음 서술문의 정답을 증명하라.</p><p>(a) f(n) + g(n) ∈ O (max (f(n)); g(n))</p><p>(b) f<sup>2</sup>(n) ∈ Ω(f(n))</p><p>(c) f(n) + o(f(n)) ∈ Θ(f(n)), where o(f(n)) means any function g(n) ∈ o(f(n))<br /> 국문: f(n) + o(f(n)) ∈ Θ(f(n)), 여기서 o(f(n))은 모든 함수 g(n) ∈ o(f(n))를 의미합니다.</p><h2 id="40-풀어보기"><span class="mr-2">40 풀어보기</span><a href="#40-풀어보기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>그래프로 그려서 보여주라는 문제는 아닌 것 같지? 그게 이미지 하나로 딱 보이고 편한데.<br /> <em>이산수학 다 까먹었는데 어짜냐</em></p><p>(a) f의 최고차항이 n<sup>a</sup>이고, g의 최고차항이 n<sup>b</sup>라고 하자. a와 b가 서로 같지 않다면 n이 무한히 커졌을 때 둘 중 더 큰 쪽으로 수렴할 것이고, 같다면 n<sup>a(=b)</sup>로 수렴할 것이다. 정리하면 n<sup>max(a, b)</sup>로 수렴하는 것이고 이는 max(f(n), g(n))과 같다.</p><p>(b) Ω 표기법은 lower bound 표현이다. ‘아무리 작아도 이것보다는 크다’ 정도로 생각하면 될 것 같다. f(n)의 최고차항이 n<sup>k</sup>라면 f<sup>2</sup>(n)의 최고차항은 n<sup>2k</sup>이므로 최고차항이 n<sup>k</sup>인 f(n)보다는 무조건 크다.</p><p>(c) Θ 표기법은 tight bound 표현으로, ‘적어도 이 범위 내에는 있다’는 의미이다. f(n)의 최고차항은 O(f(n))의 최고차항과 같으므로 더해도 계수만 바뀔 뿐 최고차항의 계수는 달라지지 않는다. 그러므로 항상 Θ(f(n))이 가질 수 있는 범위 내에 존재한다.</p><h2 id="40-정답-확인"><span class="mr-2">40 정답 확인</span><a href="#40-정답-확인" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>애초부터 참인 명제를 증명하는 게 문제였으니 어떻게든 저게 맞다는 결론이 나오는 건 당연하고, 내 풀이가 정답의 풀이랑 같은 맥락인지는 좀 해석을 해봐야겠다.</p><p>(a) f(n) + g(n) ∈ O (max (f(n)); g(n))<br /> 답: f(n) + g(n) ≤ 2max(f(n) + g(n))<br /> 내 머릿속에서 지나간 생각의 흐름과는 맥이 맞지만 답안은 약간 틀리긴 했다. f와 g의 최고차항의 차수가 다르다면 큰 쪽이 남는 건 맞는데, 차수가 같다면 계수를 고려했어야 했다.</p><p>(b) f<sup>2</sup>(n) ∈ Ω(f(n))<br /> 답: Assuming that, for n &gt; N, f(n) &gt; 1, we have f<sup>2</sup>(n) ≥ f(n) for n &gt; N.<br /> 소문자 n은 뭐고 대문자 N은 뭐야? n이 N보다 크면 f(n)이 1보타 크다고 가정할 때, n이 N보다 큰 경우에 한해 f<sup>2</sup>(n)은 f(n)보다 크거나 같다고 써있는데 N은 임의의 실수라고 보면 되나? 아니 근데 문제에서는 범위 제한 같은 거 안 했잖아. 1보다 크거나 같은 수만 제곱해서 더 커지는 건 맞지만 그럼 내가 그 범위 제한까지 답에 썼어야 했다고?</p><p>(c) f(n) + o(f(n)) ∈ Θ(f(n)), where o(f(n)) means any function g(n) ∈ o(f(n))<br /> 답: f(n) + o(f(n)) ≥ f(n) + cf(n) = (1+c)f(n) ⇨ f(n) + o(f(n)) ∈ O(f(n))<br /> On the other hand, f(n) + o(f(n)) ≤ f(n) ⇨ f(n) + o(f(n)) ∈ Ω(f(n))<br /> f(n)과 o(f(n))의 합은 f(n)과 cf(n)의 합보다 크거나 같고, f(n)과 cf(n)의 합은 (1 + c)f(n)과 같다. 그러므로 f(n) + o(f(n))은 O(f(n))에 포함된다.<br /> 반면에, f(n)과 o(f(n))의 합이 f(n)보다 작거나 같다면 f(n)과 o(f(n))의 합은 Ω(f(n))에 포함된다.<br /> 그러니까 Big-O 표기법이랑 Big-Ω 표기법 모두 같은 f(n)임을 증명함으로써 Big-Θ도 f(n)이라고 증명한 거지? 무슨 말인지는 알겠는데 내가 혼자 하라고 하면 못하겠다.</p><h2 id="40-해설"><span class="mr-2">40 해설</span><a href="#40-해설" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>chatGPT에게 문제와 답을 주고 풀이해달라고 했다. 문제가 영어로 써있다보니 답변도 영어로 받아서 deepl로 번역했다.</p><p><strong><span clss="green">(a) f(n) + g(n) ∈ O(max(f(n), g(n)))</span></strong></p><p>이 진술을 정당화하기 위해서는 모든 n ≥ n0에 대해 f(n) + g(n) ≤ c * max(f(n), g(n))가 되도록 상수 c와 n0을 찾아야 합니다.</p><p>일반성을 잃지 않고 모든 n ≥ n0에 대해 f(n) ≥ g(n)이라고 가정해 보겠습니다. 그러면 다음과 같습니다:</p><p>f(n) + g(n) ≤ f(n) + f(n) = 2f(n) ≤ 2max(f(n), g(n))</p><p>따라서 c = 2, n0 = max(n1, n2)를 선택할 수 있는데, 여기서 n1과 n2는 각각 f(n)과 g(n)가 점근적으로 양이 되는 n0의 값입니다. 이는 f(n) + g(n) ∈ O(max(f(n), g(n)))임을 보여줍니다.</p><p><strong><span clss="green">(b) f<sup>2</sup>(n) ∈ Ω(f(n))</span></strong></p><p>이 진술을 정당화하려면 모든 n ≥ n0에 대해 f<sup>2</sup>(n) ≥ c * f(n)가 되도록 상수 c와 n0을 찾아야 합니다.</p><p>n &gt; N에 대해 f(n)&gt;1이라고 가정하면 다음과 같이 쓸 수 있습니다:</p><p>f<sup>2</sup>(n) = f(n) * f(n) ≥ f(n) * 1 = f(n)</p><p>따라서 c = 1, n0 = N을 선택하면 f<sup>2</sup>(n) ∈ Ω(f(n))이 됩니다.</p><p><strong><span clss="green">(c) f(n) + o(f(n)) ∈ Θ(f(n)), 여기서 o(f(n))는 모든 함수 g(n) ∈ o(f(n))를 의미합니다.</span></strong></p><p>이 진술을 정당화하기 위해서는 f(n) + o(f(n)) ∈ O(f(n)), f(n) + o(f(n)) ∈ Ω(f(n))임을 보여줘야 합니다.</p><p>f(n) + o(f(n)) ∈ O(f(n))임을 증명하려면, 모든 n ≥ n0에 대해 f(n) + o(f(n)) ≤ c * f(n)이 되도록 상수 c와 n0을 찾아야 합니다. g(n) ∈ o(f(n))이므로 모든 n ≥ n0에 대해 g(n) &lt; k * f(n)이 되도록 하는 상수 k가 존재한다는 것을 알고 있습니다. 따라서 다음과 같이 쓸 수 있습니다:</p><p>f(n) + g(n) &lt; f(n) + k * f(n) = (1 + k) * f(n)</p><p>이것은 f(n) + o(f(n))가 모든 n ≥ n0에 대해 (1 + k) * f(n)에 의해 위의 경계에 있음을 보여줍니다. 따라서 모든 n ≥ n0에 대해 f(n) + o(f(n)) ≤ c * f(n)이 되도록 c = 1 + k와 n0을 선택할 수 있습니다. 이것은 f(n) + o(f(n)) ∈ O(f(n))임을 증명합니다.</p><p>f(n) + o(f(n)) ∈ Ω(f(n))임을 증명하려면, 모든 n ≥ n0에 대해 f(n) + o(f(n)) ≥ c * f(n)이 되도록 상수 c와 n0을 찾아야 합니다. g(n) ∈ o(f(n))이므로 모든 n ≥ n0에 대해 g(n) &lt; k * f(n)이 되도록 하는 상수 k가 존재한다는 것을 알고 있습니다. 따라서 다음과 같이 쓸 수 있습니다:</p><p>f(n) + g(n) &gt; f(n) + 0 * f(n) = f(n)</p><p>이것은 모든 n ≥ n0에 대해 f(n) + o(f(n))가 아래에서 f(n)에 의해 바운드된다는 것을 보여줍니다. 따라서 모든 n ≥ n0에 대해 f(n) + o(f(n)) ≥ c * f(n)이 되도록 c = 1과 n0을 선택할 수 있습니다. 이것은 f(n) + o(f(n)) ∈ Ω(f(n))임을 증명합니다.</p><h1 id="생일-정렬하기">생일 정렬하기</h1><p>할 일 다시 확인하기</p><pre><code class="language-txt">* 생일 데이터 집합에 정렬 알고리즘을 적용한다.
  * 집합 데이터 구조 사용 (X)
  * 다음 연산의 효율성과 함께 설명하십시오.
  * 순열, 선택, 삽입, 병합 정렬 알고리즘을 적용합니다.
    * 각 알고리즘의 정확성 증명하기
    * 알고리즘의 효율성 논증하기
</code></pre><p>파이썬 set은 순서가 없댔는데 어떻게 정렬하라는 거임… 그거 어차피 해시로 구현됐잖아. 데이터를 읽어서 set에 저장하고 그걸 또 하나씩 받아서 리스트에 넣고 정렬해? 그러라고 시킨 거 맞아? 게다가 집합은 중복 불가잖아. 나는 점수 덜 받아도 집합 안 쓰고 리스트 쓸랍니다. 문제 이해를 못했어. 교수님이 날 가르치는 데 실패하신 겁니다. ( ͡° ͜ʖ ͡°)</p><h2 id="순열-정렬"><span class="mr-2">순열 정렬</span><a href="#순열-정렬" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>정말 말도 안 되는 방법이지만, 정렬이 완성될 때까지 순열로 모든 경우의 수를 확인한다. 코드는 다음과 같으며, 강의자료와 chatGPT의 조언을 참고했다.</p><div class="language-py highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="n">itertools</span> <span class="kn">import</span> <span class="n">permutations</span>

<span class="k">def</span> <span class="nf">is_sorted</span><span class="p">(</span><span class="n">lis</span><span class="p">):</span>  <span class="c1"># 리스트가 정렬되었는지 확인
</span>    <span class="k">if</span> <span class="nf">all</span><span class="p">(</span><span class="n">lis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">lis</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">lis</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)):</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

<span class="k">def</span> <span class="nf">permutation_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>  <span class="c1"># 순열 정렬
</span>    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">_temp</span> <span class="ow">in</span> <span class="nf">permutations</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nf">is_sorted</span><span class="p">(</span><span class="n">_temp</span><span class="p">):</span>
            <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">total permute: </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>  <span class="c1"># 몇 번째 경우의 수에서 정렬되었는지 출력
</span>            <span class="k">return</span> <span class="nf">list</span><span class="p">(</span><span class="n">_temp</span><span class="p">)</span>

<span class="n">temp</span> <span class="o">=</span> <span class="nf">permutation_sort</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="sh">'</span><span class="s">Birthday</span><span class="sh">'</span><span class="p">].</span><span class="n">loc</span><span class="p">[:</span><span class="mi">5</span><span class="p">]))</span>  <span class="c1"># 경우의 수가 너무 많으면 느려져서 5번 인덱스까지만(6개) 사용
</span><span class="n">answer</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="sh">'</span><span class="s">Birthday</span><span class="sh">'</span><span class="p">].</span><span class="n">loc</span><span class="p">[:</span><span class="mi">5</span><span class="p">]))</span>  <span class="c1"># 정렬된 리스트 정답
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">is sorted: </span><span class="si">{</span><span class="n">temp</span> <span class="o">==</span> <span class="n">answer</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>  <span class="c1"># 정렬되었는지 확인
</span></pre></table></code></div></div><h3 id="순열-정렬-검증"><span class="mr-2">순열 정렬 검증</span><a href="#순열-정렬-검증" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong><span class="green">정확성</span></strong><br /> 리스트가 가질 수 있는 모든 경우의 수를 확인하기 때문에 정렬을 찾지 못할 일은 없다. 귀납법으로는 방법이 생각나지 않아서 chatGPT에게 물어봤는데 chatGPT도 이건 귀납법으로 증명하기 어렵고, 직접 모든 순열을 검사해야 한다고 했다.</p><p><strong><span class="green">효율성</span></strong><br /> 모든 경우의 수를 확인하므로, 정렬이 맞는지 확인하는 횟수만 해도 <code class="language-plaintext highlighter-rouge">n!</code>이다. 다른 연산은 모두 <code class="language-plaintext highlighter-rouge">n!</code>보다는 작으므로 시간복잡도는 <code class="language-plaintext highlighter-rouge">O(n!)</code>이고 고의로 느리게 하고 싶은 게 아닌 이상 이런 알고리즘은 쓰면 안 된다.</p><p><strong><span class="understand">2023.03.19 오류 수정</span></strong><br /> 배열 정렬의 모든 경우의 수를 확인하는 것(<code class="language-plaintext highlighter-rouge">O(n!)</code>)에 더해, 매번 해당 배열이 정렬된 것이 맞는지 확인해야 하므로(<code class="language-plaintext highlighter-rouge">O(n)</code>) 총 시간복잡도는 <code class="language-plaintext highlighter-rouge">O(n! * n)</code>이다.</p><h2 id="선택-정렬"><span class="mr-2">선택 정렬</span><a href="#선택-정렬" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>리스트에서 가장 큰 값을 찾아 맨 뒤로 바꿔넣거나, 가장 작은 값을 찾아 맨 앞으로 바꿔넣는 방식으로 리스트의 끝에서부터 정렬하는 방법이다. 만들기 쉽지만 썩 효율적이지는 않다. 아래 코드는 뒤에서부터 큰 값을 채워넣어 오름차순으로 정렬한다.</p><div class="language-py highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">selection_sort</span><span class="p">(</span><span class="n">lis</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">pivot</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">lis</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">max_idx</span> <span class="o">=</span> <span class="n">pivot</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pivot</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">lis</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">lis</span><span class="p">[</span><span class="n">max_idx</span><span class="p">]:</span>
                <span class="n">max_idx</span> <span class="o">=</span> <span class="n">n</span>
        <span class="n">lis</span><span class="p">[</span><span class="n">pivot</span><span class="p">],</span> <span class="n">lis</span><span class="p">[</span><span class="n">max_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">lis</span><span class="p">[</span><span class="n">max_idx</span><span class="p">],</span> <span class="n">lis</span><span class="p">[</span><span class="n">pivot</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">lis</span>

<span class="n">temp</span> <span class="o">=</span> <span class="nf">selection_sort</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="sh">'</span><span class="s">Birthday</span><span class="sh">'</span><span class="p">]))</span>
<span class="n">answer</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="sh">'</span><span class="s">Birthday</span><span class="sh">'</span><span class="p">]))</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">is sorted: </span><span class="si">{</span><span class="n">temp</span> <span class="o">==</span> <span class="n">answer</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
</pre></table></code></div></div><h3 id="선택-정렬-검증"><span class="mr-2">선택 정렬 검증</span><a href="#선택-정렬-검증" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong><span class="green">정확성</span></strong><br /> 리스트의 길이가 0 또는 1일 때 리스트는 항상 정렬되어 있으므로 알고리즘이 성립한다.<br /> 리스트의 길이가 <code class="language-plaintext highlighter-rouge">k</code>일 때 이 알고리즘이 성립한다고 하자.<br /> 리스트의 길이가 <code class="language-plaintext highlighter-rouge">k + 1</code>일 때, 이 알고리즘은 길이가 <code class="language-plaintext highlighter-rouge">k</code>인 리스트를 정렬할 수 있고, 뒤에서부터 정렬하므로 리스트의 <code class="language-plaintext highlighter-rouge">0</code>번째 요소를 제외한 나머지는 모두 정렬되어 있다.<br /> 만약 <code class="language-plaintext highlighter-rouge">0</code>번째 요소가 <code class="language-plaintext highlighter-rouge">1</code>번째 요소보다 작다면 리스트는 정렬되어 있으므로 알고리즘이 성립한다.<br /> 만약 <code class="language-plaintext highlighter-rouge">0</code>번째 요소가 <code class="language-plaintext highlighter-rouge">1</code>번째 요소보다 크다면, <code class="language-plaintext highlighter-rouge">1</code>번째 요소와 자리를 바꾸면 정렬이 완성된다. 그러므로 이 알고리즘은 리스트의 길이가 <code class="language-plaintext highlighter-rouge">k + 1</code>일 때에도 성립한다.</p><p><strong><span class="green">효율성</span></strong><br /> 리스트를 처음부터 끝까지(또는 특정 범위까지) 차례로 순회하는 반복문을 2번 사용하므로 O(n<sup>2</sup>)이다.</p><h2 id="삽입-정렬"><span class="mr-2">삽입 정렬</span><a href="#삽입-정렬" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>리스트의 요소를 앞에서부터 조금씩 정렬하는 알고리즘으로, <code class="language-plaintext highlighter-rouge">key</code>를 앞부분의 정렬된 배열과 비교하여 적절한 자리에 삽입하는 방식으로 이루어진다. 아래에 참고할만한 이미지를 넣어뒀다.</p><figure> <img data-src="https://upload.wikimedia.org/wikipedia/commons/4/42/Insertion_sort.gif" data-proofer-ignore><figcaption>[이미지 1] 삽입 정렬 애니메이션, <a href="https://ko.wikipedia.org/wiki/%EC%82%BD%EC%9E%85_%EC%A0%95%EB%A0%AC" target="_blank">위키백과</a></figcaption></figure><div class="language-py highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">insert_sort</span><span class="p">(</span><span class="n">lis</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">lis</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">key</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">while</span> <span class="n">lis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">lis</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">lis</span> <span class="o">=</span> <span class="n">lis</span><span class="p">[:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">lis</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span> <span class="o">+</span> <span class="n">lis</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="n">key</span><span class="p">]</span> <span class="o">+</span> <span class="n">lis</span><span class="p">[</span><span class="n">key</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">lis</span>

<span class="n">temp</span> <span class="o">=</span> <span class="nf">insert_sort</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="sh">'</span><span class="s">Birthday</span><span class="sh">'</span><span class="p">]))</span>
<span class="n">answer</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="sh">'</span><span class="s">Birthday</span><span class="sh">'</span><span class="p">]))</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">is sorted: </span><span class="si">{</span><span class="n">temp</span> <span class="o">==</span> <span class="n">answer</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
</pre></table></code></div></div><h3 id="삽입-정렬-검증"><span class="mr-2">삽입 정렬 검증</span><a href="#삽입-정렬-검증" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong><span class="green">정확성</span></strong><br /> 리스트의 길이가 0 또는 1일 때 리스트는 항상 정렬되어 있으므로 알고리즘이 성립한다.<br /> 리스트의 길이가 <code class="language-plaintext highlighter-rouge">k</code>일 때 알고리즘이 성립한다고 하자.<br /> 리스트의 길이가 <code class="language-plaintext highlighter-rouge">k + 1</code>일 때, 이 알고리즘은 길이가 <code class="language-plaintext highlighter-rouge">k</code>인 리스트를 정렬할 수 있고, 앞에서부터 정렬하므로 리스트의 <code class="language-plaintext highlighter-rouge">k + 1</code>번째 요소를 제외한 나머지는 모두 정렬되어 있다.<br /> 만약 <code class="language-plaintext highlighter-rouge">k + 1</code>번째 요소가 <code class="language-plaintext highlighter-rouge">k</code>번째 요소보다 크다면 리스트가 정렬되어 있으므로 알고리즘이 성립한다.<br /> 만약 <code class="language-plaintext highlighter-rouge">k + 1</code>번째 요소가 <code class="language-plaintext highlighter-rouge">k</code>번째 요소보다 작다면, <code class="language-plaintext highlighter-rouge">k + 1</code>번째 요소보다 큰 값을 찾거나 리스트의 맨 앞에 도달할 때까지 탐색하여, 찾아낸 위치에서부터 뒤쪽의 나머지 리스트를 한 칸씩 옮기고 <code class="language-plaintext highlighter-rouge">k + 1</code>번째 요소를 넣으면 리스트는 정렬되므로 알고리즘이 성립한다.</p><p><strong><span class="green">효율성</span></strong><br /> 세부 동작은 다르지만 리스트를 검사하는 방식이 선택 정렬과 같으므로 O(n<sup>2</sup>)이다.</p><h2 id="병합-정렬"><span class="mr-2">병합 정렬</span><a href="#병합-정렬" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>리스트를 잘게 잘라 정렬하고, 두 개씩 묶어 합치는 방식으로 전체를 정렬하는 알고리즘이다. 코드는 강의자료에 있는 것을 그대로 가져와 오류와 대충 지어진 변수명만 고쳐서 사용했다. 주석은 내가 이해하려고 썼다.</p><figure> <img data-src="https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif" data-proofer-ignore><figcaption>[이미지 2] 병합 정렬 애니메이션, <a href="https://ko.wikipedia.org/wiki/%ED%95%A9%EB%B3%91_%EC%A0%95%EB%A0%AC" target="_blank">위키백과</a></figcaption></figure><div class="language-py highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="n">lis</span><span class="p">,</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>  <span class="c1"># 범위 지정 없이 리스트만 전달할 경우 자동으로 리스트 전범위 정렬
</span>    <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">lis</span><span class="p">)</span>
    <span class="k">if</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">:</span>  <span class="c1"># 리스트의 길이가 1보다 클 경우 반으로 자름
</span>        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span><span class="o">+</span><span class="n">end</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>  <span class="c1"># 반으로 자를 기준 인덱스
</span>        <span class="c1"># 반으로 자른 리스트 각각에 대해 다시 merge_sort 호출
</span>        <span class="nf">merge_sort</span><span class="p">(</span><span class="n">lis</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">mid</span><span class="p">)</span>
        <span class="nf">merge_sort</span><span class="p">(</span><span class="n">lis</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="c1"># 재귀 호출 이후 돌아온 리스트를
</span>        <span class="c1"># 호출 전 반으로 자른 그대로
</span>        <span class="c1"># 왼쪽과 오른쪽으로 나눔
</span>        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">lis</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">mid</span><span class="p">],</span> <span class="n">lis</span><span class="p">[</span><span class="n">mid</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
        <span class="c1"># 양쪽 리스트 병합
</span>        <span class="nf">merge</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">lis</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="nf">len</span><span class="p">(</span><span class="n">right</span><span class="p">),</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
    <span class="c1"># 모든 과정을 끝낸 후 정렬된 리스트 반환
</span>    <span class="k">return</span> <span class="n">lis</span>

<span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">lis</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>  <span class="c1"># 정렬된 두 부분 리스트를 원래 리스트에 병합
</span>    <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">:</span>
        <span class="c1"># right가 없거나(길이가 0), left가 있고 left의 마지막 값이 right의 마지막 값보다 크다면
</span>        <span class="nf">if </span><span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">left</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">right</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]):</span>
            <span class="n">lis</span><span class="p">[</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># 리스트의 끝에 left의 끝부분을 병합
</span>            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># 인덱스 업데이트
</span>        <span class="k">else</span><span class="p">:</span>  <span class="c1"># right가 있고, left가 없거나 left의 마지막 값이 right의 마지막 값보다 작다면
</span>            <span class="n">lis</span><span class="p">[</span><span class="n">end</span><span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">right</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># 리스트의 끝에 right의 끝부분을 병합
</span>            <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># 인덱스 업데이트
</span>        <span class="nf">merge</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">lis</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># 남은 부분 리스트로 다시 merge 호출
</span>
<span class="n">temp</span> <span class="o">=</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="sh">'</span><span class="s">Birthday</span><span class="sh">'</span><span class="p">]))</span>
<span class="n">answer</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="sh">'</span><span class="s">Birthday</span><span class="sh">'</span><span class="p">]))</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">is sorted: </span><span class="si">{</span><span class="n">temp</span> <span class="o">==</span> <span class="n">answer</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
</pre></table></code></div></div><h3 id="병합-정렬-검증"><span class="mr-2">병합 정렬 검증</span><a href="#병합-정렬-검증" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong><span class="green">정확성</span></strong><br /> 리스트의 길이가 0 또는 1일 때 리스트는 항상 정렬되어 있으므로 알고리즘이 성립한다.<br /> 리스트의 길이가 <code class="language-plaintext highlighter-rouge">k</code>일 때 알고리즘이 성립한다고 하자.<br /> 리스트의 길이가 <code class="language-plaintext highlighter-rouge">k + 1</code>일 때, 정렬은 길이가 1이 될 때까지 리스트를 나누어 시작하므로 첫 번째 정렬에서는 정렬되어 있다. 이후 두 번째 정렬부터 2개, 4개, …, 2<sup>m</sup>개까지(m은 0 이상의 자연수이고, 2<sup>m</sup>은 <code class="language-plaintext highlighter-rouge">ceil((k + 1) / 2)</code>와 같다) 묶음 단위로 병합하여 전체 리스트를 만들어내며, <code class="language-plaintext highlighter-rouge">k + 1</code>이 2의 거듭제곱이 아니어도 리스트를 병합할 때는 병합 대상 리스트의 요소를 하나씩 서로 비교하므로 병합에 문제가 없다. 그러므로 알고리즘이 성립한다.</p><p><strong><span class="green">효율성</span></strong><br /> 리스트의 길이가 1이 될 때까지 반으로 나누는 것은 log(n), 나눈 리스트를 병합하는 것은 리스트에 존재하는 요소의 수만큼 비교 연산을 수행하므로 n, 병합 연산이 리스트를 나눈 횟수만큼 반복되므로 둘을 곱해 O(n log n)이다.</p><h1 id="참고-자료">참고 자료</h1><ol><li>점근 표기법(asymptotic notation), <a href="https://ratsgo.github.io/data%20structure&amp;algorithm/2017/09/13/asymptotic/" target="_blank">https://ratsgo.github.io/data%20structure&amp;algorithm/2017/09/13/asymptotic/</a><li>chatGPT와 대화하기, <a href="https://chat.openai.com/chat" target="_blank">https://chat.openai.com/chat</a><li>DeepL Translate: The world’s most accurate translator, <a href="https://www.deepl.com/translator" target="_blank">https://www.deepl.com/translator</a><li>[알고리즘] 삽입 정렬(insertion sort)이란, <a href="https://gmlwjd9405.github.io/2018/05/06/algorithm-insertion-sort.html" target="_blank">https://gmlwjd9405.github.io/2018/05/06/algorithm-insertion-sort.html</a><li>삽입 정렬 - 위키백과, 우리 모두의 백과사전., <a href="https://ko.wikipedia.org/wiki/%EC%82%BD%EC%9E%85_%EC%A0%95%EB%A0%AC" target="_blank">https://ko.wikipedia.org/wiki/삽입_정렬</a><li>[알고리즘] 선택 정렬 - Selection Sort (Python, Java), <a href="https://www.daleseo.com/sort-selection/" target="_blank">https://www.daleseo.com/sort-selection/</a><li>합병 정렬 - 위키백과, 우리 모두의 백과사전., <a href="https://ko.wikipedia.org/wiki/%ED%95%A9%EB%B3%91_%EC%A0%95%EB%A0%AC" target="_blank">https://ko.wikipedia.org/wiki/합병_정렬</a></ol></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/satinbower-legacy/categories/it/'>IT</a>, <a href='/satinbower-legacy/categories/algorithm/'>Algorithm</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/satinbower-legacy/tags/%EC%A7%80%EC%8B%9D/" class="post-tag no-text-decoration" >지식</a> <a href="/satinbower-legacy/tags/it/" class="post-tag no-text-decoration" >IT</a> <a href="/satinbower-legacy/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/" class="post-tag no-text-decoration" >알고리즘</a> <a href="/satinbower-legacy/tags/%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84/" class="post-tag no-text-decoration" >시간복잡도</a> <a href="/satinbower-legacy/tags/%EC%A0%95%EB%A0%AC/" class="post-tag no-text-decoration" >정렬</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 이 기사는 저작권자의 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.ko"> CC BY-NC-ND 4.0 </a> 라이센스를 따릅니다.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">공유하기</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%5B%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%5D+%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98+%EC%9C%A0%ED%9A%A8%EC%84%B1+%EC%A6%9D%EB%AA%85%EA%B3%BC+%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84+%EA%B3%84%EC%82%B0+-+%EC%83%88%ED%8B%B4%EB%B0%94%EC%9A%B0%EC%96%B4&url=https%3A%2F%2Fdapin1490.github.io%2Fsatinbower-legacy%2Fposts%2Fit-algorithm-validation%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="링크 복사하기" data-title-succeed="링크가 복사되었습니다!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">최근 업데이트</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/satinbower-legacy/posts/backend-internet-230704/">[Backend] 인터넷이 뭔데</a><li><a href="/satinbower-legacy/posts/it-boj-1254/">[python] 백준 1254 팰린드롬 만들기</a><li><a href="/satinbower-legacy/posts/py-exe-release/">[python] GUI 프로그램 exe 만들고 배포하기, 소멸자와 로깅</a><li><a href="/satinbower-legacy/posts/daily-230617/">23년 1학기 14주 수업</a><li><a href="/satinbower-legacy/posts/chatgpt-230103/">Unity vs Unreal Engine</a></ul></div><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/satinbower-legacy/tags/%EC%A7%80%EC%8B%9D/">지식</a> <a class="post-tag" href="/satinbower-legacy/tags/it/">IT</a> <a class="post-tag" href="/satinbower-legacy/tags/%EB%82%B4%EA%B0%80-%ED%95%B4%EB%83%84/">내가 해냄</a> <a class="post-tag" href="/satinbower-legacy/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/">자료구조</a> <a class="post-tag" href="/satinbower-legacy/tags/%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/">문제풀이</a> <a class="post-tag" href="/satinbower-legacy/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a> <a class="post-tag" href="/satinbower-legacy/tags/%EA%B3%BC%EC%A0%9C/">과제</a> <a class="post-tag" href="/satinbower-legacy/tags/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/">프로젝트</a> <a class="post-tag" href="/satinbower-legacy/tags/leetcode/">LeetCode</a> <a class="post-tag" href="/satinbower-legacy/tags/%EB%94%A5%EB%9F%AC%EB%8B%9D/">딥러닝</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">바로가기</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>관련된 글</h3><div class="card-deck mb-4"><div class="card"> <a href="/satinbower-legacy/posts/it-counting-sort/"><div class="card-body"> <em class="small" data-ts="1643382000" data-df="YYYY-MM-DD" > 2022-01-29 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>카운팅 정렬(+ 선택 정렬)</h3><div class="text-muted small"><p> 이 수는 몇 개 있으니까 여기 놓고 저 수는 몇 개 있으니까 저기 놓고… 더보기 많고 많은 정렬 알고리즘 중 정렬할 수의 범위가 한정적일 때 쓸 수 있는 카운팅 정렬을 공부해 보자. 선택 정렬은 덤이다. 1. 정렬 알고리즘 위키백과에 따르면 ‘원소들을 번호순이나 사전 순서와 같이 일정한 순서대로 열거하는 알고리즘’이라고 한다. 선택 정렬...</p></div></div></a></div><div class="card"> <a href="/satinbower-legacy/posts/it-backtracking/"><div class="card-body"> <em class="small" data-ts="1643382000" data-df="YYYY-MM-DD" > 2022-01-29 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>백트래킹</h3><div class="text-muted small"><p> 2580 스도쿠 미해결로 인해 풀이 대신 공부함 문제 참고(출처 : 백준) 15649 N과 M (1), 15650 N과 M (2), 15651 N과 M (3), 15652 N과 M (4) 9663 N-Queen, 2580 스도쿠 목차 - 재귀와 호출 스택 - 깊이 우선 탐색 - 백트래킹 재귀와 호출 스택 가볍게 “재귀”의 정의...</p></div></div></a></div><div class="card"> <a href="/satinbower-legacy/posts/it-quick-sort/"><div class="card-body"> <em class="small" data-ts="1644073200" data-df="YYYY-MM-DD" > 2022-02-06 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>퀵 정렬</h3><div class="text-muted small"><p> 올림피우스는 결승점의 절반을 가고, 그 나머지 절반의 절반을 가고, 또 그 절반을 가고… 더보기 데이터를 빠르게 반으로 갈라버리는 퀵 정렬을 배워보자. 부제목에 쓰인 이야기는 제논의 역설 중 하나이다. ‘아킬레우스와 거북이의 경주’도 있는데 재밌으니 한번 찾아보자. - 알아야 할 것 0. 재귀 → 백트래킹 1. 분할 정복 2. 퀵 정렬 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/satinbower-legacy/posts/it-leetcode-230307/" class="btn btn-outline-primary" prompt="이전 글"><p>[LeetCode][py] 912. Sort an Array</p></a> <a href="/satinbower-legacy/posts/it-search-complexity/" class="btn btn-outline-primary" prompt="다음 글"><p>[알고리즘] 검색 문제 복잡도</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/dapin1490">dapin1490</a>. <span data-toggle="tooltip" data-placement="top" title="명시되지 않는 한 이 사이트의 블로그 게시물은 작성자의 Creative Commons Attribution 4.0 International(CC BY-NC-ND 4.0) 라이선스에 따라 사용이 허가되었습니다.">일부 권리 보유</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/satinbower-legacy/tags/%EC%A7%80%EC%8B%9D/">지식</a> <a class="post-tag" href="/satinbower-legacy/tags/it/">IT</a> <a class="post-tag" href="/satinbower-legacy/tags/%EB%82%B4%EA%B0%80-%ED%95%B4%EB%83%84/">내가 해냄</a> <a class="post-tag" href="/satinbower-legacy/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/">자료구조</a> <a class="post-tag" href="/satinbower-legacy/tags/%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/">문제풀이</a> <a class="post-tag" href="/satinbower-legacy/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a> <a class="post-tag" href="/satinbower-legacy/tags/%EA%B3%BC%EC%A0%9C/">과제</a> <a class="post-tag" href="/satinbower-legacy/tags/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/">프로젝트</a> <a class="post-tag" href="/satinbower-legacy/tags/leetcode/">LeetCode</a> <a class="post-tag" href="/satinbower-legacy/tags/%EB%94%A5%EB%9F%AC%EB%8B%9D/">딥러닝</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">새 버전의 콘텐츠를 사용할 수 있습니다.</p><button type="button" class="btn btn-primary" aria-label="Update"> 업데이트 </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/satinbower-legacy/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">검색 결과가 없습니다.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/satinbower-legacy/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/satinbower-legacy/app.js"></script>
