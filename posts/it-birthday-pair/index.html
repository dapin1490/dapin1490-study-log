<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="prefer-datetime-locale" content="ko"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="[알고리즘] 알고리즘 만들고 검증, 평가하기: 생일 pair 존재 확률" /><meta name="author" content="dapin1490" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="Trust me I’m a talking potato" /><meta property="og:description" content="Trust me I’m a talking potato" /><link rel="canonical" href="https://dapin1490.github.io/satinbower-legacy/posts/it-birthday-pair/" /><meta property="og:url" content="https://dapin1490.github.io/satinbower-legacy/posts/it-birthday-pair/" /><meta property="og:site_name" content="새틴바우어" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-03-04T11:27:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[알고리즘] 알고리즘 만들고 검증, 평가하기: 생일 pair 존재 확률" /><meta name="twitter:site" content="@dapin1490" /><meta name="twitter:creator" content="@dapin1490" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"dapin1490"},"dateModified":"2023-03-06T14:21:42+09:00","datePublished":"2023-03-04T11:27:00+09:00","description":"Trust me I’m a talking potato","headline":"[알고리즘] 알고리즘 만들고 검증, 평가하기: 생일 pair 존재 확률","mainEntityOfPage":{"@type":"WebPage","@id":"https://dapin1490.github.io/satinbower-legacy/posts/it-birthday-pair/"},"url":"https://dapin1490.github.io/satinbower-legacy/posts/it-birthday-pair/"}</script><title>[알고리즘] 알고리즘 만들고 검증, 평가하기: 생일 pair 존재 확률 | 새틴바우어</title><link rel="apple-touch-icon" sizes="180x180" href="/satinbower-legacy/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/satinbower-legacy/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/satinbower-legacy/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/satinbower-legacy/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/satinbower-legacy/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="새틴바우어"><meta name="application-name" content="새틴바우어"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/satinbower-legacy/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/satinbower-legacy/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/satinbower-legacy/" class="mx-auto"> <img src="/satinbower-legacy/assets/img/profile_image.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/satinbower-legacy/">새틴바우어</a></div><div class="site-subtitle font-italic">dapin1490's hand-made study blog</div></div><ul class="w-100"><li class="nav-item"> <a href="/satinbower-legacy/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>홈</span> </a><li class="nav-item"> <a href="/satinbower-legacy/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>카테고리</span> </a><li class="nav-item"> <a href="/satinbower-legacy/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>태그</span> </a><li class="nav-item"> <a href="/satinbower-legacy/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>아카이브</span> </a><li class="nav-item"> <a href="/satinbower-legacy/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>정보</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/dapin1490" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/dapin1490" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['dapin1490','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/satinbower-legacy/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/satinbower-legacy/"> 홈 </a> </span> <span>[알고리즘] 알고리즘 만들고 검증, 평가하기: 생일 pair 존재 확률</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 포스트</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="검색..."> </span> <span id="search-cancel" >취소</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4 pb-5"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>[알고리즘] 알고리즘 만들고 검증, 평가하기: 생일 pair 존재 확률</h1><div class="post-meta text-muted"> <span> 게시 <em class="" data-ts="1677896820" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2023-03-04 </em> </span> <span> 업데이트 <em class="" data-ts="1678080102" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2023-03-06 </em> </span><div class="d-flex justify-content-between"> <span> By <em> dapin1490 </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5659 단어"> <em>31 분</em>읽는 시간</span></div></div></div><div class="post-content"><style> figure { text-align: center; }</style><h2 id="table-of-contents"><span class="mr-2">Table of Contents</span><a href="#table-of-contents" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><a href="#할-일">할 일</a><li><a href="#문제-설명">문제 설명</a><li><a href="#문제-풀기">문제 풀기</a><ul><li><a href="#수작업-해결">수작업 해결</a><li><a href="#알고리즘-구상-생일-쌍-찾기">알고리즘 구상: 생일 쌍 찾기</a><li><a href="#알고리즘-구상-생일-쌍이-존재할-확률">알고리즘 구상: 생일 쌍이 존재할 확률</a><li><a href="#실험과-증명">실험과 증명</a><ul><li><a href="#귀납적-증명">귀납적 증명</a><li><a href="#효율성-계산">효율성 계산</a><li><a href="#효율성-계산-chatgpt-풀이">효율성 계산: chatGPT 풀이</a><li><a href="#의사-코드">의사 코드</a><li><a href="#코드-작성">코드 작성</a></ul><li><a href="#알고리즘-개선">알고리즘 개선</a><ul><li><a href="#수정한-알고리즘">수정한 알고리즘</a></ul></ul><li><a href="#진짜-이론대로-나오는지-실험하기">진짜 이론대로 나오는지 실험하기</a><li><a href="#추가-궁금한-점">추가 궁금한 점</a><li><a href="#참고-자료">참고 자료</a></ul><h1 id="할-일">할 일</h1><ul><li>모든 과제는 블로그에 올리고 LMS에 링크 제출하기<li>교수님을 위해 한국어로 쓰기<li>다음주 화요일 12:00까지(수업은 목요일)<li>정당한 사유 없이 지각 제출 불가<li>만약 다른 학생과 토의했다면 그것도 모두 기록할 것. 과제를 위해 한 모든 활동을 기록하라.</ul><p><br /></p><ol><li>생일 데이터 다운로드: 개인정보 보호 문제로 파일은 비공개, 무작위로 생성한 생일 사용 가능.<li>생일이 같은 두 사람의 쌍을 수동으로 결정한다. 해결 방법을 설명한다.<li>의사 코드를 사용하여 첫 번째 질문에 대한 알고리즘을 개발한다. (스타일 무관) <em>(이 부분이 이해가 잘 안 돼서 생일 쌍을 찾는 알고리즘과 그게 존재할 확률을 계산하는 알고리즘 2개를 만들었다)</em><li>k명의 학생으로 구성된 학급에 생일이 같은 학생이 2명 이상 있을 확률을 계산하는 코드를 작성한다. 여러 개의 다른 k를 적용한다.<li>한 교실에 학생이 100명일 경우 생일이 같은 학생 한 쌍이 있을 확률이 99.999%임을 증명한다. 이 문제를 해결하기 위해 계산 실험을 수행한다.<ol><li>알고리즘을 구두 설명으로 단어로 설명한다.<li>코딩하기 전에 알고리즘의 정확성을 보이라. 귀납적 증명을 사용하라.<li>효율성을 보이라. 점근 표기법(시간복잡도)을 사용하고 그 이유를 설명한다.<li>설명을 위한 의사 코드를 작성한다.<li>문제를 해결하기 위한 코드를 개발한다.<li>결과를 표시한다.</ol><li>답안을 개선하기 위해 사용 가능한 모든 리소스를 적용하고 원래 솔루션과 다른 솔루션을 비교한다. 어떤 리소스를 어떻게 사용했는지 설명한다.</ol><p><br /></p><ul><li>개인 정보 보호를 위해 생일 데이터는 블로그에 업로드하지 말 것.<li>만약 99.999%라는 확률이 아직도 의심스럽다면 첨부한 동영상을 보라.<br /> <a href="https://youtu.be/LZ5Wergp_PA">https://youtu.be/LZ5Wergp_PA</a></ul><h1 id="문제-설명">문제 설명</h1><p>서로 다른 사람이 23명 있다. 이 중에 생일이 같은 두 사람의 쌍이 존재할 확률은 얼마나 될까? 서로 다른 사람이 100명 있을 때는? <em>(편의상 윤년은 고려하지 않는다)</em></p><p>답은 각각 50% 이상, 99.999% 이상이다. <a href="https://ko.wikipedia.org/wiki/%EC%83%9D%EC%9D%BC_%EB%AC%B8%EC%A0%9C" target="_blank">위키백과</a>를 참고하여 간단히 풀이하자면, 우선 모든 사람의 생일이 모두 다를 확률을 구한 뒤 1에서 빼야 한다. 모든 사람의 생일이 다를 확률은 365일 중 사람 수만큼 비복원추출을 하는 것과 같다. 자세한 식은 위키백과에서 직접 확인하자.</p><h1 id="문제-풀기">문제 풀기</h1><h2 id="수작업-해결"><span class="mr-2">수작업 해결</span><a href="#수작업-해결" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>* 사전에 조사된 수강생 생일 데이터를 엑셀 파일로 받아 이용했다. <em>수동으로 하라고는 했지만 도구를 사용하지 말라는 말은 없었으니까</em></p><ol><li>엑셀로 파일을 열고, 생일을 기준으로 정렬한다.<li>스크롤을 내리면서 서로 같은 두 날짜가 쓰인 행을 찾는다.<li>서로 같은 생일의 쌍만 남기고 나머지 행은 지운다.<li>완성</ol><h2 id="알고리즘-구상-생일-쌍-찾기"><span class="mr-2">알고리즘 구상: 생일 쌍 찾기</span><a href="#알고리즘-구상-생일-쌍-찾기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>사람이 답을 찾을 때는 보통 시각에 의존하니 보기 좋으라고 정렬했지만, 프로그램은 그럴 필요가 없다. 정렬보다 해시 테이블이 빠르다.</p><p>생일을 키로, 이름(또는 개인을 구분할 수 있는 정보)을 값으로 갖는 빈 해시 테이블을 준비해둔다. 생일 데이터를 차례로 읽어들이며 해시 테이블에 같은 생일이 있는지 확인하고 있다면 바로 반환하고, 없다면 해시 테이블에 추가한다. 생일 쌍을 찾아 반환하거나 모든 데이터를 확인할 때까지 반복한다. 생일 쌍이 없다면 <code class="language-plaintext highlighter-rouge">None</code>을 반환한다.</p><h2 id="알고리즘-구상-생일-쌍이-존재할-확률"><span class="mr-2">알고리즘 구상: 생일 쌍이 존재할 확률</span><a href="#알고리즘-구상-생일-쌍이-존재할-확률" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>나는 이번 과제가 잘 이해가 안 되는 게, (1) 주어진 생일 데이터 내에서 생일이 같은 쌍을 찾아내라는 건지, (2) 쌍이 존재할 확률을 구하라는 건지, (3) 무작위로 생일을 배치하고 쌍을 찾아내는 실험을 반복해 통계적 확률이 수학적 확률에 수렴하는지 확인하라는 건지 모르겠다.</p><p>(1) 수업시간에 알고리즘 다 배웠고 증명하는 것도 배웠으니 ‘직접 구상하라’고 하는 건 이상함<br /> (2) 수학 계산만 하면 되니까 굳이 알고리즘이라고 할 게 없음<br /> (3) 어차피 반복 실험을 할 거라면 생일 데이터는 매번 새로운 게 필요하니까 수강생의 생일 데이터를 수집한 의미가 없고, 반복이라는 요소가 추가되었을 뿐 (1)번과 알고리즘은 같음.</p><p>과제 마감 기한이 길지 않아 교수님께 문의 올리고 답변을 기다리기엔 틈틈이 글을 써야 해서 내가 생각하기에 이걸 요구하셨을 것 같다 싶은 것을 하기로 했다(메일을 보내 두기는 했다). 공지에 써있는 것도 ‘확률을 구하라’였고, 참고하라고 올려주신 영상도 저 문제를 확률적으로 증명하는 내용이었지만 그래서는 알고리즘을 검증하고 평가할 게 없으니 (1)번으로 쓰겠다.</p><ol><li>필요한 것은 사람의 수 <code class="language-plaintext highlighter-rouge">k</code>.<li>생일 문제의 공식에 따라 모든 사람의 생일이 다를 확률을 구한다.<li>그 값을 1에서 뺀다.<li>답을 반환한다.</ol><h2 id="실험과-증명"><span class="mr-2">실험과 증명</span><a href="#실험과-증명" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><pre><code class="language-txt">1. 알고리즘을 구두 설명으로 단어로 설명한다.
2. 코딩하기 전에 알고리즘의 정확성을 보이라. 귀납적 증명을 사용하라.
3. 효율성을 보이라. 점근 표기법(시간복잡도)을 사용하고 그 이유를 설명한다.
4. 설명을 위한 의사 코드를 작성한다.
5. 문제를 해결하기 위한 코드를 개발한다.
6. 결과를 표시한다.
</code></pre><p>알고리즘을 말로 설명한 것은 <a href="#알고리즘-구상-생일-쌍-찾기">알고리즘 구상: 생일 쌍 찾기</a> 문단에 있다.</p><h3 id="귀납적-증명"><span class="mr-2">귀납적 증명</span><a href="#귀납적-증명" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>* 내가 구상한 알고리즘이 입력의 크기에 상관 없이 올바르게 동작하는지 보이면 된다고 이해했음.</p><ol><li><code class="language-plaintext highlighter-rouge">k = 0</code><br /> 사람이 없으면 읽을 데이터도 없고 생일도 없으므로 생일이 같은 쌍은 없다.<li><code class="language-plaintext highlighter-rouge">k = 1</code><br /> 사람이 1명밖에 없으므로 생일이 같은 쌍은 찾을 수 없다.<li><code class="language-plaintext highlighter-rouge">k = 2</code><br /> 첫 번째 사람의 데이터를 읽고, 이미 저장된 데이터가 없으므로(저장된 데이터 중 일치하는 생일이 없으므로) 해시 테이블에 저장한다.<br /> 두 번째 사람의 데이터를 읽고, 해시 테이블에 같은 데이터가 있는지 찾는다. 만약 있다면 함께 반환한다.<br /> 만약 없었다면 모든 사람의 데이터를 확인했으므로 <code class="language-plaintext highlighter-rouge">None</code>을 반환한다.<li><code class="language-plaintext highlighter-rouge">k &gt; 2</code><br /> 3번과 같은 과정을 첫 번째 쌍을 찾을 때까지 반복하거나, 없다면 모든 데이터를 확인할 때까지 반복한다.</ol><h3 id="효율성-계산"><span class="mr-2">효율성 계산</span><a href="#효율성-계산" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>이 알고리즘에서 수행해야 하는 과정은 다음과 같다. 입력의 크기는 <code class="language-plaintext highlighter-rouge">n</code>이다.</p><ul><li>데이터 읽기<li>해시 테이블 확인하기<ul><li>해시 테이블에 일치하는 데이터가 있을 경우: pair로 반환하기<li>없을 경우: 해시 테이블에 추가하고 <code class="language-plaintext highlighter-rouge">continue</code>하기</ul></ul><p>데이터를 읽는 과정과 해시 테이블을 확인하는 과정은 별다른 추가 과정을 필요로 하지 않으므로 매 실행마다 <code class="language-plaintext highlighter-rouge">O(1)</code>이다. 해시 테이블이 왜 <code class="language-plaintext highlighter-rouge">O(1)</code>인지에 대해서는 해시 테이블의 개념에 대해 공부하면 알 수 있다.</p><p>해시 테이블에 일치하는 데이터가 있는지 확인하여 반복을 더 할지 결정하는 과정은 입력의 크기에 따라 달라진다. 최선의 경우 2번만 하면 되므로 <code class="language-plaintext highlighter-rouge">O(1)</code>이고, 최악의 경우 모든 입력을 확인하므로 <code class="language-plaintext highlighter-rouge">O(n)</code>이다. <span class="x-understand">최선도 최악도 아닌 평균적인 경우는 어떻게 구해야 할지 모르겠다.</span> 산술적인 평균이라 한다면 <code class="language-plaintext highlighter-rouge">(1 + n) / 2</code>이므로 <code class="language-plaintext highlighter-rouge">O(n)</code>이다.</p><h3 id="효율성-계산-chatgpt-풀이"><span class="mr-2">효율성 계산: chatGPT 풀이</span><a href="#효율성-계산-chatgpt-풀이" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>* 내가 받은 답변을 그대로 번역한 것이다.</p><p>코드의 시간 복잡도는 O(n)이며, 여기서 n은 데이터 집합의 행 수입니다. 이는 코드가 데이터 집합의 각 행을 정확히 한 번씩 반복하고 각 행에 대해 일정한 양의 작업을 수행하기 때문입니다.</p><p><code class="language-plaintext highlighter-rouge">for</code> 루프는 <code class="language-plaintext highlighter-rouge">_data</code>에 있는 행의 인덱스를 반복하므로 정확히 <code class="language-plaintext highlighter-rouge">n</code>번 실행되며, 여기서 <code class="language-plaintext highlighter-rouge">n</code>은 <code class="language-plaintext highlighter-rouge">_data</code>에 있는 행의 수입니다. 루프 내에서 각 반복은 사전 테이블에 액세스하고 업데이트하는 일정한 양의 작업을 수행합니다.</p><p>따라서 코드의 전체 시간 복잡도는 입력 데이터의 크기에 따라 선형적인 O(n)입니다. 이는 생일 문제를 푸는 데 효율적인 시간 복잡도입니다.</p><h3 id="의사-코드"><span class="mr-2">의사 코드</span><a href="#의사-코드" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>빈 해시 테이블을 준비한다(C++ <code class="language-plaintext highlighter-rouge">unordered_map</code>, 파이썬 <code class="language-plaintext highlighter-rouge">dict</code> 등). 키는 생일이고 값은 생일인 사람의 이름(또는 개인을 구분할 수 있는 정보)이다.<li>생일 데이터를 읽어들이며 아래 과정을 반복한다.<ol><li>해시 테이블에 지금 읽어들인 사람의 생일이 이미 존재하는지 확인한다.<li>만약 존재한다면, 찾아낸 값과 함께 생일 쌍으로 반환한다.<li>그렇지 않다면 해시 테이블에 정보를 추가하고 다음 반복으로 <code class="language-plaintext highlighter-rouge">continue</code>한다.</ol><li>모든 데이터를 읽어도 반환할 수 있는 쌍이 없었다면 답이 없는 것으로, <code class="language-plaintext highlighter-rouge">None</code>(사용하는 언어에 따라 <code class="language-plaintext highlighter-rouge">null</code>로 표현하기도 함)을 반환한다.</ol><h3 id="코드-작성"><span class="mr-2">코드 작성</span><a href="#코드-작성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>사용 언어: 파이썬</p><p>파이썬의 딕셔너리(dict, dictionary)는 해시 구조로 이루어져 있으므로(<a href="https://fierycoding.tistory.com/68">참고</a>) 이 알고리즘에서 해시 테이블로 사용할 것이다.</p><p>이 글의 초입에도 쓰여 있지만 생일 데이터는 공개하지 않는다. 대신 아래에 랜덤한 생일 데이터를 생성하는 코드를 추가했으니 직접 해보고 싶다면 그쪽을 복사해서 실행해보자.</p><div class="language-py highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="n">pandas</span> <span class="k">as</span> <span class="n">pd</span>

<span class="c1"># 개인정보 보호를 위해 수강생의 이름을 지우고 번호 인덱스로 대체함
</span><span class="n">file_route</span> <span class="o">=</span> <span class="sa">r</span><span class="sh">'</span><span class="s">algorithm\homework\week01\Algorithms - Birthday Data edited.csv</span><span class="sh">'</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nf">read_csv</span><span class="p">(</span><span class="n">file_route</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="sh">'</span><span class="s">utf-8</span><span class="sh">'</span><span class="p">)</span>
<span class="n">data</span><span class="p">.</span><span class="nf">dropna</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c1"># 수강생 중 생일을 제공하지 않은 데이터는 제외
</span>
<span class="nf">print</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="nf">info</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">find_B_pair</span><span class="p">(</span><span class="n">_data</span><span class="p">):</span>
    <span class="n">table</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># &lt;class 'dict'&gt;
</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">_data</span><span class="p">.</span><span class="n">index</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">_data</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="sh">'</span><span class="s">Birthday</span><span class="sh">'</span><span class="p">]</span> <span class="ow">in</span> <span class="n">table</span><span class="p">:</span>
            <span class="nf">return </span><span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="sh">'</span><span class="s">Birthday</span><span class="sh">'</span><span class="p">]],</span> <span class="n">k</span><span class="p">[</span><span class="sh">'</span><span class="s">Number</span><span class="sh">'</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="sh">'</span><span class="s">Birthday</span><span class="sh">'</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">table</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="sh">'</span><span class="s">Birthday</span><span class="sh">'</span><span class="p">]]</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="sh">'</span><span class="s">Number</span><span class="sh">'</span><span class="p">]</span>

    <span class="k">return</span> <span class="bp">None</span>

<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>  <span class="c1"># 데이터를 무작위로 섞어 10번 반복
</span>    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">sample</span><span class="p">(</span><span class="n">frac</span><span class="o">=</span><span class="mi">1</span><span class="p">).</span><span class="nf">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="nf">find_B_pair</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
</pre></table></code></div></div><h2 id="알고리즘-개선"><span class="mr-2">알고리즘 개선</span><a href="#알고리즘-개선" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>달리 토의할 만한 친구는 없어서 chatGPT에게 ‘생일 문제에 대해 코드를 썼는데, 이걸 개선할 방법이 있느냐’고 물어봤다.<br /> 답변 사항은 다음과 같다.</p><ol><li>코드에 주석을 추가하면 다른 사람이 코드를 이해하는 데 도움이 된다.<br /> * 주석을 한국어로 썼는데, 질문은 영어로 해서 지워뒀었다. 이후 한국어 주석이 그대로 있는 코드로 똑같은 질문을 다시 했으나 똑같은 지적이 돌아온 것으로 보아 GPT는 영어 주석을 요구한 것 같다. 아쉽게도 내가 아직 그 정도 수준은 못된다.<li>보다 설명적인 변수 이름을 사용하라. <code class="language-plaintext highlighter-rouge">for</code> 루프에 사용된 변수 <code class="language-plaintext highlighter-rouge">k</code>의 이름이 설명적이지 않다.<br /> * 다음부터 적극 반영하겠음. 나도 웬만하면 이름은 알아보기 좋게 짓는데 오늘은 <code class="language-plaintext highlighter-rouge">k</code> 자리에 적당히 쓸 이름이 생각나지 않아서 대충 썼었다.<li><code class="language-plaintext highlighter-rouge">if k['Birthday'] in table</code> 대신 try-except 블록을 사용하라. 사전에서 키가 존재하는지 확인하기 위해 if 문을 사용하는 대신 try-except 블록을 사용하여 보다 효율적으로 처리할 수 있다. 예를 들어 다음 코드를 사용할 수 있다:<div class="language-py highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre> <span class="k">try</span><span class="p">:</span>
     <span class="nf">return </span><span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="sh">'</span><span class="s">Birthday</span><span class="sh">'</span><span class="p">]],</span> <span class="n">k</span><span class="p">[</span><span class="sh">'</span><span class="s">Number</span><span class="sh">'</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="sh">'</span><span class="s">Birthday</span><span class="sh">'</span><span class="p">])</span>
 <span class="k">except</span> <span class="nb">KeyError</span><span class="p">:</span>
     <span class="n">table</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="sh">'</span><span class="s">Birthday</span><span class="sh">'</span><span class="p">]]</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="sh">'</span><span class="s">Number</span><span class="sh">'</span><span class="p">]</span>
</pre></table></code></div></div><p>* 좋은 참고가 되었다.</p><li>사전 대신 집합을 사용하라. 생일을 이미 본 적이 있는지 여부만 신경 쓰기 때문에 사전 대신 집합을 사용하여 생일을 저장할 수 있다. 집합은 상수 시간 조회가 가능하므로 이러한 용도로 사전보다 더 빠를 수 있다.<br /> * 이건 GPT가 잘못 생각한 것 같다. 어차피 모든 쌍을 찾는 게 아니긴 했지만 결과를 반환할 때는 생일이 같은 두 사람의 정보도 함께 반환하기 때문에 집합을 이용해 생일만 따로 저장하면 안 된다.<li>오류 처리를 추가하라. 코드에서는 데이터 집합에 생일이 같은 사람이 한 쌍 이상 있다고 가정한다. 이러한 쌍이 없는 경우를 처리하기 위해 오류 처리를 추가할 수 있다.<br /> * 원래 코드에서는 생일 쌍이 없을 경우 <code class="language-plaintext highlighter-rouge">None</code>을 반환하게 해 뒀지만, GPT가 지적한 문제는 쌍이 있는 경우에 반환하는 값의 자료형과 없을 경우에 반환하는 값의 자료형을 통일시키라는 의미인 것 같다. 내가 사용한 언어가 파이썬이 아니었다면 당연히 그렇게 해야 했겠지만 파이썬이라서 대충 쓴 건 맞다. 반성합시다.<br /> * 나중에 GPT가 써준 개선 코드 예시를 봤는데, 결과를 출력하는 부분에서 <code class="language-plaintext highlighter-rouge">None</code>이 반환되었을 경우 <code class="language-plaintext highlighter-rouge">일치하는 쌍이 없습니다</code> 같은 문구를 대신 출력하게 만들라는 뜻이었던 것 같다. 이 코드는 확인만 하면 되는 코드라 굳이 그렇게까지 쓰지는 않았었다.<li>샘플링 코드를 함수 외부로 이동하라. 데이터를 샘플링하고 함수를 호출하는 코드를 함수 외부로 이동하여 함수의 모듈화 및 재사용성을 높일 수 있다.<br /> * 이건 뭘 말하는 건지 모르겠다. 데이터를 섞기 위한 샘플링 코드를 말하는 거라면 이미 함수 밖에 있다.<br /> * 개선 코드 예시를 봤는데 <code class="language-plaintext highlighter-rouge">if __name__ == '__main__':</code>이 추가된 것 이외엔 별 다를 게 없었다. 정말로 어떻게 바꾸라는 건지 모르겠다.</ol><p>GPT의 예시 코드는 생략하겠다. 그걸 그대로 가져다 쓸 마음은 없다. 바꿔도 내 맛대로 바꿔야 내 코드지.</p><h3 id="수정한-알고리즘"><span class="mr-2">수정한 알고리즘</span><a href="#수정한-알고리즘" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>chatGPT의 제안을 반영했다.</p><ol><li>주석을 더 자세히 썼다.<li>대충 지은 변수명을 제대로 개명했다.<li>생일 쌍을 찾는 함수 내에서 테이블에 데이터가 존재하는지 확인하는 부분을 <code class="language-plaintext highlighter-rouge">if-else</code>에서 <code class="language-plaintext highlighter-rouge">try-except</code>로 바꿨다.<li>생일 쌍이 데이터에 존재하지 않았을 경우 <code class="language-plaintext highlighter-rouge">None</code> 대신 “No pair”를 출력한다.</ol><ul><li><code class="language-plaintext highlighter-rouge">if __name__ == '__main__':</code>은 필요성을 느끼지 못해 추가하지 않았다. 이 함수를 모듈로 쓸 생각이라면 추가하는 게 맞지만 현재로서는 이 함수를 모듈로 사용할 생각이 없다.</ul><div class="language-py highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="n">file_route</span> <span class="o">=</span> <span class="sa">r</span><span class="sh">'</span><span class="s">algorithm\homework\week01\Algorithms - Birthday Data edited.csv</span><span class="sh">'</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nf">read_csv</span><span class="p">(</span><span class="n">file_route</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="sh">'</span><span class="s">utf-8</span><span class="sh">'</span><span class="p">)</span>
<span class="n">data</span><span class="p">.</span><span class="nf">dropna</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c1"># 수강생 중 생일을 제공하지 않은 데이터는 제외
</span>
<span class="nf">print</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="nf">info</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">find_birthday_pair</span><span class="p">(</span><span class="n">_data</span><span class="p">):</span>  <span class="c1"># 생일 쌍 찾기
</span>    <span class="n">table</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># &lt;class 'dict'&gt;
</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">_data</span><span class="p">.</span><span class="n">index</span><span class="p">:</span>  <span class="c1"># 데이터를 인덱스대로 순회
</span>        <span class="n">person</span> <span class="o">=</span> <span class="n">_data</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># 데이터 하나씩 가져오기
</span>        <span class="k">try</span><span class="p">:</span>  <span class="c1"># 테이블에 데이터가 존재한다면 다음 코드가 실행됨
</span>            <span class="nf">return </span><span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">person</span><span class="p">[</span><span class="sh">'</span><span class="s">Birthday</span><span class="sh">'</span><span class="p">]],</span> <span class="n">person</span><span class="p">[</span><span class="sh">'</span><span class="s">Number</span><span class="sh">'</span><span class="p">],</span> <span class="n">person</span><span class="p">[</span><span class="sh">'</span><span class="s">Birthday</span><span class="sh">'</span><span class="p">])</span>  <span class="c1"># 생일 쌍 반환
</span>        <span class="k">except</span> <span class="nb">KeyError</span><span class="p">:</span>  <span class="c1"># 테이블에 데이터가 존재하지 않았음
</span>            <span class="n">table</span><span class="p">[</span><span class="n">person</span><span class="p">[</span><span class="sh">'</span><span class="s">Birthday</span><span class="sh">'</span><span class="p">]]</span> <span class="o">=</span> <span class="n">person</span><span class="p">[</span><span class="sh">'</span><span class="s">Number</span><span class="sh">'</span><span class="p">]</span>  <span class="c1"># 테이블에 추가
</span>
    <span class="k">return</span> <span class="bp">None</span>  <span class="c1"># 반복을 다 해도 반환할 게 없었다면 None 반환
</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>  <span class="c1"># 데이터를 무작위로 섞어 10번 반복
</span>    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">sample</span><span class="p">(</span><span class="n">frac</span><span class="o">=</span><span class="mi">1</span><span class="p">).</span><span class="nf">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c1"># 데이터 섞기
</span>    <span class="n">result</span> <span class="o">=</span> <span class="nf">find_B_pair</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">result</span> <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="sh">"</span><span class="s">No pair</span><span class="sh">"</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>  <span class="c1"># 생일 쌍 찾기 결과 출력
</span></pre></table></code></div></div><h1 id="진짜-이론대로-나오는지-실험하기">진짜 이론대로 나오는지 실험하기</h1><ul><li><code class="language-plaintext highlighter-rouge">find_birthday_pair()</code> 함수는 위에서 정의한 것과 같다.<li>1 ~ 365 중 하나를 뽑고 이를 월과 일로 환산하는 방식으로 랜덤한 생일을 생성한다. 굳이 환산하는 이유는 <a href="#추가-궁금한-점">추가 궁금한 점</a> 문단을 보면 알 수 있다.<li><code class="language-plaintext highlighter-rouge">n</code>에 직접 숫자를 대입하여 사람 수를 정할 수 있다.<li><code class="language-plaintext highlighter-rouge">total</code>로 총 실행 횟수를 정할 수 있다.<li>자세한 사항은 주석으로 써두었다.</ul><p><code class="language-plaintext highlighter-rouge">n</code>을 23으로 설정하고 코드를 실행하면 실제로 50% 이상의 확률이 나온다. 아래 코드를 <strong>응용</strong>해 실험한 결과는 다음 링크에서 확인할 수 있다.<br /> <a href="https://www.kaggle.com/code/dapin1490/birthday-problem/">https://www.kaggle.com/code/dapin1490/birthday-problem/</a></p><div class="language-py highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="n">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">import</span> <span class="n">random</span>

<span class="k">def</span> <span class="nf">num_to_day</span><span class="p">(</span><span class="n">_num</span><span class="p">):</span>  <span class="c1"># 1 ~ 365 사이의 수를 1년 중 날짜로 환산(윤년 제외)
</span>    <span class="n">md</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">31</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">28</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">31</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">31</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">31</span><span class="p">),</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">31</span><span class="p">),</span> <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">31</span><span class="p">),</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">31</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">md</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">_num</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="si">:</span><span class="mi">02</span><span class="si">}</span><span class="s">.</span><span class="si">{</span><span class="n">_num</span> <span class="si">:</span><span class="mi">02</span><span class="si">}</span><span class="sh">'</span>
        <span class="n">_num</span> <span class="o">-=</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="bp">None</span>

<span class="k">def</span> <span class="nf">generate_days</span><span class="p">(</span><span class="n">_n</span><span class="p">):</span>  <span class="c1"># 1 ~ 365 사이의 숫자를 랜덤하게 뽑고 날짜로 환산해 임의의 생일 데이터 생성
</span>    <span class="k">return</span> <span class="p">{</span><span class="sh">'</span><span class="s">Number</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">_n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span>
            <span class="sh">'</span><span class="s">Birthday</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="nf">num_to_day</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="nf">randrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">365</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_n</span><span class="p">)]}</span>

<span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># 주어진 데이터에서 생일이 같은 사람의 쌍을 찾은 횟수
</span><span class="n">n</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">randrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># 사람 수
</span><span class="n">total</span> <span class="o">=</span> <span class="mi">500</span>  <span class="c1"># 총 실행 수
</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">total</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="se">\n</span><span class="s">iterate </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">random_data</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nc">DataFrame</span><span class="p">(</span><span class="nf">generate_days</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>  <span class="c1"># 임의의 생일 데이터 생성
</span>    <span class="n">b_pair</span> <span class="o">=</span> <span class="nf">find_birthday_pair</span><span class="p">(</span><span class="n">random_data</span><span class="p">)</span>  <span class="c1"># 생일 쌍 찾기
</span>    <span class="k">if</span> <span class="n">b_pair</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>  <span class="c1"># 생일 쌍이 존재할 경우 카운트 증가
</span>        <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">b_pair</span><span class="p">)</span>  <span class="c1"># 찾아낸 생일 쌍 출력(None이어도 출력)
</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">n = </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s">, rate = </span><span class="si">{</span><span class="n">cnt</span> <span class="o">/</span> <span class="n">total</span> <span class="o">*</span> <span class="mi">100</span><span class="si">}</span><span class="s">%</span><span class="sh">'</span><span class="p">)</span>  <span class="c1"># 설정된 사람 수와 생일 쌍이 존재한 비율 출력
</span></pre></table></code></div></div><h1 id="추가-궁금한-점">추가 궁금한 점</h1><p>365일 중 하루를 뽑아서 어떤 날이 뽑힐 확률과, 12월 중 하나를 뽑고 그 달에 있는 28/30/31일 중 하루를 뽑아서 어떤 날이 뽑힐 확률이 같을까, 다를까?</p><p>확률과 통계는 많이 까먹었지만 내가 아는 선에서 생각해본다면 다를 것 같다. 365일 중 하루를 뽑는 건 모든 날짜가 동일하게 <code class="language-plaintext highlighter-rouge">1/365</code>의 확률을 갖지만, 달과 일을 따로 뽑으면 일자별로 뽑힐 확률이 다를 것 같다.</p><p>예를 들어 2월 28일이 뽑힐 확률이라고 치자. 365일 중 하루를 뽑는다면 <code class="language-plaintext highlighter-rouge">1/365</code>이다. 달과 일을 뽑는다면 <code class="language-plaintext highlighter-rouge">1/12 * 1/28 = 1/336</code>이다. 다른 거 맞네.</p><p>질문 하나만 더 해보자. 그렇다면 달과 일을 따로 뽑아도 모든 확률의 합은 1이 될까?</p><p>계산을 역순으로 생각해보자. 2월 28일이 뽑힐 확률은 <code class="language-plaintext highlighter-rouge">1/12 * 1/28 = 1/336</code>이었다. 이 확률은 2월 내의 모든 날짜가 동일하게 갖고, 그 합은 <code class="language-plaintext highlighter-rouge">1/12</code>이다. 그리고 <code class="language-plaintext highlighter-rouge">1/12</code>는 12월 중 2월이 뽑힐 확률과 같으며 이는 12개 월이 모두 동일하게 갖는다. 12개 월이 뽑힐 확률의 합은 <code class="language-plaintext highlighter-rouge">1</code>이다. 고로 달과 일을 따로 뽑으면 각 날짜가 뽑힐 확률은 동일하지 않지만 전체 확률의 합은 1이다.</p><h1 id="참고-자료">참고 자료</h1><ol><li>생일 문제 - 위키백과, <a href="https://ko.wikipedia.org/wiki/%EC%83%9D%EC%9D%BC_%EB%AC%B8%EC%A0%9C" target="_blank">https://ko.wikipedia.org/wiki/생일_문제</a><li>파이썬의 딕셔너리는 어떻게 구현되어 있을까? -해시-, <a href="https://fierycoding.tistory.com/68" target="_blank">https://fierycoding.tistory.com/68</a><li>Pandas에서 DataFrame 행을 무작위로 섞는 방법, <a href="https://www.delftstack.com/ko/howto/python-pandas/how-to-randomly-shuffle-dataframe-rows-in-pandas/" target="_blank">https://www.delftstack.com/ko/howto/python-pandas/how-to-randomly-shuffle-dataframe-rows-in-pandas/</a><li>파이썬 난수(random) 생성, <a href="https://yeolco.tistory.com/95" target="_blank">https://yeolco.tistory.com/95</a><li>(Python) 숫자 포맷팅, <a href="https://jaeworld.github.io/python/python_number_format/" target="_blank">https://jaeworld.github.io/python/python_number_format/</a><li>[Pandas] 리스트, 딕셔너리 자료형을 데이터프레임, Series로 바꾸기, <a href="https://jimmy-ai.tistory.com/89" target="_blank">https://jimmy-ai.tistory.com/89</a><li>chatGPT와 대화하기, <a href="https://chat.openai.com/chat" target="_blank">https://chat.openai.com/chat</a></ol></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/satinbower-legacy/categories/it/'>IT</a>, <a href='/satinbower-legacy/categories/algorithm/'>Algorithm</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/satinbower-legacy/tags/%EC%A7%80%EC%8B%9D/" class="post-tag no-text-decoration" >지식</a> <a href="/satinbower-legacy/tags/it/" class="post-tag no-text-decoration" >IT</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 이 기사는 저작권자의 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.ko"> CC BY-NC-ND 4.0 </a> 라이센스를 따릅니다.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">공유하기</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%5B%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%5D+%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98+%EB%A7%8C%EB%93%A4%EA%B3%A0+%EA%B2%80%EC%A6%9D%2C+%ED%8F%89%EA%B0%80%ED%95%98%EA%B8%B0%3A+%EC%83%9D%EC%9D%BC+pair+%EC%A1%B4%EC%9E%AC+%ED%99%95%EB%A5%A0+-+%EC%83%88%ED%8B%B4%EB%B0%94%EC%9A%B0%EC%96%B4&url=https%3A%2F%2Fdapin1490.github.io%2Fsatinbower-legacy%2Fposts%2Fit-birthday-pair%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="링크 복사하기" data-title-succeed="링크가 복사되었습니다!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">최근 업데이트</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/satinbower-legacy/posts/backend-internet-230704/">[Backend] 인터넷이 뭔데</a><li><a href="/satinbower-legacy/posts/it-boj-1254/">[python] 백준 1254 팰린드롬 만들기</a><li><a href="/satinbower-legacy/posts/py-exe-release/">[python] GUI 프로그램 exe 만들고 배포하기, 소멸자와 로깅</a><li><a href="/satinbower-legacy/posts/daily-230617/">23년 1학기 14주 수업</a><li><a href="/satinbower-legacy/posts/chatgpt-230103/">Unity vs Unreal Engine</a></ul></div><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/satinbower-legacy/tags/%EC%A7%80%EC%8B%9D/">지식</a> <a class="post-tag" href="/satinbower-legacy/tags/it/">IT</a> <a class="post-tag" href="/satinbower-legacy/tags/%EB%82%B4%EA%B0%80-%ED%95%B4%EB%83%84/">내가 해냄</a> <a class="post-tag" href="/satinbower-legacy/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/">자료구조</a> <a class="post-tag" href="/satinbower-legacy/tags/%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/">문제풀이</a> <a class="post-tag" href="/satinbower-legacy/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a> <a class="post-tag" href="/satinbower-legacy/tags/%EA%B3%BC%EC%A0%9C/">과제</a> <a class="post-tag" href="/satinbower-legacy/tags/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/">프로젝트</a> <a class="post-tag" href="/satinbower-legacy/tags/leetcode/">LeetCode</a> <a class="post-tag" href="/satinbower-legacy/tags/%EB%94%A5%EB%9F%AC%EB%8B%9D/">딥러닝</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">바로가기</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>관련된 글</h3><div class="card-deck mb-4"><div class="card"> <a href="/satinbower-legacy/posts/it-backtracking/"><div class="card-body"> <em class="small" data-ts="1643382000" data-df="YYYY-MM-DD" > 2022-01-29 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>백트래킹</h3><div class="text-muted small"><p> 2580 스도쿠 미해결로 인해 풀이 대신 공부함 문제 참고(출처 : 백준) 15649 N과 M (1), 15650 N과 M (2), 15651 N과 M (3), 15652 N과 M (4) 9663 N-Queen, 2580 스도쿠 목차 - 재귀와 호출 스택 - 깊이 우선 탐색 - 백트래킹 재귀와 호출 스택 가볍게 “재귀”의 정의...</p></div></div></a></div><div class="card"> <a href="/satinbower-legacy/posts/it-counting-sort/"><div class="card-body"> <em class="small" data-ts="1643382000" data-df="YYYY-MM-DD" > 2022-01-29 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>카운팅 정렬(+ 선택 정렬)</h3><div class="text-muted small"><p> 이 수는 몇 개 있으니까 여기 놓고 저 수는 몇 개 있으니까 저기 놓고… 더보기 많고 많은 정렬 알고리즘 중 정렬할 수의 범위가 한정적일 때 쓸 수 있는 카운팅 정렬을 공부해 보자. 선택 정렬은 덤이다. 1. 정렬 알고리즘 위키백과에 따르면 ‘원소들을 번호순이나 사전 순서와 같이 일정한 순서대로 열거하는 알고리즘’이라고 한다. 선택 정렬...</p></div></div></a></div><div class="card"> <a href="/satinbower-legacy/posts/it-quick-sort/"><div class="card-body"> <em class="small" data-ts="1644073200" data-df="YYYY-MM-DD" > 2022-02-06 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>퀵 정렬</h3><div class="text-muted small"><p> 올림피우스는 결승점의 절반을 가고, 그 나머지 절반의 절반을 가고, 또 그 절반을 가고… 더보기 데이터를 빠르게 반으로 갈라버리는 퀵 정렬을 배워보자. 부제목에 쓰인 이야기는 제논의 역설 중 하나이다. ‘아킬레우스와 거북이의 경주’도 있는데 재밌으니 한번 찾아보자. - 알아야 할 것 0. 재귀 → 백트래킹 1. 분할 정복 2. 퀵 정렬 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/satinbower-legacy/posts/it-immersive-content-workshop/" class="btn btn-outline-primary" prompt="이전 글"><p>실감미디어콘텐츠 워크샵 후기</p></a> <a href="/satinbower-legacy/posts/it-leetcode-230307/" class="btn btn-outline-primary" prompt="다음 글"><p>[LeetCode][py] 912. Sort an Array</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/dapin1490">dapin1490</a>. <span data-toggle="tooltip" data-placement="top" title="명시되지 않는 한 이 사이트의 블로그 게시물은 작성자의 Creative Commons Attribution 4.0 International(CC BY-NC-ND 4.0) 라이선스에 따라 사용이 허가되었습니다.">일부 권리 보유</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/satinbower-legacy/tags/%EC%A7%80%EC%8B%9D/">지식</a> <a class="post-tag" href="/satinbower-legacy/tags/it/">IT</a> <a class="post-tag" href="/satinbower-legacy/tags/%EB%82%B4%EA%B0%80-%ED%95%B4%EB%83%84/">내가 해냄</a> <a class="post-tag" href="/satinbower-legacy/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/">자료구조</a> <a class="post-tag" href="/satinbower-legacy/tags/%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/">문제풀이</a> <a class="post-tag" href="/satinbower-legacy/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a> <a class="post-tag" href="/satinbower-legacy/tags/%EA%B3%BC%EC%A0%9C/">과제</a> <a class="post-tag" href="/satinbower-legacy/tags/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/">프로젝트</a> <a class="post-tag" href="/satinbower-legacy/tags/leetcode/">LeetCode</a> <a class="post-tag" href="/satinbower-legacy/tags/%EB%94%A5%EB%9F%AC%EB%8B%9D/">딥러닝</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">새 버전의 콘텐츠를 사용할 수 있습니다.</p><button type="button" class="btn btn-primary" aria-label="Update"> 업데이트 </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/satinbower-legacy/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">검색 결과가 없습니다.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/satinbower-legacy/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/satinbower-legacy/app.js"></script>
