[ { "title": "한글과 영어 폰트 따로 설정하기", "url": "/satinbower-legacy/posts/daily-230704/", "categories": "내가 해냄", "tags": "내가 해냄", "date": "2023-07-04 16:12:00 +0900", "snippet": "오늘따라 문득 블로그 한글 폰트는 나눔고딕으로 쓰고 영어 폰트는 Consolas로 쓰고 싶다는 느낌이 강하게 들어서 좀 찾아봤다. 전체 폰트는 원래 알던 CSS 그대로 바꾸면 되고, 이제 거기서 글자별로 따로 설정하는 옵션을 찾아야 했다. 한컴에서 한글 써보면 한글 글씨체랑 영어 글씨체를 따로 설정할 수 있었으니 이것도 되지 않을까 하는 근거 없는 확신이 있기도 했다.어쨌든, 성공했으니까 이 글을 쓰는 거지. 참고 링크는 @font-face unicode-range 사용법이다. 이 블로그는 chirpy 테마인데 css 파일이 여러 개로 나뉘어 있어서 그 중에 폰트를 import하는 부분과 font-family로 설정하는 부분이 있는 파일을 찾아서 바꿔뒀다.근데 좀 문제가 있긴 했다. 처음엔 Consolas라는 이름으로 나눔고딕과 Roboto Mono를 섞어서 설정하고 제대로 적용되는 걸 확인했는데, Consolas가 마이크로소프트 서체래서 괜히 저작권 관련 문제가 생길까봐 이름을 바꿨더니 적용이 안 됐다. 다시 consolas로 되돌리니까 적용이 잘 되긴 했는데 왜 됐는지, 왜 안됐는지 이유는 모른다." }, { "title": "[Backend] 인터넷이 뭔데", "url": "/satinbower-legacy/posts/backend-internet-230704/", "categories": "IT, Backend", "tags": "지식, IT, Backend, internet, network", "date": "2023-07-04 13:16:00 +0900", "snippet": "ToC Intro 개요 네트워크와 인터넷 인터넷의 작동 과정 프로토콜 기본 용어 HTTP와 HTTPS TCP/IP SSL/TLS 인터넷 최신 트렌드 요약Introroadmap.sh의 백엔드 로드맵에 나오는 순서대로 정리하면서 공부하기로 했다.원문 출처: cs.fyi - How does the Internet Work?개요인터넷이 뭐고, 어떻게 작동하는지 알기 위해 필요한 기본 개념에 대해 얕게 훑어본다. 인터넷은 네트워크로 이루어지고, 네트워크는 각각의 컴퓨터와 기타 장치로 이루어지므로 네트워크부터 인터넷의 대략적인 원리, 통신 프로토콜 순서로 알아본다.네트워크와 인터넷 네트워크: 서로 연결된 컴퓨터 또는 기타 장치의 그룹 인터넷: 네트워크 간의 연결. 1960년대 후반 미국 국방부가 핵 공격을 견딜 수 있는 분산형 통신 네트워크를 만들기 위한 수단으로 개발했다. 현재는 대부분의 최신 소프트웨어 애플리케이션의 구축 기반이다.인터넷의 작동 과정 인터넷의 작동: 표준화된 프로토콜을 사용해 장치와 시스템을 서로 연결하여 작동한다. 프로토콜: 장치 간에 정보가 교환되는 방식을 정의하고 데이터가 안정적이고 안전하게 전송되도록 보장.인터넷의 핵심은 서로 연결된 라우터로 구성된 글로벌 네트워크로, 서로 다른 장치와 시스템 간의 트래픽을 라우팅한다. 인터넷을 통해 데이터를 전송하는 과정은 다음과 같다. 데이터를 작은 패킷으로 분할 디바이스에서 라우터로 전송 라우터가 패킷을 검사 목적지로 향하는 경로의 다음 라우터로 패킷 전달 최종 목적지에 도달할 때까지 전송 반복패킷을 올바르게 주고받기 위해 Internet Protocol(IP)과 Transmission Control Protocol(TCP) 등 다양한 프로토콜을 사용한다. IP는 패킷을 목적지로 라우팅하고, TCP는 패킷이 올바른 순서로 전송되게 보장한다. 이외에도 인터넷 통신, 데이터 교환 관련 기술/프로토콜에는 DNS, HTTP, SSL/TLS 등이 있다.프로토콜기본 용어 Packet: 인터넷을 통해 전송되는 작은 데이터 단위 Router: 서로 다른 네트워크 간에 데이터 패킷을 전달하는 장치 IP Address: 네트워크의 각 장치에 할당된 고유 식별자로, 데이터를 올바른 목적지로 라우팅하는 데 사용된다. 일반적으로 “192.168.1.1”과 같이 온점으로 구분된 4개의 숫자로 표시한다. Domain Name: 사람이 읽을 수 있는 웹사이트 및 인터넷 리소스 식별자. 일반적으로 온점으로 구분된 두 개 이상의 부분으로 구성되며 “google.com”과 같은 것을 말한다. Domain Name은 DNS를 통해 IP 주소로 변환된다. DNS(Domain Name System): Domain Name을 IP 주소로 변환. 사용자가 도메인 이름을 입력하면 컴퓨터는 DNS를 통해 IP 주소로 변환한 후 해당 주소에 연결한다. HTTP: Hypertext Transfer Protocol은 클라이언트(예: 웹 브라우저)와 서버(예: 웹사이트) 간에 데이터를 전송하는 데 사용된다. HTTPS: 클라이언트와 서버 간의 보안 통신을 제공하는 데 사용되는 암호화된 HTTP 버전 SSL/TLS: Secure Sockets Layer 및 Transport Layer Security 프로토콜은 인터넷을 통한 보안 통신을 제공하는 데 사용된다. 프로토콜: 장치와 시스템 간에 정보가 교환되는 방식을 정의하는 규칙과 표준 Internet Protocol(IP): 데이터 패킷을 목적지로 라우팅 Transmission Control Protocol(TCP): 패킷이 안정적이고 효율적으로 전송되도록 보장 User Datagram Protocol(UDP): 패킷이 안정적이고 효율적으로 전송되도록 보장 Domain Name System(DNS): 도메인 이름을 IP 주소로 변환 HTTP: 클라이언트와 서버 간 데이터 전송 표준화된 프로토콜 사용의 이점: 서로 다른 제조업체/공급업체의 장치와 시스템이 원활하게 통신할 수 있음 (하드웨어/시스템이 달라도 별다른 어댑터 없이 일정한 통신이 가능함)HTTP와 HTTPSHTTP(Hypertext Transfer Protocol)와 HTTPS(HTTP Secure)는 인터넷 기반 애플리케이션과 서비스에서 가장 일반적으로 사용되는 두 가지 프로토콜이다. HTTP: 클라이언트와 서버 간에 데이터를 전송하는 데 사용하는 프로토콜. 웹사이트를 방문하면 브라우저가 사용자의 요청에 따라 서버에 HTTP 요청을 보내고 서버는 요청한 데이터가 포함된 HTTP 응답을 클라이언트에 보낸다. HTTPS: SSL/TLS(Secure Sockets Layer/Transport Layer Security) 암호화를 사용해 클라이언트와 서버가 주고받는 데이터를 암호화한다. 로그인, 결제 정보, 개인 데이터 같은 민감 정보를 보호하는 데 도움이 된다. 웹사이트를 방문했을 때 주소 표시줄에 자물쇠 아이콘이 있고 주소가 https로 시작하면 연결이 안전함을 나타내는 것이다.TCP/IPTCP/IP(Transmission Control Protocol/Internet Protocol)는 대부분의 인터넷 기반 애플리케이션과 서비스에서 사용되는 기본 통신 프로토콜이다. 이 프로토콜은 서로 다른 기기에서 실행되는 애플리케이션 간에 데이터를 안정적으로, 순서대로, 오류를 확인하며 전달할 수 있도록 한다. Port: 장치에서 실행 중인 애플리케이션 또는 서비스를 식별하는 데 사용. 각 애플리케이션 또는 서비스에는 고유 포트 번호가 할당되어 데이터를 올바른 대상으로 전송할 수 있다. Socket: IP 주소와 포트 번호의 조합으로, 통신을 위한 특정 엔드포인트를 나타낸다. 장치 간 연결을 설정하고 애플리케이션 간에 데이터를 전송하는 데 사용. Connection: 두 장치가 서로 통신하고자 할 때 두 소켓 간에 연결이 설정된다. 연결 설정 과정에서 장치는 데이터가 전송되는 방식을 결정하는 최대 segment 크기 및 window 크기와 같은 다양한 매개 변수를 협상한다negotiate. Data transfer: 연결이 설정되면 각 장치에서 실행 중인 애플리케이션 간에 데이터를 전송할 수 있다. 데이터는 일반적으로 segment로 전송되며, 각 segment에는 안정적인 전송을 보장하기 위해 시퀀스 번호와 기타 메타데이터가 포함되어 있다. TCP/IP로 애플리케이션을 구축할 때는 애플리케이션이 적절한 포트, 소켓 및 연결과 함께 작동하도록 설계되었는지 확인해야 한다. TCP/IP에서 일반적으로 사용되는 프로토콜과 표준: HTTP, FTP(File Transfer Protocol), SMTP(Simple Mail Transfer Protocol) 등SSL/TLS SSL/TLS: 인터넷을 통해 전송되는 데이터를 암호화하는 데 사용되는 프로토콜. 일반적으로 웹 브라우저, 이메일 클라이언트, 파일 전송 프로그램과 같은 애플리케이션에 보안 연결을 제공하는 데 사용. Certificates: SSL/TLS 인증서는 클라이언트와 서버 간의 신뢰를 구축하는 데 사용된다. 인증서에는 서버의 신원에 대한 정보가 포함되어 있으며 신뢰할 수 있는 제3자(인증 기관)가 서명하여 진위 여부를 확인한다. Handshake: 이 프로세스에서 클라이언트와 서버는 정보를 교환하여 보안 연결을 위한 암호화 알고리즘 및 기타 매개변수를 협상한다negotiate. Encryption: 보안 연결이 설정되면 합의된 알고리즘을 사용하여 데이터를 암호화하여 안전하게 전송할 수 있다. 로그인, 결제 정보, 기타 개인 데이터와 같은 민감한 데이터를 전송할 때 애플리케이션이 SSL/TLS를 사용하도록 설계되었는지 확인하는 것이 중요 서버에 유효한 SSL/TLS 인증서를 획득하고 유지해야 하며, SSL/TLS 연결 구성 및 보안을 위한 모범 사례를 따라야 한다. 이를 통해 사용자의 데이터를 보호하고 인터넷을 통한 애플리케이션 통신의 무결성 및 기밀성을 보장할 수 있다.인터넷 최신 트렌드 5G: 최신 모바일 네트워크 기술. 이전 세대보다 빠른 속도, 짧은 지연 시간, 더 큰 용량 제공. 다만 현재는 사장되는 추세이고 대신 6G를 준비하는 단계라고 알고 있다. 5G는 개념은 이상적이고 좋은데 상용화는 못 할 기술이었음(개인 의견). Internet of Things(IoT): 인터넷에 연결되어 데이터를 교환할 수 있는 물리적 장치, 차량, 가전제품 및 기타 사물의 네트워크를 말한다. Artificial Intelligence(AI): 머신러닝과 자연어 처리와 같은 AI 기술은 이미 음성 어시스턴트부터 사기 탐지까지 다양한 애플리케이션과 서비스를 지원하는 데 사용되고 있다. Blockchain: 안전하고 분산된 거래를 가능하게 하는 분산 원장ledger 기술이다. 암호화폐부터 공급망 관리에 이르기까지 다양한 애플리케이션을 구동하는 데 사용되고 있다. Edge computing: 중앙 집중식 데이터 센터가 아닌 네트워크의 엣지edge of the network에서 데이터를 처리하고 저장하는 것을 말한다.요약 인터넷은 표준 통신 프로토콜 세트를 사용하여 데이터를 교환하는 상호 연결된 컴퓨터의 글로벌 네트워크로, 서로 다른 장치와 시스템 간에 트래픽을 전달하는 상호 연결된 라우터로 구성된다. 인터넷은 TCP/IP와 같은 표준화된 프로토콜을 사용하여 장치와 컴퓨터 시스템을 서로 연결하여 작동한다. 패킷, 라우터, IP 주소, 도메인 이름, DNS, HTTP, HTTPS, SSL/TLS 등 기본 개념과 용어 프로토콜은 인터넷을 통한 통신 및 데이터 교환을 가능하게 하여 다양한 제조업체/공급업체의 디바이스와 시스템이 원활하게 통신할 수 있도록 한다." }, { "title": "[python] 백준 1254 팰린드롬 만들기", "url": "/satinbower-legacy/posts/it-boj-1254/", "categories": "IT, 문제풀이", "tags": "지식, IT, 문제풀이, 백준", "date": "2023-06-25 17:40:00 +0900", "snippet": "Table of Contents 문제 예제 계획 풀이 오답 첫 번째 정답 두 번째 정답 문제 백준 1254 팰린드롬 만들기주어진 단어의 뒤에 0개 이상의 문자를 추가해 만들어지는 팰린드롬 단어의 최소 길이를 구하라.예제입력 → 출력 abab → 5 abacaba → 7 qwerty → 11 abdfhdyrbdbsdfghjkllkjhgfds → 38계획처음엔 1213 팰린드롬 만들기 문제랑 같은 논리인 줄 알고 잠깐 시간을 날렸었다.문제를 제대로 이해하고 나서는 투 포인터 탐색으로 양 끝에서부터 글자를 비교하면서 서로 다르면 뒤에 글자를 추가한다는 전제로 포인터를 계속 진행시켜서 최종 개수를 세도록 했는데 틀렸고, 반례도 찾았다.그 후로 투 포인터 탐색으로는 아무리 고민을 해도 답이 안 나오는 것 같아서 어떤 알고리즘을 써야 풀리는지 봤는데 브루트포스라고 해서 금방 해결했다.풀이36분 42초에서 힌트 보고 재시도.46분 45초 정답 통과오답 의도: 주어진 단어의 뒤에 최소한의 글자를 추가해 최소 팰린드롬 길이 출력 투 포인터 탐색 양 끝의 글자가 같으면 그대로 진행 다르면 맨 뒤에 글자를 추가했다는 전제로 왼쪽 포인터 이동, 전체 길이 증가 두 포인터가 만나면 종료 예시 qwe rty qwe r ty- qwer ty-- qwer t y--- qwert y---- qwert y ----- 반례: abaabaccdaba 안 되는 이유: 단어의 맨 뒤에 글자를 추가한다면 처음부터 팰린드롬 검사를 다시 해야 하는데, 이 코드는 당연히 될 거라 전제하고 이어서 진행했다.def min_palindrome(word: str) -&gt; int: ans_len = len(word) left = 0 right = ans_len - 1 while True: if left &gt;= right: break if word[left] != word[right]: ans_len += 1 else: right -= 1 left += 1 return ans_lenprint(min_palindrome(input()))첫 번째 정답팰린드롬이 아닌 것이 확인될 때마다 그 횟수만큼 단어의 뒤에 빈 글자를 추가한 후, 그 빈 글자를 팰린드롬의 정의에 맞게 채우고 다시 팰린드롬 검사. 팰린드롬이 될 때까지 반복. 특징: 필요한 건 단어의 길이뿐인데 팰린드롬 단어를 진짜로 다 만든다. 단점: 그래서 코드가 길고 불필요한 정보를 너무 많이 만든다.def min_palindrome(word: str) -&gt; int: edited_word = word num_char = 0 while not is_pal(edited_word): num_char += 1 edited_word = fill_pal(word + ('-' * num_char)) return len(edited_word)def fill_pal(word: str) -&gt; str: word_lis = list(word) for i in range(len(word_lis) - 1, -1, -1): if word_lis[i] == '-': word_lis[i] = word_lis[len(word_lis) - 1 - i] return to_string(word_lis)def to_string(lis: list) -&gt; str: word = '' for char in lis: word += char return worddef is_pal(word: str) -&gt; bool: for i in range(len(word) // 2): if word[i] != word[len(word) - 1 - i]: return False return Trueprint(min_palindrome(input()))두 번째 정답 개선한 부분: 불필요한 정보를 만들지 않도록 하기 위해 단어의 뒤에 채운 빈 글자를 그대로 두고 팰린드롬을 검사하게 했다. 실행 시간은 이전 정답보다 4ms 감소했다.def min_palindrome(word: str) -&gt; int: while not is_pal(word): word += '-' return len(word)def is_pal(word: str) -&gt; bool: for i in range(len(word) // 2): if word[len(word) - 1 - i] == '-': continue if word[i] != word[len(word) - 1 - i]: return False return Trueprint(min_palindrome(input()))" }, { "title": "[python] 백준 1213 팰린드롬 만들기", "url": "/satinbower-legacy/posts/it-boj-1213/", "categories": "IT, 문제풀이", "tags": "지식, IT, 문제풀이, 백준", "date": "2023-06-24 23:56:00 +0900", "snippet": "Table of Contents 문제 예제 상황 파악과 계획 풀이 첫 번째 답안 두 번째 답안 세 번째 답안 문제 백준 1213 팰린드롬 만들기주어진 문자열을 재조합해 팰린드롬 단어를 만들어라. 불가능할 경우 \"I'm Sorry Hansoo\" 출력.예제 예제 1 입력: AABB출력: ABBA 예제 2 입력: AAABB출력: ABABA 예제 3 입력: ABACABA출력: AABCBAA 예제 4 입력: ABCD출력: I'm Sorry Hansoo 상황 파악과 계획문제에서 요구하는 것: 주어진 글자들을 이용해 팰린드롬 만들기계획: 알파벳 대문자만 주어지므로 카운팅 후 확인 및 팰린드롬 생성 홀수 개 등장한 글자가 2개 이상 있을 경우 팰린드롬 불가 -&gt; \"I'm Sorry Hansoo\" 홀수 개 등장한 글자가 1개 이하일 경우, 해당 글자는 1개만 따로 빼두고 짝수 개 등장한 것으로 취급한다. 짝수 개 등장한 글자를 절반씩 먼저 앞에 놓고, 홀수 개 글자가 있을 경우 가운데 놓고, 이후 앞에 놓은 알파벳의 역순으로 다시 나머지 글자를 놓는다.풀이첫 번째 답안타이머를 늦게 켜서 계획 시간 약간 빼고 정답 확인까지 22분 39초 사실 함수를 정의할 필요까지는 없었는데 코드를 어디 담아 정리하는 게 습관이다. 원래 계획은 사전순으로 팰린드롬 앞부분을 먼저 붙인 다음 사전 역순으로 팰린드롬 뒷부분을 붙이는 거였는데, 순서만 반대이고 똑같은 작업을 굳이 따로 해야 할까 싶어서 한번에 할 방법을 고민하다 팰린드롬의 가운데에서부터 양 옆으로 단어를 연장해가기로 했다. ord()랑 chr() 정도는 이참에 외우면 좋겠다. 항상 까먹어서 다시 검색한다.def make_palindrome(word: str) -&gt; str: alphabets = [0] * 26 int_a = ord('A') ans = \"\" middle_char = None for char in word: # 글자 세기 alphabets[ord(char) - int_a] += 1 for i in range(26): # 팰린드롬 만들기 전 글자 구성 확인 if alphabets[i] % 2 != 0: # 홀수 개 있는 글자 if middle_char is None: # 처음 나왔으면 가운데 글자로 저장 후 짝수 개 취급 middle_char = chr(int_a + i) ans = middle_char # 가운데 글자 먼저 놓기 alphabets[i] -= 1 else: # 또 나왔으면 팰린드롬 불가 return \"I'm Sorry Hansoo\" alphabets[i] //= 2 # 결격사유가 없다면 짝수일 것 for i in range(25, -1, -1): # 양 옆에 짝수 글자 놓기 if alphabets[i] == 0: continue ans = (chr(int_a + i) * alphabets[i]) + ans + (chr(int_a + i) * alphabets[i]) return ansprint(make_palindrome(input()))두 번째 답안첫 번째 답안에서 비슷하게 생긴 반복문을 여러 개 쓰는 것 같아서 합쳐봤다. 글자 수가 짝수인지 홀수인지 확인함과 동시에 팰린드롬 단어를 만들기 때문에 가운데 글자를 넣는 부분이 조금 바뀌었다.채점 시간은 44ms에서 40ms로 줄었다.def make_palindrome(word: str) -&gt; str: alphabets = [0] * 26 int_a = ord('A') ans = \"\" middle_char = None for char in word: # 글자 세기 alphabets[ord(char) - int_a] += 1 for i in range(25, -1, -1): if alphabets[i] == 0: continue if alphabets[i] % 2 != 0: # 홀수 개 있는 글자 if middle_char is None: # 처음 나왔으면 가운데 글자로 저장 후 짝수 개 취급 middle_char = chr(int_a + i) alphabets[i] -= 1 else: # 또 나왔으면 팰린드롬 불가 return \"I'm Sorry Hansoo\" alphabets[i] //= 2 # 결격사유가 없다면 짝수일 것 ans = (chr(int_a + i) * alphabets[i]) + ans + (chr(int_a + i) * alphabets[i]) if middle_char is not None: ans = ans[:len(ans) // 2] + middle_char + ans[len(ans) // 2:] return ansprint(make_palindrome(input()))세 번째 답안최단시간 답안을 봤는데 딕셔너리를 사용하고 있어서 그 아이디어를 빌려 조금 더 바꿔봤다.채점 시간은 40ms 그대로이다.def make_palindrome(word: str) -&gt; str: alpha = {} ans = \"\" middle_char = None for char in word: # 글자 세기 if char in alpha: alpha[char] += 1 else: alpha[char] = 1 for char in sorted(alpha.keys(), reverse=True): if alpha[char] % 2 != 0: # 홀수 개 있는 글자 if middle_char is None: # 처음 나왔으면 가운데 글자로 저장 후 짝수 개 취급 middle_char = char alpha[char] -= 1 else: # 또 나왔으면 팰린드롬 불가 return \"I'm Sorry Hansoo\" alpha[char] //= 2 ans = (char * alpha[char]) + ans + (char * alpha[char]) if middle_char is not None: ans = ans[:len(ans) // 2] + middle_char + ans[len(ans) // 2:] return ansprint(make_palindrome(input()))" }, { "title": "[python] 백준 8979 올림픽", "url": "/satinbower-legacy/posts/it-boj-8979/", "categories": "IT, 문제풀이", "tags": "지식, IT, 문제풀이, 백준", "date": "2023-06-23 20:49:00 +0900", "snippet": "Table of Contents 문제 예제 상황 파악과 계획 풀이 1. 제출 오답 2. 제출 정답 3. 최단시간 답안 문제 백준 8979 올림픽각 국가별 메달 획득 수가 주어진다. 등수는 자신보다 성적이 좋은 국가의 수 + 1로 정한다. 주어진 국가 중 특정 국가의 등수를 계산하라.예제예제 1입력:4 31 1 2 02 0 1 03 0 1 04 0 0 1출력: 2예제 2입력:4 21 3 0 03 0 0 24 0 2 02 0 2 0출력: 2상황 파악과 계획필요한 것: 성적 순 정렬, 특정 국가 찾기, 동점자 제외계획: 금, 은, 동, 국가번호 순으로 튜플을 만들어 정렬. 정렬 결과에서 원하는 국가 찾은 후 해당 인덱스로 등수 계산, 거슬러 올라가며 동점자의 수만큼 등수 차감.풀이정답(100점) 확인까지는 약 30분 걸렸다.1. 제출 오답계획과 유사하게 쓰긴 했는데 인덱스로 등수를 계산하는 과정에서 반례가 발생했다.모든 국가가 동점이거나, 자신이 1등이라 앞 순위가 없는 경우 등 if lis[i][:3] != lis[idx][:3]: 안으로 들어갈 기회가 없으면 등수 값이 업데이트되지 않아 답이 0으로 출력된다.이 답안은 예제 입출력만 통과했다(100점 만점에 8점).n, k = map(int, input().split(' '))lis = []rank = 0idx = 0for i in range(n): country, gold, silver, bronze = map(int, input().split(' ')) lis.append((gold, silver, bronze, country))lis = sorted(lis, reverse=True)for i in range(n): if lis[i][3] == k: idx = i breakfor i in range(idx - 1, -1, -1): if lis[i][:3] != lis[idx][:3]: rank = i + 2 breakprint(rank)2. 제출 정답등수를 계산하는 부분을 바꿔, 국가를 처음 찾았을 때부터 등수를 설정하고 동점자가 발견될 때마다 하나씩 차감하게 했다.n, k = map(int, input().split(' '))lis = []rank = 0idx = 0for i in range(n): country, gold, silver, bronze = map(int, input().split(' ')) lis.append((gold, silver, bronze, country))lis = sorted(lis, reverse=True)for i in range(n): if lis[i][3] == k: idx = i rank = i + 1 breakfor i in range(idx - 1, -1, -1): if lis[i][:3] == lis[idx][:3]: rank -= 1 else: breakprint(rank)3. 최단시간 답안내 답안도 통과를 하긴 했는데, 왠지 조금만 고치면 더 나은 답이 될 것 같아서 최단시간 답안을 찾아봤다. 원래 답안은 등수를 정렬할 때 국가 번호도 같이 정렬되어서 국가 번호가 작을수록 뒤로 가는 문제가 있었는데 이 답안은 딱 필요한 국가만 따로 저장함으로써 아예 국가 번호가 필요 없게 만들었다.import sysinput = sys.stdin.readlinen,k = map(int,input().split())medals = []for _ in range(n): x, g, s, b = map(int,input().split()) medals.append((g, s, b)) if x == k: k = (g, s, b)medals.sort(reverse=True)for i in range(n): if medals[i] == k: print(i+1) break" }, { "title": "디자인패턴 기말고사 필기", "url": "/satinbower-legacy/posts/design-pattern-study/", "categories": "IT", "tags": "지식, IT", "date": "2023-06-19 19:02:00 +0900", "snippet": "패턴 내 클래스의 역할mediator 중재자 클래스: 컴포넌트 간 통신을 조정하기 위한 인터페이스 구체 중재자 클래스: 중재자 인터페이스를 구현, 실제 통신 조정을 수행 동료 클래스: 중재자와 통신할 인터페이스 구체 동료 클래스: 동료 인터페이스 구현observer 관찰 대상: 관찰 대상을 관리하는 인터페이스 구체 관찰 대상: 상태가 변하면 관찰자에게 통보. 관찰자: 관찰 대상으로부터 상태 변화를 통보받음. 구체 관찰자: 관찰 대상으로부터 상태 변화를 통보받으면 관찰 대상의 현재 상태를 확인하고 적절한 동작을 수행함.state 상태: 상태를 나타냄. 각 상태에 따른 행동을 하는 통일된 인터페이스를 정함. 구체 상태: 구체적인 각각의 상태를 표현. 상태 인터페이스 구현. 상황/문맥: 현재 상태를 나타내는 구체 상태 클래스를 갖고 있음(집합 관계).flyweight 플라이: 평소대로 취급하면 프로그램이 무거워져 공유하는게 훨씬 좋은 역할 플라이 공장: 플라이 역할을 만드는 공장의 역할. 일단 만들면 인스턴스를 공유한다. 클라이언트: 플라이 공장으로 플라이를 만들어서 사용함.command 커맨드: 실행될 기능에 대한 인터페이스. 실행될 기능을 execute 메서드로 선언함. 구체 커맨드가 반드시 구현해야 하는 계약서 역할. 구체 커맨드: 실제로 실행되는 기능을 구현. 인보커/호출자: 기능의 실행을 요청하는 호출자 클래스. 커맨드의 레퍼런스를 갖고 있음. 리시버: 구체 커맨드에서 execute 메서드를 구현할 때 필요한 클래스, 구체 커맨드의 기능을 실행하기 위해 사용하는 수신자 클래스decorator 컴포넌트: 기능을 추가할 때 핵심이 되는 역할. 장식의 밑바탕이 됨. 구체 컴포넌트: 컴포넌트 클래스 구현 장식자: 컴포넌트와 동일한 인터페이스를 가짐. 장식자이면서 장식 대상이 됨. 구체 장식자: 구체적인 장식자.chain of responsibility 핸들러/처리자: 요구를 처리하는 클래스들의 인터페이스(API)를 정하는 역할 구체 핸들러: 요구를 처리하는 구체적인 역할 클라이언트: 구체 핸들러에게 요구하는 역할proxy 주체: 프록시와 구체 주체를 동일시하기 위한 인터페이스(API)를 정한다. 구체 주체: 주체를 상속 구현함. 생성이 오래 걸리거나 접근 권한을 제한해야 하는 클래스. 프록시: 주체를 상속 구현하며 클라이언트의 요구를 최대한 직접 처리함. 혼자 처리할 수 없을 때 그제서야 구체 주체 생성하여 위임. 클라이언트: 사용자facade 파사드/정면: 시스템을 구성하고 있는 그 밖의 많은 역할에 대한 ‘단순한 창구’. 높은 레벨에서 단순한 인터페이스(API)를 시스템 외부에 제공. 복잡한 서브 클래스들에 대한 인스턴스 포함 시스템을 구성하는 다수의 클래스: 각각의 임무를 실행하지만 Facade 역할에 대해서는 신경쓰지 않음. 파사드 클래스에서 호출되는 임무를 실행하지만, 다른 클래스가 파사드 클래스를 호출하는 일은 없다. 클라이언트: 파사드 사용자패턴을 적용했을 때의 장단점mediator 중재자가 복잡하게 얽혀 있는 객체들 간의 상호 통신을 중재시키고, 객체들 간의 상호 작용 로직을 Mediator 에 집중시킴으로써 처리를 원할하게 한다. GUI에 효과적. 중재자의 재사용이 어려움. 동료 클래스는 재사용 가능.state 새로운 상태를 추가하는 것은 간단 상태 머신에 몇 가지 상태만 있거나 머신이 거의 변경되지 않을 때상태 패턴을 적용하는 것은 추천되지 않음command 시스템이 확장성이 있으면서 유연성을 가짐. 인보커와 리시버, 커맨드가 각각 캡슐화 되어서 결합도가 낮아진다. 리시버 객체의 동작이 늘어날 때마다 커맨드 클래스가 늘어나기 때문에 클래스가 많아진다.decorator 내용물을 변경하지 않고, 기능을 추가할 수 있다. 단순한 장식으로도 다양한 기능을 추가할 수 있다. 작은 클래스가 증가함. 유사한 작은 클래스들이 많아진다.chain of responsibility 요구하는 사람과 요구를 처리하는 사람을 느슨하게 연결. 이 패턴을 사용하지 않으면, “이 요구는 이 처리자가 처리해야 한다”라는 지식을 누군가 중앙 집중적으로 가지고 있어야 한다. 동적으로 연쇄의 형태를 바꿀 수 있다. 자신의 일에 집중할 수 있다. 유연성은 높지만, 처리 속도는 느리다. 요구와 처리자의 관계가 고정적이고, 처리의 속도가 중요한 경우에는 이 패턴을 사용하지 않는 편이 유효할 수도 있다.proxy 초기화에 시간이 많이 걸리는 대규모 시스템에서 유용하다. 사이즈가 큰 객체가 로딩되기 전에도 프록시를 통해 참조 가능. 실제 객체의 public, protected 메소드를 숨기고 인터페이스를 통해 노출 가능. 로컬에 있지 않고 떨어져있는 객체를 사용 가능. 원래 객체에 접근에 대한 사전처리 가능 객체를 생성할 때 한 단계를 거치게 되므로, 빈번한 객체 생성이 필요한 경우 성능 저하 가능. 프록시 내부에서 객체 생성을 위해 스레드가 생성, 동기화가 구현되어야 하는 경우 성능 저하 가능. 로직이 난해해져 가독성이 떨어질 수 있음.facade 복잡한 하위 시스템에서 코드를 별도로 분리할 수 있다. 파사드는 앱의 모든 클래스에 결합된 전지전능한 객체가 될수 있다.패턴을 적용할만한 상황, 패턴을 사용하면 좋은 경우mediator 복잡하고 다양한 양식 컨트롤로 구성된 대화 상자. 요소 중 일부는 다른 요소와 상호작용 (관계 형성), 코드 재사용 어려움 (얽힌 상호작용에 따라 클래스 종속성 발생)observer 특정 사건에 대해 알림을 받고 싶은 고객과 모든 사건에 대해 알림을 보내고 싶은 쇼핑몰의 이해관계 충돌 문제 MVC 모델state 상태 머신의 경우 보통 많은 조건문으로 구현되는 문제점이 발생 스마트폰 버튼의 상태에 따른 행동 변화flyweight 총을 쏘는 간단한 게임을 개발할 때의 문제. 사격 및 폭발로 인한 총알, 미사일, 파편을 객체로 구현, 몇 분이 지나지 않아 게임은 crash가 나서 종료됨. 많은 데이터를 포함하는 별도의 객체가 문제 RAM의 사용을 줄이는 최적화 아이디어. 인스턴스를 가능한 한 공유시켜서, 쓸데없이 new를 하지 않도록 함. 인스턴스가 필요할 때 마다 new를 하는 것이 아니라, 이미 만들어져 있는 인스턴스를 이용할 수 있으면 공유 텍스트 에디터 프로그램: 각 문자의 위치, 폰트, 크기, 색상 등을 지정할 수 있음. 메모리 용량 사용 최적화를 위해 Flyweight 패턴을 적용함.command 객체 A에서 객체 B의 메소드를 실행하려면 객체 B를 참조하고 있어야 하는 의존성이 발생 텍스트 편집기의 도구 모음(툴바)을 만들기. 일반 버튼에 사용할 Button 클래스, 다양한 버튼은 다 다른 기능을 수행해야 함. 자식 클래스를 만들어 버튼 클릭 시 실행되어야 하는 코드 포함시킴. 엄청난 수의 자식 클래스 생성으로 인한 Button 클래스 의존성 증가, 일부 작업의 경우 여러 위치에서 호출될 가능성도 있음. 중복된 코드 사용, 버튼에 의존하는 메뉴 등 문제 발생. 레스토랑 주문: 고객은 주문만 하면 되지 음식이 어떻게 만들어지는지는 관심 없음. 버튼 하나로 음악플레이어의 음악 재생과 전원을 처리하기 작업들로 객체를 매개변수화하려는 경우 사용, 특정 메서드 호출을 독립실행형 객체로 전환 가능 되돌릴 수 있는 작업을 구현하려고 할 때 사용, 두 가지 단점: 첫째, 앱 일부가 비공개일 수 있으므로 앱의 상태를 저장하는 것이 쉽지 않음. 둘째, 상태 백업들은 상당히 많은 RAM을 소모할 수 있음.decorator 간단한 이메일 알림 시스템을 만드는 과정, Notifier 클래스 기반(단일 send 메소드). 이메일 이외의 알림을 추가하고 싶어 추가 자식 클래스를 생성. 복합적으로 알림을 구현하고 싶을 경우 너무 많은 자식 클래스 조합 발생. 도로 표시 방법 조합하기: 내비게이션 SW에서 도로를 표시하는 기능 java.io 패키지와 Decorator 패턴chain of responsibility 온라인 주문 시스템. 일련의 인증 과정을 거쳐 검증된 사용자만 기능에 접근할 수 있도록 해야 함. 인증 과정은 순서대로 진행되어야 함. 이 상황에서 새 기능을 추가할 때마다 코드는 길고 복잡해진다. -&gt; 특정 행동들을 핸들러라는 독립 실행형 객체들로 변환, 핸들러들을 체인으로 연결하도록 제안. 하나의 핸들러가 주문 처리를 수행한 다음 요청을 체인 아래로 더전달할지를 결정.proxy HTTP 프록시: HTTP 서버(웹 서버)와 HTTP 클라이언트(웹 브라우저) 사이에 들어가, 웹 페이지의 캐싱 등을 실행하는 소프트웨어. 웹 브라우저가 웹 페이지를 표시할 때, 일일이 원격지에 있는 웹서버로부터 페이지를 얻어오는 것이 아니다. 대신에, HTTP 프록시가 캐쉬한 페이지를 얻어온다. 최신 정보가 필요하게 되었거나, 페이지의 유효기간이 다 되었을 때에 비로소 웹 서버로 웹 페이지를 가지러 간다.facade 많은 저레벨 객체를 모두 제어해야 하는 상황. 많은 객체에 의존성을 갖게 되기 때문에 문제 발생. -&gt; 저수준 객체를 깔끔하게 감싼 고수준 객체를 만들면 된다 전화로 주문하기 위해 매장에 전화를 걸었을 때 전화를 받는 교환원. 주문 시스템, 지불 게이트웨이 및 다양한 배송 서비스에 대한 간단한 음성 인터페이스 제공 영화를 볼 때, 복잡한 서브 클래스 없이 해결하기 복잡한 하위 시스템에 대한 제한적이지만 간단한 인터페이스가 필요할 때 사용한다. 하위 시스템을 계층들로 구성하려는 경우 사용한다. (mediator pattern)추가 참고 사항mediator 로직이 중재자에게 집중됨.observer 관찰하는 게 아니라 통지를 받음.state 머신 클래스가 상태 클래스의 객체를 현재 상태로써 갖고, 현 상태에 따른 적절한 동작은 상태 클래스에 위임함. divide and conquer. 개개의 구체적인 상태를 각각 클래스로 나누어서 표현함으로써 문제를 분할함. STD(State Transition Diagram): 시스템의 상태 변화를 표현하기 위해 많이 사용되는 다이어그램flyweight Flyweight 패턴의 핵심은, 인스턴스를 ‘공유’하는 것이다. 반드시 공유해야 할 정보만 공유해야 한다. instrinsic한 정보: 공유되어야 하는 정보, 상태에 의존하지 않는 정보 extrinsic한 정보: 공유시키지 말아야 할 정보, 상태에 따라 바뀌는 정보를 의미함 관리되고 있는 인스턴스는 쓰레기수집(Garbage collection)이 되지 않는다.command 객체의 행위(메소드)를 클래스로 만들어 캡슐화 관심사 분리의 원칙 기반 프로그래밍. 그래픽 인터페이스 레이어와 비즈니스 로직용 레이어의 분리. 그래픽 사용자 인터페이스 객체는 어떤 비즈니스 논리 객체가 요청을 받을지, 요청이 어떻게 처리될지 알 필요가 없어짐decorator 래퍼의 참조 필드가 해당 인터페이스를 따르는 모든 객체를 받도록 처리, 여러 래퍼로 객체를 포장해서 모든 래퍼들의 합성된 행동들을 객체에 추가 가능 중심이 되는 객체에, 장식과 같은 부가적인 기능을 하나씩 입혀서좀 더 목적에 어울리는 객체를 만드는 패턴 재귀적인 구조: 장식을 하는 주체와 장식되는 대상이 같을 수 있다.chain of responsibility 특정 문제 케이스에 대해 문제 해결 과정 시퀀스 다이어그램 그리기 문제 있음. 각 클래스 별 해결 가능한 문제를 정해주고, 클래스마다 문제를 몇 개나 해결할 수 있는지 / 몇 개나 처리하지 못했는지 개수를 세는 문제 있음(뒤에 있는 해결자는 앞에서 해결한 문제는 제외하고 세어야 한다) + 마지막까지 남은 문제를 모두 해결할 수 있는 논리 구조 작성하기 문제 낼 수 있음.proxy 실제 서비스와 같은 이름의 메서드 구현(인터페이스 사용), 실제 서비스에 대한 참조 변수를 가짐, 실제 서비스의 같은 이름을 가진 메서드를 호출하고 그 값을 클라이언트에게 반환, 실제 서비스의 메서드 호출 전후에도 별도의 로직을 수행 가능. 세 가지 프록시 타입은 시험에 나온다. 예시 코드를 바꿔서 낼 것이니, 코드의 어느 부분에서 시간이 걸리는지 확인하고 어떤 유형의 프록시인지 파악하기. 가상 프록시: 꼭 필요한 시점까지 객체 생성 연기. 작은 단위 작업은 프록시가 처리하고, 리소스가 많이 필요한 작업이 요구될 때에만 주체 클래스를 사용하게 함. 속도 향상 타입. 초기화하는데 시간이 많이 걸리는 대규모의 시스템에서 유용하다. 원격 프록시: 원격 객체에 대한 접근을 제어(로컬 환경에 존재하며, 원격 객체에 대한 대변자 역할을 함). 구글 클라우드 서비스와 비슷함. 구글 독스처럼 서로 다른 주소 공간에 있는 객체에 대해 마치 같은 주소 공간에 있는 것처럼 동작하게 함. 멀리 떨어져 있어도 지금 같이 있는 것처럼 보호 프록시: 주체 클래스에 대한 접근을 제어. 객체에 대한 접근 권한을 제어하거나 객체마다 접근 권한을 다르게 할 수 있음. 프록시가 클라이언트의 주체 클래스에 대한 접근을 허용할지 말지 결정. 귀한 곳에 누추하신 분이 오면 입장권 확인 " }, { "title": "[python] GUI 프로그램 exe 만들고 배포하기, 소멸자와 로깅", "url": "/satinbower-legacy/posts/py-exe-release/", "categories": "IT, python", "tags": "지식, IT, python, exe, 배포, 소멸자, GUI", "date": "2023-06-17 19:49:00 +0900", "snippet": "ToC 파이썬 GUI PyQt5 exe 만들기 PyInstaller 소멸자와 로그 남기기 참고 자료파이썬 GUI PyQt5밥 메뉴를 고르는 게 귀찮아서 룰렛을 돌릴 때가 가끔 있는데, 그때마다 인터넷으로 룰렛을 검색해서 돌리는 게 더 귀찮아서 룰렛 프로그램을 직접 만들었다. 처음엔 C++로 콘솔 텍스트 출력만 이용해서 만들었는데, GUI로도 만들면 좋을 것 같아서 뭘 할 수 있을까 찾아봤었다. 처음부터 C++로 만들었으니까 GUI도 C++로 만들고 싶었는데, 찾아서 나오는 것들이 하나같이 영 어려워 보여서 파이썬으로 바꿨다. 파이썬은 PyQt5로 GUI를 만들 수 있다고 해서 보니까 코드가 꽤 쉬워서 기본 기능만 조금 익혀서 일단 완성했다.PyQt5 배우는 건 PyQt5 Tutorial - 파이썬으로 만드는 나만의 GUI 프로그램 보면서 했고, 완성한 프로그램은 dapin1490/roulette_exe에 v230615-h17-40 버전으로 배포했다. 릴리즈가 몇 개 더 있긴 한데, 이것보다 앞선 릴리즈는 C++로 만들었던 프로그램이다.프로그램 자체는 아주 간단해서 하루만에도 다 만들 수 있었지만 나름 배운 건 있었다. GUI 프로그램을 만들 때는 버튼, 입력칸, 텍스트 등등 부품을 조립한다고 생각하면 좀 이해하기 좋더라. 필요한 컴포넌트를 생성하고, 스타일 꾸미고, 적절한 기능 연결하고, 마지막으로 레이아웃에 배치. 프로그램마다 다를 수는 있겠지만 큰 흐름은 이렇게 되는 것 같다.exe 만들기 PyInstaller비주얼 스튜디오는 빌드 메뉴로 바로 exe 파일을 만들 수 있고, 일부 설정만 조금 만지면 배포도 가능하다. 근데 파이썬이나 파이참은 그런 메뉴를 못봐서 찾아보니까 PyInstaller를 사용하면 된다고 한다.PyInstaller는 터미널에서 pip으로 설치하면 되고, 사용할 때는 터미널로 exe 파일을 저장할 곳에 가서 pyinstaller -w -F {작성한 코드 파일 경로}로 실행하면 exe 파일을 만들 수 있다. -w 옵션은 완성된 exe 파일을 실행했을 때 콘솔창이 따로 뜨지 않게 하고, -F는 별도의 파일 없이 exe 파일 하나로 완성되게 한다.소멸자와 로그 남기기룰렛은 간단한 GUI도 만들어봤고 exe도 해봤으니까 이번에는 시험 공부도 할 겸 디자인 패턴 필기 자료를 읽어서 랜덤으로 문제를 내는 프로그램을 만들었는데, 점수 기록을 위해 프로그램 종료 시 세이브 파일에 기록을 남기게 하려고 했다. 가장 처음 한 생각은 어차피 프로그램이 종료될 때 소멸자가 실행될 거니까, 소멸자에서 세이브 파일을 수정하고 끝내면 되겠다 였는데 여기서 문제가 생겼었다. open 함수로 파일을 열어 프로그램 실행 기록을 남기고 다시 닫아야 하는데 해당 함수가 정의되어 있지 않다는 오류가 자꾸 났다. 오류 메시지는 NameError: name 'open' is not defined When trying to log to files였다.오류 메시지로 검색을 해보니 인터프리터가 종료될 때 가비지 콜렉터가 open 함수를 삭제하는 게 소멸자보다 빨리 실행돼서 소멸자 입장에서는 open이 정의되어 있지 않은 게 문제라고 했다. 해결 방법은 로그 작성이 소멸자보다 먼저 실행되게, 명시적으로 실행하는 것. 고치니까 바로 해결됐다. 여기서 새로운 걸 배웠다. 파이썬 인터프리터가 종료될 때, 소멸자보다 먼저 삭제되는 함수가 있고, 그 경우 소멸자에서는 사용할 수 없다.참고 자료 PyQt5 Tutorial - 파이썬으로 만드는 나만의 GUI 프로그램 PyQt5 Tutorial - 파이썬으로 만드는 나만의 GUI 프로그램 / 09. 실행파일 만들기 (PyInstaller) NameError: name ‘open’ is not defined When trying to log to files" }, { "title": "23년 1학기 14주 수업", "url": "/satinbower-legacy/posts/daily-230617/", "categories": "내가 해냄", "tags": "내가 해냄", "date": "2023-06-17 12:38:00 +0900", "snippet": "ToC 모빌리티서비스 초청 강연 모빌리티 진로 추천 알고리즘 소프트웨어분석및설계 소프트웨어디자인패턴모빌리티서비스 기말고사 공지초청 강연모빌리티 모빌리티: 이동성 모빌리티 서비스: 이동성의 자유벤츠벤츠의 부인이 남편의 차를 타고 처음으로 시험주행했다. 이를 시작으로 지금의 브랜드 벤츠가 생겼다. 도전의 시작은 자기 자신을 믿는 것.모빌리티서비스에는 뭐가 있을까?우버, 그램, 쏘카, 그린카, 카카오T 등차량 공유 기반의 모빌리티 서비스 카 헤일링: 요청 시 태워줌. (예: 우버, 그랩, 카카오T 등) 카 쉐어링: 차량을 빌려줌. 대여 및 반납 방식에 따라 구분. (예: 쏘카, 그린카, 피플카 등) 투웨이: 대여 위치로 돌아와 반납 원웨이: 지정된 주차장 아무데나 반납 프리플롯팅: 특정 지역 안에서 자유 픽업/반납 자동차의 전자화 안전하고 튼튼한 자동차, 잘 달리고 잘 멈추는 차 편리/즐거움을 주는 자동차, 환경친화적인 자동차커넥티드 카: 자동차에 통신이 접목됨. 요즘 자동차는 스마트폰만 갖고 가면 문이 알아서 열린다.자율주행이 뭐가 좋냐? 새로운 사업 기회가 열린다. 차에서 운전 안하고 딴짓할 수 있다. 차량에 스크린이 붙을 수 있다.모빌리티는 사람의 자유를 확장한다.왜 모빌리티를 파는가? 인구 고령화, 감소 + 평균수명 연장: 조만간 한국 사회는 초 고령화 사회가 된다. 사회적 양극화: 부익부 빈익빈. 교통 편의 양극화(버스가 하루에 한두번만 다니는 지역이 있다) 기술의 발달: ACES(자율 주행, 통신 연결, 전기차, 공유차 플랫폼). 자동차 산업이 제조업에서 서비스업으로 변화했다. 교통 이용 형태 변화: 젊은 세대에서 소유보다 공유 문화가 확산됨.모빌리티의 가능성 끊임없이 연계될 수 있는 다양한 서비스: 사람이 타는 차량 예약, 물건 주문 및 배달 등미래 모빌리티 차량의 소유는 개인 소유보다 공유로: 변화를 촉진하기 쉬워짐 사람 운전보다 자율 주행으로: “지정 주차 구역”이 필요 없어질 수 있다. 결국엔 공유 자율 주행 차량의 시대차량 생산 기업의 경쟁력 현재 차량 생산 기업의 하드웨어 기술은 이미 포화 상태. 이제는 브랜드 이름만 보고 차를 살 이유가 줄어들고 있다. 그럼에도 계속 브랜드 가치를 유지하려면 그만한 서비스를 제공해야 한다. 그것이 모빌리티 서비스.모빌리티의 사업 기회 패러다임의 변화 인간 삶의 모든 영역전기차는 연료차보다 트렁크가 작은 경우가 많다진로 추천 “지금” 잘 되고 있는 곳은 안 된다. 나중에 물 빠지면 잘린다. 성장 가능성이 보이는 분야에 들어가서 하나씩 쌓아올려라. 무슨 직업을 갖든 기본적인 재무 지식은 반드시 도움이 된다. 꼭 공부하라. 항상 당당할 수 있게 열심히 좀 살아봐라알고리즘knapsack 복습item이 3개 있다. 최대 S = 5이다. X_1 = 10, S_1 = 4 X_2 = 25, S_2 = 2 X_3 = 7, S_3 = 3그래프 관점에서 보자. 처음엔 S가 비어 있는 상태인 하나의 노드에서 시작한다. 이후 아이템을 하나씩 확인하는 것마다 하나의 레이어로 간주한다. 위 상황에서 output 레이어를 포함해 각 레이어가 가질 수 있는 노드는 S = 0일 때부터 S = 5일 때까지 총 6개이다.각 노드는 현재 판단중인 아이템의 번호 X와 현재 채워진 용량 S를 갖는다. (0, 0): 초기 상태 (1, 0): 첫 번째 아이템을 들고 넣을까 말까 고민하고 있음 (2, 0): 첫 번째 아이템을 넣지 않았고, 두 번째 아이템을 넣을까 말까 (2, 4): 첫 번째 아이템을 넣었고, 두 번째 아이템을 넣을까 말까 (3, 0): 아직 아무것도 넣지 않았고, 세 번째 아이템을 넣을까 말까 …위의 과정에서 아이템을 넣거나 넣지 않음에 따라 변화하는 주머니 가치의 총량은 각 간선의 가중치가 된다.소프트웨어분석및설계 지난 주 복습 UP는 기본적으로 반복 개발 모델이다. 점증적 개발. 하나의 분석으로부터 여러 개의 설계를 만들고 각자 릴리즈하거나, 여러 개의 분석으로부터 독립적으로 개발해 릴리즈하는 방법이 있음. 폭포수 모델은 각 단계를 완전히 끝낸 후 다음 단계로 넘어간다. 구현 단계 이전까지는 프로그래머들이 할 일이 없다. BPR: Busines Process Reengineering. ISP 과정 중에서 현재 구현 대상인 비즈니스의 흐름을 검토하고 재설계. ISP: Information Strategy Planning. 큰 시스템 개발하기 전에 개발 비용 견적 산출. 메소드 오버로딩: 같은 이름 다른 파라미터 메소드 오버라이딩: 같은 이름 다른 클래스 설계의 원리 추상화: 복잡한 소프트웨어의 설계를 단순화하고 관리하기 위한 목적으로 세부 정보를 숨긴다. 특정 구현 사례에서 문제와 관련된 범주 및 개념을 분리할 수 있다. 이는 특정 세부 사항(예: 지원 애플리케이션, 운영 체제 소프트웨어 또는 하드웨어)에 의존하지 않도록 코드를 작성할 수 있음을 의미한다. 정보 은닉: 모듈의 선택된 알고리즘 및 데이터 구조와 관련된 내부 설계 결정을 외부로부터 숨기는 설계 원칙. 내부 설계 결정이 변경될 가능성이 가장 높다. 따라서 향후 설계의 유지보수 또는 수정으로 인한 부작용을 줄이고 설계의 다른 모듈에 미치는 영향을 최소화할 수 있다. Separation of concerns: 컴퓨터 프로그램을 여러 섹션으로 분리하여 각 섹션이 별도의 관심사를 다루도록 하는 설계 원칙이다. 우려 사항은 컴퓨터 프로그램의 코드에 영향을 미치는 일련의 정보이다. SoC를 잘 구현하는 프로그램을 모듈형이라고 한다. 모듈화, 즉 관심사 분리는 잘 정의된 인터페이스를 가진 코드 섹션 내부에 정보를 캡슐화함으로써 달성된다. 인터페이스: 인터페이스는 모듈 또는 시스템이 통신하는 액세스 지점이다. 각 추상화에는 추상화에서 예상되는 입력과 출력을 명확하게 설명하는 잘 정의된 인터페이스가 있어야 한다. 객체가 완전히 캡슐화된 경우 인터페이스는 다른 객체가 객체에 액세스할 수 있는 유일한 방법을 설명한다. 일부 프로그래밍 언어는 명시적으로 인터페이스를 지원한다(C#, Java, Objective-C, PHP 등). Modularity: 대규모 소프트웨어 시스템을 상호 연결된 작은 모듈로 분할한다. 모듈은 인터페이스를 통해 상호 연결된다. 상호 연결은 부작용과 유지보수 비용을 피하기 위해 가능한 한 간단하고 적게 이루어져야 한다. (1) 직접 연결: 한 모듈이 다른 모듈을 호출할 수 있다. (2) 간접 연결: 공통 파일 또는 전역 데이터 구조를 공유한다. 분할 정복: 모듈의 세부 설계 또는 알고리즘을 개발할 때 사용되는 개념이다. 문제를 재귀적으로 더 작은 하위 문제로 나누는 것을 기반으로 한다. 백트래킹은 도달한 가장 낮은 하위 문제가 해결되어 원래 문제의 해결에 기여할 때 발생한다. 디자인 패턴: 성공적인 설계의 재사용, 표준 형식 제공, 의사소통 원활하게 해줌, 설계 수정 용이, 설계 문서화 개선, 설계 이해도 상승 디자인 패턴의 구분 생성 패턴: 객체 생성 과정. 추상 팩토리(abstract factory), 빌더(builder), 팩토리 메서드(factory method), 프로토타입(prototype), 싱글톤(singleton) 구조 패턴: 객체와 클래스의 구성. 어댑터(adaptor), 브리지(bridge), 복합(composite), 데코레이터(decorator), 파사드(facade), 플라이웨이트(flyweight), 프락시(proxy) 행동 패턴: 클래스와 객체가 맞물려 동작할 때의 책임. 책임체인(change of responsibility), 명령(command), 인터프리터(interpreter), 반복(iterator), 중재자(mediator), 메멘토(memento), 관찰자(observer), 상태(state), 전략(strategy), 템플릿 메서드(template), 방문자(visitor) 소프트웨어디자인패턴 proxy 패턴 대리인(“프락치”라고 부르던 그 단어가 맞음). 실제 서비스와 같은 이름의 메서드를 구현하고, 실제 서비스에 대한 참조 변수를 갖고, 실제 서비스의 같은 이름을 가진 메서드를 호출하고 값을 클라이언트에게 반환함. 실제 서비스 메서드 호출 전후로 별도 동작 가능. 실제 서비스는 ‘주체’라고 칭하는 것이 통상적이고, 의미가 잘 통한다. 주체 클래스, 대리인 클래스, 공통 인터페이스, 클라이언트. 주체와 대리인은 공통 인터페이스를 상속 구현하고, 클라이언트는 대리인을 사용, 대리인은 주체를 갖고 사용함. 인터페이스는 주체와 대리인을 동일시하기 위함. 주체 클래스를 직접 다루는 부분에서는 synchronized를 사용해야 한다. 중간부터 객체를 생성하는 시퀀스 다이어그램에 유의. 다음 세 가지 프록시 타입은 시험에 나온다. 예시 코드를 바꿔서 낼 것이니, 코드의 어느 부분에서 시간이 걸리는지 확인하고 어떤 유형의 프록시인지 파악하기. 가상 프록시: 꼭 필요한 시점까지 객체 생성 연기. 작은 단위 작업은 프록시가 처리하고, 리소스가 많이 필요한 작업이 요구될 때에만 주체 클래스를 사용하게 함. 속도 향상 타입. 초기화하는데 시간이 많이 걸리는 대규모의 시스템에서 유용하다. 원격 프록시: 원격 객체에 대한 접근을 제어(로컬 환경에 존재하며, 원격 객체에 대한 대변자 역할을 함). 구글 클라우드 서비스와 비슷함. 구글 독스처럼 서로 다른 주소 공간에 있는 객체에 대해 마치 같은 주소 공간에 있는 것처럼 동작하게 함. 멀리 떨어져 있어도 지금 같이 있는 것처럼 보호 프록시: 주체 클래스에 대한 접근을 제어. 객체에 대한 접근 권한을 제어하거나 객체마다 접근 권한을 다르게 할 수 있음. 프록시가 클라이언트의 주체 클래스에 대한 접근을 허용할지 말지 결정. 귀한 곳에 누추하신 분이 오면 입장권 확인 HTTP proxy 예시: Proxy는 HTTP 서버(웹 서버)와 HTTP 클라이언트(웹 브라우저) 사이에 들어가, 웹 페이지의 캐싱 등을 실행하는 소프트웨어. 웹 브라우저가 웹 페이지를 표시할 때, 일일이 원격지에 있는 웹서버로부터 페이지를 얻어오지 않고 HTTP 프록시가 캐쉬한 페이지를 얻어온다. 최신 정보가 필요하게 되었거나, 페이지의 유효기간이 다 되었을 때에 비로소 웹 서버로 웹 페이지를 가지러 간다. 장점: 사이즈가 큰 객체가 로딩되기 전에도 프록시를 통해 참조 가능. 실제 객체의 public, protected 메소드를 숨기고 인터페이스를 통해 노출 가능. 로컬에 있지 않고 떨어져있는 객체를 사용 가능. 원래 객체에 접근에 대한 사전처리 가능. 단점: 객체를 생성할 때 한 단계를 거치게 되므로, 빈번한 객체 생성이 필요한 경우 성능 저하 가능. 프록시 내부에서 객체 생성을 위해 스레드가 생성, 동기화가 구현되어야 하는 경우 성능 저하 가능. 로직이 난해해져 가독성이 떨어질 수 있음. facade 패턴 하우스 인테리어를 한다고 치자. 도배, 목공, 싱크, 타일 등 할 일이 많다. 즉 다뤄야 할 저수준 객체가 많다. 많은 객체에 의존성을 갖게 되는 것이 문제다. -&gt; 많은 저수준 객체들을 감싼 고수준 객체를 만들면 된다. 예를 들면 인테리어 회사. 라이브러리/프레임워크/다른 클래스들의 복잡한 집합에 대한 단순화된 인터페이스를 제공하는 구조적 디자인 패턴. 예를 들면 어떤 회사에 어떤 문의를 하기 위해 전화를 걸었을 때 먼저 전화를 받아 적절한 부서로 연결해주는 상담원. 파사드 클래스, 다수의 서브 클래스, 클라이언트. 클라이언트는 파사드 클래스를 사용하고, 파사드 클래스는 서브 클래스들을 모두 갖고 사용함. 파사드 클래스가 클라이언트용 인터페이스 역할을 함. 파사드는 서브 클래스를 호출하지만 서브 클래스는 파사드를 호출하지 않음. 예제: 영화를 볼 때 복잡한 서브 클래스 없이 해결하기. 서브클래스에는 리모컨, 영화, 음료수 클래스가 있고, 파사드 클래스가 서브클래스들을 모두 혼자 컨트롤함. 사용자는 파사드 클래스를 이용해 ‘영화 보기’ 버튼만 누르면 됨. 복잡한 하위 시스템에 대해 제한적이지만 간단한 인터페이스가 필요할 때 사용, 하위 시스템을 계층으로 구성하려고 할 때 사용(mediator pattern). 장점: 복잡한 하위 시스템에서 코드를 별도로 분리할 수 있다. 단점: 파사드는 앱의 모든 클래스에 결합된 전지전능한 객체가 될수 있다. 패턴별 장단점 모두 알아야 한다. “패턴을 적용했을 때의” 장점과 단점이다." }, { "title": "23년 1학기 13주 수업", "url": "/satinbower-legacy/posts/daily-230607/", "categories": "내가 해냄", "tags": "내가 해냄", "date": "2023-06-07 13:48:00 +0900", "snippet": "ToC 모빌리티서비스 알고리즘 리뷰 피보나치 knapsack 팰린드롬 GA 리뷰 + 공지 소프트웨어분석및설계 소프트웨어디자인패턴모빌리티서비스 라즈베리파이 네트워크 설정을 포함한 SBC setup OpenCR setup roscore bringup, teleop, rqt SLAM, save map알고리즘리뷰DP를 구성하는 세 가지 요소 guess: 문제를 잘 파악 recursion: 재귀 memoization: 잘 기억DP 풀이 순서 부분 문제 결정 각 부분 문제에 소요되는 시간 계산 부분 문제 구현 재귀 설계 원래 문제 해결피보나치memo = {}fib(k): if(k in memo) return memo[k] else if (k &lt;= 2) f= 1 else: f = fib(k - 1) + f(k + 2) memo[k] = f return f해결해야 할 오리지널 문제는 fib(k). 아래에서부터 위로 올라가며 계산하는 문제이기 때문에 Bottom-up 방식이라고 한다.knapsack용량이 정해진 주머니와, 크기와 가치가 정해진 요소들이 있다. 각 요소의 크기와 가치는 S_i, X_i로 나타낸다. suffix i given X guess: in or not in DP[i, X] = max(DP[i + 1, X], DP[i + 1, X - s_i] + X_i)초기 상태: 아무것도 넣지 않음1-1. 첫 번째 아이템을 넣지 않는다.1-1-1. 두 번째 아이템을 넣지 않는다.1-1-2. 두 번째 아이템을 넣는다.1-2. 첫 번째 아이템을 넣는다.1-2-1. 두 번째 아이템을 넣지 않는다.1-2-2. 두 번째 아이템을 넣는다.사람의 생각은 위와 같은 방식으로 진행되지만 실제 컴퓨팅은 주머니가 꽉 찬 상태에서 비워지는 방향으로 이루어짐.팰린드롬주어진 단어에 사용된 알파벳을 조합하여 최대한 긴 팰린드롬 단어를 찾는다. 단어의 의미는 고려하지 않는다.탐색 방식: 양 끝에서 좁혀오는 투 포인터(i, j) 탐색 부분 문제: 동일한 알파벳의 쌍 찾기 X[i] == X[j]: 2 + pal(i + 1, j - 1) X[i] != X[j]: max(pal(i, j - 1), pal(i + 1, j)) i: 0 -&gt; n j: n -&gt; 0 start pal(0, n - 1)pal(i, j): if (i == j): return 1 # base case else if (X[i] == X[j]): if (i + 1 == j): return 2 # base case else: return 2 + pal(i + 1, j - 1) else: return max(pal(i, j - 1), pal(i + 1, j))C++ 구현#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;random&gt;#include &lt;string&gt;using namespace std;int longest_pal(string&amp; word, int i, int j) { if (i == j) return 1; if (word.at(i) == word.at(j)) { if (i + 1 == j) return 2; else return 2 + longest_pal(word, i + 1, j - 1); } else return max(longest_pal(word, i + 1, j), longest_pal(word, i, j - 1));}int longest_pal(string&amp; word, int i, int j, vector&lt;vector&lt;int&gt;&gt;&amp; memo) { /* * 컨닝페이퍼 작성 팁: 모든 반환값을 컨닝페이퍼에서 베껴서 내게 한다. * 채워지지 않은 컨닝페이퍼는 내기 전에 채워둔다. */ if (memo[i][j] != -1) return memo[i][j]; if (i == j) { memo[i][j] = 1; return memo[i][j]; } if (word.at(i) == word.at(j)) { if (i + 1 == j) { memo[i][j] = 2; return memo[i][j]; } else { if (memo[i + 1][j - 1] == -1) memo[i + 1][j - 1] = longest_pal(word, i + 1, j - 1, memo); memo[i][j] = 2 + memo[i + 1][j - 1]; return memo[i][j]; } } else { if (memo[i + 1][j] == -1) memo[i + 1][j] = longest_pal(word, i + 1, j, memo); if (memo[i][j - 1] == -1) memo[i][j - 1] = longest_pal(word, i, j - 1, memo); return max(memo[i + 1][j], memo[i][j - 1]); }}int main(){ clock_t clock_start; mt19937 gen(random_device{}()); // 난수 생성기 uniform_int_distribution&lt;int&gt; alphabet(int('a'), int('z')); // 알파벳 아스키코드 생성 uniform_int_distribution&lt;int&gt; word_len(15, 25); // 단어 길이 선택 string word = \"\"; // 단어 int idx = 0; // 팰린드롬 길이 vector&lt;vector&lt;int&gt;&gt; memo; vector&lt;string&gt; words; for (int i = 0; i &lt; 30; i++) { word.clear(); for (int i = 0; i &lt; word_len(gen); i++) word.push_back(alphabet(gen)); // 단어에 글자 붙이기 words.push_back(word); } clock_start = clock(); for (string&amp; wd : words) { memo.clear(); memo.resize(wd.length(), vector&lt;int&gt;(wd.length(), -1)); std::cout &lt;&lt; \"# \" &lt;&lt; ++idx &lt;&lt; \": \" &lt;&lt; longest_pal(wd, 0, wd.length() - 1) &lt;&lt; \", \" &lt;&lt; wd &lt;&lt; \"\\n\"; } std::cout &lt;&lt; \"\\nrecursion 실행 시간 : \" &lt;&lt; double(clock() - clock_start) &lt;&lt; \"ms\\n\\n\"; idx = 0; clock_start = clock(); for (string&amp; wd : words) { memo.clear(); memo.resize(wd.length(), vector&lt;int&gt;(wd.length(), -1)); std::cout &lt;&lt; \"# \" &lt;&lt; ++idx &lt;&lt; \": \" &lt;&lt; longest_pal(wd, 0, wd.length() - 1, memo) &lt;&lt; \", \" &lt;&lt; wd &lt;&lt; \"\\n\"; } std::cout &lt;&lt; \"\\nmemo 실행 시간 : \" &lt;&lt; double(clock() - clock_start) &lt;&lt; \"ms\\n\"; return 0;}시간복잡도 계산 T(n) = 2T(n - 1) = 2^n → exponential → use memo for O(n^2) 어디에 memo를 넣을지는 각자 알아서 생각해보기(기말고사에 나올지도?)GA 리뷰 + 공지 보고서 형식 자유, 분량만 지키면 된다. 그래도 글자 크기 1pt로 하면 안 된다. 선택한 알고리즘에 대해 왜 그것을 선택했는지, 하이퍼 파라미터를 바꿔봤을 때 어떻게 달라지는지 등 탐구 과정에 대한 내용이 더 많이 들어가길 바람. 하이퍼 파라미터 튜닝: grid search. 예를 들어 하이퍼 파라미터가 30개 있다면 30차원의 grid를 모두 채우면서 테스트를 하는 것. 현실적으로 너무 오래 걸리니까 요즘은 랜덤으로 준다. 매번 부여된 랜덤한 값에 대한 결과를 보고 좋은 방향으로 찾아가는 것. random search라고 한다.소프트웨어분석및설계 UP(unified process): 가장 많이 사용되는 객체 지향 개발 방법론, 반복적이고 점증적인 개발 Inception(개시) 대강의 비전과 요구사항, 비즈니스 케이스, 범위, 대략적 비용 추정에 대해 정의 기본적인 요구 사항 기술, 유스케이스 분석: 모든 유스케이스를 작성할 필요는 없음 기능 요구: 사용자가 사용할 수 있는 모든 기능 / 비기능 요구: 기능을 제외한 모든 것. non-functional req. 대표적으로 품질 요구를 의미함. 소프트웨어의 성능, 속도, 정확성, 보안 등. “How well” PoC: 개념 증명. 설계한 시스템/소프트웨어가 실제로 작동 가능한지 프로토타입을 만들어 확인함. iteration: 첫 번째 feature 단위 release에서 할 일 정함 Elaboration(정련) 정제된 비전, 핵심 아키텍쳐(구조) 정의. 대부분의 요구사항과 범위 식별, 보다 현실적인 추정. 높은 위험성 해결 기본적이고 핵심적인 시나리오 구성 도메인 모델, 설계 모델, SW 아키텍처 문서, 데이터 모델, 스토리보드, UI 프로토타입 등을 만듦 분석 단계에서는 UI에 대해 고려하지 않는다. ‘버튼’, ‘터치’ 등의 UI를 나타내는 표현은 설계 단계에서 나오는 것. 이외에도 데이터베이스, 제어 등의 개념이 개입할 때를 설계 단계라고 한다. Construction(구축) 반복적인 구현 및 배치 준비 사용 가능한 완제품을 만들어가는 단계 Transition(전이) 베타 테스트, 배치 사용자에게 배포 분석 절차 - GRAPPLE 요구사항 수집 전체 과정에서 가장 중요한 활동으로 구성됨 분석 수집한 요구 사항 세분화 설계 솔루션 고안에 관한 결정 수행: 객체 및 컴포넌트 다이어그램 개발, 배포 계획, 사용자 인터페이스 설계, 시험 설계, 문서화 시작 개발 코딩 시작 배포 백업 및 복구 준비, 하드웨어에 시스템 설치, 배포 활동 다이어그램: flow chart의 확장 버전. 알고리즘을 서술할 때에도 사용함. 다시 한번 과정 정리 비즈니스 업무 흐름 파악 도메인 분석: 인터뷰 분석(명/동사 분석), 일반화/그룹화 -&gt; 주요 클래스/관계 파악. 클래스 파악 팁: 무슨 책임이 있는지 생각해보기 클래스 간 연관에 이름 붙이기: 삼원 연관, 반사 연관(자기 자신과 연관), 집합/복합 연관 클래스 내용 채우기: 속성과 오퍼레이션 작성 유스케이스 작성 후 클래스 업데이트 사용자 인터페이스 설계 사용자 중에는 색약/색맹이 있을 수 있으니 색깔에 너무 많은 의미를 주지 말라 화면 좌측에 비중 있는 기능을 배치하고, 관련 있는 기능은 그룹화한다. 취소 기능을 제공하고, 가급적 취소 횟수를 제한하지 않는다. 어떤 기능을 실행하기 위한 동작은 한 가지 이상 제공한다. 오래 봐도 눈이 피곤하지 않게 색깔은 적당히 쓴다. 분석과 설계는 다르다 분석: 사용자 시각. needs -&gt; requirement. 설계: 개발자 시각. requirement -&gt; target lang, DB, UML. 품질, 성능, 사용성, 보안, 신뢰성, 유지보수성 등을 고려해야 함. 이 요소들은 아키텍처의 영향을 받고, 서로 trade-off 관계라 잘 고민해야 함. 시험 공지 서술형 주관식 중요한 컨셉, 간단한 분석 문제 90분 정도 팀 과제는 코딩보다 분석과 설계에 시간을 더 투자하고, 분석/설계의 내용이 코드에 잘 반영되도록 할 것. 코딩 과목이 아니니까. 소프트웨어디자인패턴 Chain of Responsibility 패턴 책임 떠넘기기 해결자(추상 클래스), 구체해결자, 요구자. 각 해결자는 자신의 다음 순서 해결자를 갖는다. 온라인 주문 시스템 예시: 인증된 사용자만 주문 가능하게 함, 관리자는 모든 권한 허용. 인증 과정은 차례대로 수행되어야 함. 중도 탈락 시 이후 과정 진행 불가. 인증의 각 과정을 독립된 핸들러로 구현, 각 핸들러를 체인으로 연결 문제가 발생하여 “누군가는 처리해야 하는” 상황 각 핸들러가 문제를 동시에 처리하는 게 아니기 때문에 처리할 수 있는 문제가 서로 겹치는 건 괜찮다. 처리가 될 때까지 다음 인증자(해결자)에게 떠넘기는 체인. 구매 인증 과정이라고 생각한다면 인증 실패 사유가 발견될 때까지 다음 인증자에게 넘기는 것. 특정 문제 케이스에 대해 문제 해결 과정 시퀀스 다이어그램 그리기 문제 있음. 각 클래스 별 해결 가능한 문제를 정해주고, 클래스마다 문제를 몇 개나 해결할 수 있는지 / 몇 개나 처리하지 못했는지 개수를 세는 문제 있음(뒤에 있는 해결자는 앞에서 해결한 문제는 제외하고 세어야 한다) + 마지막까지 남은 문제를 모두 해결할 수 있는 논리 구조 작성하기 문제 낼 수 있음. 해결할 수 있는 문제가 많을수록 내부에서 처리할 일도 많은 게 일반적이므로 보통은 복잡하고 할 수 있는 일이 많은 해결자가 뒤로 간다. 지금은 예시이므로 각 해결자가 알맹이 없이 껍데기만 있어서 역순이 더 효율적일 뿐이다. 각 해결자의 해결 시간을 계산할 때, 자기 자신의 해결 시간이 짧더라도 앞에 다른 해결자가 있다면 그 과정을 거쳐오는 시간까지 같이 포함해야 한다. -&gt; 보기엔 좋은데 효율성 계산이 참 까다로움. ‘문제’와 ‘해결자’가 느슨하게 연결되어 있기 때문에, ‘문제’는 처음 보이는 ‘해결자’에게 요구하고 기다리기만 하면 되기 때문에 누군가가 단독으로 문제와 매치되는 해결자를 판단할 필요가 없다. 문제와 매치되는 해결자를 판단하는 역할을 ‘문제’에게 맡기는 것은 부적절하다. 동적으로 문제 해결의 순서 변경 가능. 유연성은 높지만 처리 속도는 느리기 때문에 요구와 처리자의 관계가 고정적이고, 처리의 속도가 중요할 때는 이 패턴을 안 쓰는 게 나을 수 있다. -&gt; 순서를 잘못 구성하면 처리 속도가 대폭 느려질 수 있다는 단점이 기말 시험에 나올지도 동전 교환기 예시: 10원 구멍, 50원 구멍 등 동전 크기별 구멍이 (기기 내부에) 크기 순서대로 있기 때문에 100원 동전이 10원 구멍에 들어갈 수 없고, 50원 동전에 500원 구멍에 들어갈 일이 없다. 마지막까지 해결되지 않는 문제가 있을 수 있다. 이에 대해 마지막 해결자의 역할과 문제 처리가 중요하다. 기말고사 공지 15주차에 본다 자잘한 영단어는 시험으로 내지 않겠지만 패턴 이름 정도는 영어로 쓸 줄 알아야 한다 답안지가 궁금하면 메일로 문의 다음 주 현충일 휴강" }, { "title": "23년 1학기 12주 수업", "url": "/satinbower-legacy/posts/daily-230524/", "categories": "내가 해냄", "tags": "내가 해냄", "date": "2023-05-24 00:00:00 +0900", "snippet": "ToC 모빌리티서비스 알고리즘 처음 보는 문제 팀으로 해결하기 벨만포드 다이나믹 프로그래밍 knapsack 소프트웨어분석및설계 소프트웨어디자인패턴모빌리티서비스휴강, 자습 라즈베리파이 SD카드 구울 때 ssh 허용하게 설정하고 시작하기 nmap으로 라즈베리파이 ip 찾아서 연결하기 -&gt; ip 찾는 건 되는데 라즈베리파이가 와이파이를 스스로 못잡아서 다시 구워야 함알고리즘처음 보는 문제 팀으로 해결하기 각자 이해 서로 도와서 해결 완성본 비교 합본(제일 좋은) 최적화-&gt; 위 과정이 제대로 안 되었다면 혼자 하는 게 낫다.벨만포드generic 최단경로 초기화: 모든 정점에 대해 거리를 무한으로 설정 시작점은 0 더이상 할 수 없을 때까지 다음을 반복 일정 기준에 따라 간선 선택 Relax Relax:if (d[v] &gt; d[u] + w(u, v)) d[v] = d[u] + w(u, v) π[v] = u벨만포드 초기화 (정점 수 - 1)만큼 반복 모든 간선에 대해 Relax 모든 간선에 대해 if (d[v] &gt; d[u] + w(u, v)) 음수 사이클이 있음을 알림 * V는 정점, E는 간선다이나믹 프로그래밍과정 Define subprob: 부분 문제 정의 Guess: 부분 문제의 시간복잡도 추정 Ideate: 부분 문제 해결 시작 Rec + Memoi: 재귀가 필수는 아님 Solve Orig.Prob.: 원래 문제 해결knapsack문제: 제한된 weight 내에서 주어진 item을 선택해 cost 최대화문제 해결 과정 value for sufix i given knapsack size X 2 choices: 넣는다 / 하나 빼고 넣는다 DP[i, X] = max(DP[i+1, X], v_i + DP[i+1, X - S_i]) for i in n..0 AND X in 0..S -&gt; Θ(nS) DP[n, S]뭘 수업하는 건지 영 모르겠음소프트웨어분석및설계 컴포넌트 vs 라이브러리 컴포넌트는 실제 존재하는 실행 대상, 설계 단계에서 고려한다. 인터페이스+구현. 세부 구현을 숨기고 인터페이스에 의해 접근한다. 소스코드가 있으면 라이브러리 인터페이스 클래스: 속성은 갖지 않고 오퍼레이션만 갖는다. deployment diagram: 컴포넌트를 어디에 어떻게 배치할 것인지 나타내는 다이어그램 클라이언트 컴포넌트: 주로 클라이언트 컴퓨터에서 작동, GUI. 서버 컴포넌트: 서버 컴퓨터에서 작동, 비즈니스 로직 및 데이터 관리. 컨테이너: 서버 컴포넌트가 안에 포함되어 통신함 컴포넌트의 생성, 소멸, 생명주기 관리 클라이언트-컴포넌트 사이 메시지 패싱 관리 트랜잭션, 보안 등 기반 서비스 제공 EJB(Enterprise Java Beans): 계층적 컴포넌트 아키텍처에 사용. 서버, 컨테이너, 홈 인터페이스, 리모트 인터페이스, 빈 클래스로 구성소프트웨어디자인패턴 Decorator 패턴 간단한 이메일 알림 시스템을 만들고자 하는데, 알림을 보낼 앱이 많고 그 조합은 더 많다. 이들을 모두 자식 클래스로 생성하면 너무 많으니, 집합 관계를 이용해 하나의 wrapper가 여러 객체를 받아 합성된 행동을 하도록 하자. 중심이 되는 객체에, 장식과 같은 부가적인 기능을 하나씩 입혀서 좀 더 목적에 어울리는 객체를 만드는 패턴 컴포넌트(추상), 구체컴포넌트, 장식자(추상), 구체장식자. 구체컴포넌트와 장식자가 모두 컴포넌트를 상속 구현하고, 구체장식자는 장식자를 상속 구현한다. 장식자는 컴포넌트를 필드로 갖는다. 컴포넌트는 기능 구현 및 장식의 가장 기본 바탕. 구체컴포넌트는 장식 없이 구현된 기본 바탕. 장식자는 컴포넌트와 같은 인터페이스를 가지며 장식자인 동시에 장식의 대상이 될 수 있다. 구체장식자는 장식자를 구현한다. Composite 패턴과 같은 재귀 구조. 내용 변경 없이 기능 추가 가능, 단순한 장식의 조합으로 다양한 기능 구현 가능. java,io 패키지에 Decorator 패턴 사용됨. 자잘한 구체장식자를 모두 구현해야 하므로 작은 클래스가 많아질 수 있다. 도로 표시 방법 조합하기 예제 기본 기능: 도로를 선으로 표시 추가 기능: 내비게이션 SW에 따라 도로의 차선을 표시 " }, { "title": "23년 1학기 11주 수업", "url": "/satinbower-legacy/posts/daily-230511/", "categories": "내가 해냄", "tags": "내가 해냄", "date": "2023-05-11 00:00:00 +0900", "snippet": "ToC 모빌리티서비스 알고리즘 동적 프로그래밍 피보나치 수열 최단경로 소프트웨어분석및설계 소프트웨어디자인패턴모빌리티서비스터틀봇 실습 준비로 리눅스 세팅 및 ip 세팅.라즈베리파이 이미지 다운로드가 아주 오래걸리니 가이드를 미리 확인해보고 몰아서 다운받아놓은 후 진행할 것알고리즘동적 프로그래밍피보나치 수열재귀로 구현하는 피보나치 수열은 Θ(2^n/2)의 시간복잡도를 갖는다. 이는 한 번 계산했던 값을 매번 다시 계산하기 때문이므로 한 번 계산한 값을 따로 기억하게 하면 Θ(n)으로 줄일 수 있다.최단경로예를 들어 δ(s, v)는 s에서 v로 가는 최단경로라고 하자. 그리고 이 경로상에는 u, t 등의 정점이 포함된다. 그러므로 다음과 같이 식을 다시 쓸 수 있다. w(x1, x2)는 x1에서 x2로 연결된 단일 간선의 가중치를 나타낸다.δ(s, v) = δ(s, t) + w(t, v) = δ(s, u) + w(u, t) + w(t, v)위와 같은 식으로 모든 정점에서 다른 모든 정점까지의 최단경로를 알 수 있고, 이걸 기억해두면 된다. ?소프트웨어분석및설계 파생 클래스: 상속 관계에서 상속을 받은 하위 클래스를 말함. 부모-자식 중 자식 추상 클래스: 생성자가 없고 객체를 생성할 수 없음. 하위 클래스의 아웃라인, 템플릿.이진관계 예: 자신의 배우자를 p로 지정(setSpouse(*p)) p가 현 배우자가 아닌지 현 배우자가 없는지 p를 현 배우자로 지정 p의 배우자를 자신으로 지정 return 배우자가 있음 기존 배우자 데려옴 자신의 배우자 지움 기존 배우자의 배우자(자신) 지움 배우자를 p로 지정 만약 현 배우자(p)가 존재한다면 현 배우자의 배우자를 자신으로 지정 return 상태 다이어그램: 시스템의 변화를 모델링, 시간이 흐름에 따라 변화하는 객체의 값을 상태라 이름. 상태 다이어그램의 구현: enum으로 상태를 구분함. 상태 entry와 exit를 위한 helper 함수 추가, 이벤트 핸들러 추가. Helper 함수: onEntry() 함수는 특정 상태에 진입했을 때 객체가 수행할 액션의 순서를 정의함. 상태 entry와 exit 관련 함수, helper는 시스템 본인에 의해 수행되므로 protected로 정의된다. 이벤트: 사용자 또는 외부 엔티티에 의해 발생하므로 public 함수로 정의됨 이벤트 핸들러: 발생한 이벤트와 현재 상태에 맞게 올바른 상태 전이를 발생시킴. 중첩 상태는 시험 범위에서 제외 컴포넌트 다이어그램 Color Slide Bar 예제: 슬라이더 * 3, 패널 * 4, 라벨 * 3, 리스너 * 1로 구성된 컬러피커. 물리적인 실제 대상을 상정하고 구조를 만들기 때문에 설계 단계에서 하는 일이다. 반복을 통한 정제 전화기 다이얼 예제 눈으로 보이는 버튼을 누른다고 그 정보가 바로 스크린으로 가는 것이 아니다. 겉보기엔 그렇게 되는 것 같지만 논리적으로는 다이얼러를 거쳐서 전달된다. 물리 ≠ 논리 다이얼러가 중간에 끼어서 클래스 간의 소통을 관리하면 사용자가 어떤 버튼을 누르는지도 구분해서 전달하기 좋다. 처음부터 모든 것을 만들지 말고 핵심부터 하나씩 추가하라. 소프트웨어디자인패턴 Flyweight 패턴 고유 객체와 공유 객체, 생산자. 많은 메모리를 요구하지만 공통적으로 사용되는 데이터를 공유 객체가 갖고, 생산자가 고유 객체와 공유 객체를 이용하여 하나의 완성된 오브젝트를 생산. 다른 것보다 훨씬 많은 메모리를 요구하지만, 많은 객체가 공유하는 데이터로 인해 메모리 사용량 증가 문제를 해결 -&gt; 공유 데이터를 하나의 공유 객체로 이동하여 필요할 때마다 가져와서 씀. 참고: 인기도가 낮고 자주 쓰이지 않는다. 정말정말 이게 없으면 안 될 정도가 되어야 사용하는 패턴 RAM 사용을 줄이는 것이 목적. 인스턴스를 공유해서 불필요핸 new를 사용하지 않게 함 텍스트 에디터 예제 각 문자의 폰트, 사이즈, 색상 등을 공유 데이터로 사용. 주의: 공유 데이터를 변경하면 해당 데이터를 공유한 모든 곳에 영향을 주기 때문에 꼭 공유해야만 하는 것이 무엇인지 잘 정하는 게 중요함. 시퀀스 다이어그램 그릴 때 주의: 비슷한 작업을 여러 번 할 때, 각각의 작업에 대해 모두 그리기. 하나만 그리고 까먹으면 안 된다. intrinsic(본질적인): 상태에 의존하지 않고, 공유되어야 하는 정보 + extrinsic(부대적인): 상태에 따라 바뀌고 공유할 수 없는 정보 공유 객체로 관리되고 있는 인스턴스는 가비지 콜렉션이 안 된다 -&gt; 메모리가 부족해졌을 때 멋대로 사라질 일이 없다. 메모리 이외의 리소스 개선 시간: new를 적게 사용하므로 프로그램의 속도 높일 수 있음. Command 패턴 객체의 행위를 클래스로 만들어 캡슐화. 객체 간의 의존성을 제거하고 시스템에 확장성과 유연성 부여. 관심사 분리의 원칙 기반 프로그래밍 버튼 클래스 예제 OK, 취소, 수락, 프린트 등 다양한 버튼을 만들어야 한다. 이들을 모두 버튼 클래스의 자식으로 만들면 부모 클래스의 의존성이 증가하고, 여러 위치에서 호출되는 일부 작업이 존재할 수 있고, 중복된 코드가 사용됨. 레스토랑 주문 예시: 손님은 밥이 맛있기만 하면 되지 요리를 어떻게 하는지는 관심 없다. 주문을 주방에 전달하고 그에 상응하는 동작을 응답받는 것이 이 패턴의 예시에 해당함. mp3 플레이어 예제: 버튼 하나로 많은 작업을 처리해야 한다. 요소가 추가될 때마다 의존도가 높아져 구현이 번거롭기 때문에 수행해야 하는 행위를 캡슐화한다. 버튼에 각 커맨드를 setter로 지정하고, 버튼을 누르면 지정된 커맨드가 실행된다. 각 행위에 대해 클래스가 만들어져야 버튼에 지정할 수 있다. mp3 플레이어 예제의 UML을 그리는 게 과제다. 기말고사에서 물어볼 것이기 때문이다. 비슷하지만 한 번도 본 적이 없는 코드를 줄 테니 그것을 보고 관계를 파악하여 그리면 된다. 말만 하면 연습 안 할 것 같아서 과제로 낸다. 커맨드, 구체커맨드, 인보커, 리시버. 커맨드는 구현되어야 할 인터페이스, 구체커맨드는 실제 커맨드, 인보커는 기능을 요청하는 호출자(버튼), 리시버는 요청받은 동작을 수행하는 실행자(mp3 플레이어). 시퀀스 다이어그램은 호출 스택을 따라 그리면 된다. invoker와 리시버, 커맨드가 따로 캡슐화되어서 결합도가 낮아진다는 장점이 있지만 커맨드의 개수만큼 클래스를 만들어야 하는 단점이 있다. 되돌릴 수 있는 작업을 구현하려고 할 때 사용하지만, 기록을 따로 구현해야 하고, 앱의 상태가 비공개라면 상태를 저장하는 게 쉽지 않고, 백업이 메모리를 잡아먹을 수 있다. " }, { "title": "23년 1학기 10주 수업", "url": "/satinbower-legacy/posts/daily-230504/", "categories": "내가 해냄", "tags": "내가 해냄", "date": "2023-05-04 00:00:00 +0900", "snippet": "ToC 모빌리티서비스 알고리즘 소프트웨어분석및설계 소프트웨어디자인패턴모빌리티서비스 9주에 했던 내용 다시 실행 실습 예고: 가상 머신을 하나 더 만들거나, 아예 리눅스 PC를 새로 장만하면 좋다. 피자 먹었음. 맛있었음.알고리즘 유전 알고리즘 복습 랜덤한 해를 생성하고(P_0) 각 해의 cost 계산 랜덤한 두 부모를 선택 후 교배(원하는 방식대로 섞기) 낮은 확률로 돌연변이 발생(랜덤하게 뭔가 바뀜) 생성된 자식은 전체 유전자 풀에서 안 좋은 해를 대체함 위의 과정을 반복 특정한 조건 하에 반복을 중단하고 가장 좋은 해를 반환함 유전 알고리즘 세부 구현의 다양한 변형 부모 선택 알고리즘: 룰렛 휠, 토너먼트, 사회복지(전체에서 특별히 cost가 높은 유전자의 cost 보정해주기) 교배 방식(일관된 규칙이 있기만 하면 됨): 일정한 모양/비율로 분할, 각 자리마다 랜덤한 확률로 부모 중 하나 선택, 랜덤한 확률로 부모 복제, (2차원 이상)해를 잘라서 이어붙임, 1% - 0.01% 확률로 돌연변이 발생(확률 고정, 감소 방식), 얌체 교배, 양봉 세대 교체 방식: steady-state(매번 대체), generational(세대별 대체), Preselection(부모 대체), Crowding(유사값 대체), Eliticism(엘리트주의, 특별히 cost가 낮은 해가 대체되지 않게 보호), 재산비례(cost가 낮을수록 자식을 많이 만듦), Island Method(Parallel, 콜럼버스 방식, 대륙을 나누어 각자 수렴진화 후 대륙 간 교배), 천적관계(두 그룹이 서로를 공격하며 진화) 구현 시 예상되는 어려움초기에는 해가 성립하거나 성립하지 않는 특정 조건(예: 1이 무조건 6개 이상, F 다음에는 A가 오면 안 됨)을 고려하여 부모를 생성하기 때문에, 초기 전체 풀은 ‘해로 사용 가능함(feasible)’이 보장된다. 하지만 교배 방식에 따라 자식은 해의 조건을 충족하지 않을 수 있다. 고로 자식을 생성할 때 자식해를 적절하게 수정할 필요가 있을 수 있다. 활용 사례 다항식 최적화 다항식의 계수 벡터를 유전 알고리즘의 해로 간주하고, 정해진 변수 값에 따라 그에 맞는 답을 만들어낼 수 있는 최적의 계수 조합을 찾음. 신경망 가중치 최적화 초기 가중치 셋을 구할 때 유전 알고리즘을 사용한 후 오차 역전파를 수행하면 더 빠르다고 한다. 엘리베이터 스케줄링 차량 라우팅: 타다, 우버 등의 카 헤일링/쉐어링 서비스에서 요청이 있는 고객에게 효율적으로 차량 배치하기 단백질 3차원 구조 VLSI 회로 배치 Vector quantization 죄수 딜레마 소프트웨어분석및설계 시퀀스 다이어그램 복습, 진도 나감 시나리오 중 객체 생성, 삭제 시퀀스 다이어그램에 프레임 씌우기: 참조, 대안(if-else), 동시 진행 표기 가능 통신 다이어그램: 수업 내용 기억 안 남 객체지향 선언과 구현 분리: 컴파일러는 선언부와 구현부가 따로 있으면 따로 컴파일한다. 일반적으로 권장됨. java: java는 C++에 대한 반항으로 태어난 언어이다. C/C++은 포인터 사용으로 인한 오류가 너무 많았고, 보안에 취약했다. 대신 속도는 압도적으로 빠르다. C++과 java의 차이 위주로 확인 언어에 따라 다르지만 java는 다중상속이 불가하고 C++은 가능하다. (약한) 집합 연관: 자바는 포인터가 없어서 그대로 쓸 수는 없음. C++은 포인터를 사용하기 때문에 상위 객체가 삭제되어도 하위 객체가 남는다. 복합 연관의 표현: 맨 앞에 언더바가 붙는 이름은 private이니 건드리지 말라는 암묵적 표시 이진 연관: 양방향 연관. 관계가 끊어지거나 변경될 때 양쪽 객체 모두가 업데이트되어야 함. 소프트웨어디자인패턴 State 패턴 유한 상태 머신 패턴. 각 상태는 서로 다른 클래스로 표현된다. 객체의 모든 가능한 상태에 대한 클래스를 만들고 각 상태별 작업을 위임하여 처리함 구체상황과 상태, 구체상태. 구체상황은 현재의 상태를 나타내는 구체상태를 하나 갖고 있으며, 자체적으로 행동하지 않고 해당 구체상태 클래스에 위임한다. 겉보기에 모든 동작을 구체상황 클래스가 수행하는 것처럼 보이지만 내부적으로는 각 구체상태 클래스가 수행하고 있고, main 입장에서는 현재 상태를 알 수 없다. 개개의 구체적인 상태를 각각 클래스로 나누어서 표현함으로써 문제를 분할, 상태의 종류가 많을수록 유용하다. 상태에 따라 행동이 달라지는 처리 새로운 상태를 추가하는 것은 간단하나, 상태의 수가 적거나 머신이 거의 변경되지 않을 때 이 패턴을 사용하는 것은 추천되지 않는다. 시퀀스 다이어그램 팁: 보낸 메시지가 돌아올 때 그 전후상황을 알아야 한다면 라이프라인이 연결되어 있어야 하고, 그럴 필요가 없다면 라이프라인 잘라도 됨. 케이크 잘 그리기. " }, { "title": "23년 1학기 9주 수업", "url": "/satinbower-legacy/posts/daily-230503/", "categories": "내가 해냄", "tags": "내가 해냄", "date": "2023-05-03 00:00:00 +0900", "snippet": "ToC 모빌리티서비스 알고리즘 소프트웨어분석및설계 졸업생 깜짝 특강 시퀀스 다이어그램 소프트웨어디자인패턴모빌리티서비스 C++ ROS 프로그래밍 기초: 패키지 생성, 빌드, 첫 빌드 후 환경설정, 실행 토픽, 서비스, 액션 인터페이스: 인터페이스 패키지 만들고 기본 파일 생성 후 빌드. 오류 해결 실패 시 깃허브 소스 다운받아 실행하기. C++ ROS 2 패키지 설계: 소스 코드 다운로드 및 빌드. 토픽 서브스크라이버/서비스 서버/액션 서버 실행, 토픽 퍼블리셔, 서비스 클라이언트, 액션 클라이언트 실행. 팁: 강의와 똑같이 복붙해도 안되면 직접 쓰기(유니코드 문제)알고리즘유전 알고리즘: 어떤 문제에 대해 랜덤한 답안들을 생성하고 2개씩 골라 섞어서 더 나은 답안 찾아가기.유전 알고리즘은 해의 경우의 수가 너무 많아 일일이 찾거나 확정적인 알고리즘을 사용할 수 없는 문제에 사용할 수 있다. 기계학습과 비슷하게 문제 영역에서 최적해를 찾아가는 과정이다. 문제 영역에는 여러 가지 지역 최적해가 존재할 수 있는데, 목표는 전역 최적해를 찾는 것이지만 한 번 지역 최적해를 향해 가기 시작하면 그 흐름에서 빠져나오기 어렵다. 그러므로 ‘진화’를 이용하여 지역 최적해를 빠져나와 다른 더 좋은 해를 찾아간다.유전 알고리즘에서 랜덤이 적용되는 부분은 다음과 같다. 초기 답안 풀 생성: 로또 찍는 것처럼 아무 답안이나 원하는 개수만큼 생성한다. 001100010110 등과 같이 유전자스럽게 표현한다. 교배할 부모 선택: 자연선택의 원리를 적용하되, 안 좋은 답안도 선택될 확률이 남아있게 한다. 교배: 두 부모의 답안을 섞는 방식은 알고리즘 작성자 마음대로 한다. 굳이 랜덤하게 섞지 않아도 된다. 일정하기만 하면 된다. 돌연변이: 낮은 확률로 교배가 완료된 자식이 돌연변이를 일으킨다. 한 세대의 교배 수: 교배를 통해 생성된 자식이 기존의 세대를 대체하는 방식과 관련이 있으며, 작성자 마음대로 쓴다.생물학의 개념을 빌려왔기 때문에 용어도 생물학의 용어를 그대로 따서 쓴다. chromosome: 문제 영역에 대한 답안. 각각의 부모, 자식을 나타냄 gene: 답안의 각 자리(글자) schema: 유전자에서 보이는 특정 gene의 패턴. 대체로 좋은 결과를 보였던 일정한 패턴을 말한다. 꼭 연속하여 위치할 필요는 없다.소프트웨어분석및설계졸업생 깜짝 특강 ‘개발’의 분야는 아주 다양하고, 한 사람이 모든 일을 혼자서 다 할 수 없으니 직무 선택이 첫 번째다. 혼자서 모든 일을 할 수 있다고 해도 회사에서는 올라운더 잡캐보다 특정 클래스 특화 캐릭터를 선호한다. 직무 선택에는 본인의 성향이 중요하다. 토이 프로젝트 등에서 맡았던 역할 중 특히 좋았던 역할을 생각해보면 도움이 된다. 뭐가 됐든 일단 부딪히고 깨져보는 건 도움이 된다. 각종 회사별 기술블로그 추천: 어떤 회사가 무엇을 사용해 뭘 하는지 보고 배워라. techblogposts.com 나는 플라네타리움에 관심이 있음. 트위터에서 오픈소스 프로젝트 기여할 사람 찾는다고 하는 거 본 적 있음. 학부 공부 이외에도(혹은 졸업 후에도) 필요에 따라 추가 교육 준비: 국비 지원 과정, 온라인 강의(유/무료), 부트캠프(boottent) 등 단순 실력 향상 목적 학원 X, 협업 경험 목적 O: 학원의 광고 멘트는 보통 상술이다. 기본기, 자격증은 학원에 안 가도 충분히 가능(방향성 잡기는 어려울 수 있음), 포폴 목적/취업 연계 등 목적은 괜찮. 자격증: 회사 바이 회사지만 취업에 큰 영향을 주지는 않음. 일부 보수적인 분야에서는 자격증을 중시할 수 있으나 기본적으로 프로젝트 경험의 질과 양을 우선함. 포폴 정리: 지금까지 했던 일(학과, 알바, 동아리 등) 모두 정리, 필요한 기술 스택과 연계해 어필할 강점 파악. 평소 정리가 중요하다. 코딩 테스트 준비: 미리 하는 게 좋을 것이다. 핵심 자료구조, 알고리즘 공부하고 편한 언어 사용. 파이썬, 자바 추천. 기술 면접 준비: 서류 전형 준비할 때 같이 준비. 본인이 사용한 기술을 선택한 이유. IT 관련 기초 지식 중시하는 회사 많다. 비전공자가 이해할 만큼 쉽게 잘 설명하는 것도 가산점 요소. 모의 면접 추천. 인성 면접: 결과가 노력에 비례하지 않을 수 있다는 점에서 기술 면접보다 어려울 수 있음. 회사와 분위기가 맞는 사람인지 보기 때문. 정답이 없고 순위를 매기지 않는 전형이기 때문에 떨어진다고 상처받지 말고 서로 인연이 아니었다 생각하길. 기술 면접과 연계되는 내용은 트렌드에 따라 다르기 때문에 알아서 자료 참고. 유튜브 ‘면접왕 이형’ 추천, 잡플래닛 면접 후기, 취준생 커뮤니티 참고 가능. 각종 취준 경험과 기록은 모두 정리해서 모아두기: 면접 질의응답 자료와 코딩테스트 문제들 입사 이후: 취업해도 공부는 안 끝난다(!) 4년간의 배움, 6개월만에 바닥난다. 학부에서 꼭 머리에 안 들어오는 과목은 취업하면 그렇게 그렇게 필요해진다. 혼자 울면서 공부하면 힘들고 어차피 공부는 모두가 다 해야 하니까 팀원이든 동기든 같이 공부할 사람을 찾고 붙잡고 공부해라. 서로 공부할 분야가 다르다면 인증 모임이라도 만들어라. 같은 분야 공부가 가장 좋지만 IT는 결국 하나의 흐름으로 모이기 때문에 분야가 달라도 같이 공부하는 게 훨씬 좋다. 뭘 공부하면 좋은지 추천: roadmap.sh 프론트엔드: 자바스크립트, HTML, CSS, 리액트 게임(클라이언트): 유니티+C#(캐주얼), 언리얼+C++(MMORPG) 백엔드: DB 필수(MySQL, PostgreSQL(여기까지 관계형DB), NoSQL(비관계형 DB, 대용량 처리에 적합), 몽고 등등 다양하니 찾아보라) 게임: C#, C++ non-게임: 자바, 스프링(스프링부트) 안드로이드: 자바, 코틀린 알고리즘: 파이썬 추천. 실무에서 시간복잡도를 고려할 줄 아는 것이 중요함(문제를 풀라고 직접 시키지 않지만 서비스의 질과 연관됨) 한 번 취직 후 타 직무로 이직하기 쉽지 않다는 점 고려 필요 직무와 분야에 따라 수학, 알고리즘 등 별도 역량 필요: 요즘 유니티 엔진 등 엔진이 잘 되어 있어서 직접 깊게 공부하는 건 필요에 따라 다르고 필수는 아님(연구직을 하겠다면 필요할 수는 있음) 야근 비게임: 사람이 자산이기 때문에 길게 일할 수 있게 잘 보살펴 준다. 물론 야근 있을 수 있음. 급하거나 큰 일이 생기면 야근을 몰아서 하게 될 수도 있는데 그럴 때는 야근 수당 또는 보상 휴가라는 게 있다. 재택 근무, 유연 근무 등 다양한 방안이 있음. 게임: 야근 꽤 있을 수 있음. 타이핑 치다가 제대로 못들었음 연구와 개발의 차이: 개발은 끊임없이 개발하고 테스트하고 확인하는 과정이 쉴새없이 몰려옴. 사용자의 반응을 볼 수 있다. 연구는 개발처럼 몸이 바쁘진 않은데 머리를 열심히 써야 함. 눈에 보이지 않는 성과를 내야 함. 일과 생활의 분리: 공부 등등도 중요하지만 지속 가능한 게 중요하니 일과 삶은 분리해야 한다. 조금이라도 일과 관계 없는 시간을 마련해야 할 것(삶의 동기부여). 욕심내지 않으면 공부할 시간도 있다. 조금씩 꾸준해도 발전은 있다. 포폴용 프로젝트의 깊이: 학생에게 현직자 수준 기대하지 않음. 혼자 할 수 있는 일을 5명이 나눠서 했다 X, 5명분의 일을 5명이 했다 O. 프로젝트 마감 후에 발견한 개선점은 메모해두고 면접에서 활용 가능. 본인이 하고 싶은 프로젝트를 하는 게 좋다. 현직자만큼의 깊은 수준을 바라지 않는다. 컴공 전공 후 “개발자” 이외 직무: QA, 인증/보안, 데이터 분석, 기획, 은행(디지털 전환) 등 구글링으로 진행한 프로젝트의 ‘깊이’(코드와 로직 복붙): 완전 복붙은 좀 아니고, 약간 변형해서 활용 가능하면 됨. 같은 역할을 하는 코드라도 다양한 상황에 따른 적절한 선택 능력이 있으면 됨.시퀀스 다이어그램 시스템의 동적인 측면을 모델링, 다수의 객체를 대상으로 하며 하나의 다이어그램에 여러 개의 시나리오가 표현될 수 있다. 동기 메시지와 비동기 메시지를 구분한다(응답도 구분한다). 정적 모델(클래스 다이어그램)은 처음부터 완성될 수 없다. 동적 모델과 서로를 보완하며 완성한다. 만약 동적 모델이 타당하다면 정적 모델은 동적 모델에 표현된 오퍼레이션만 가져야 한다. 시퀀스 다이어그램에 표시된 화살표에 병기된 오퍼레이션은 화살표의 목적지가 갖는 것이다. 액터가 시스템의 실행 종료 후 결과에 관여하는 것은 오퍼레이션으로 취급하지 않고, 다이어그램에 표기하지 않는다. 여러 개의 시나리오가 함께 표현된 시퀀스 다이어그램을 보고 포함된 시나리오를 분리해서 해석할 줄 알아야 하며, 여러 개의 시나리오를 하나의 다이어그램으로 나타낼 줄 알아야 한다.소프트웨어디자인패턴 Mediator중재자 패턴 객체 간의 의존 관계가 복잡한 상황의 컨트롤타워. 다수의 컴포넌트가 직접 통신하면 디버깅이 어려워지고 프로그램이 복잡해지기 때문에 통신을 총괄하는 중재자를 만듦. 컴포넌트 간의 직접 통신을 금하고 중재자를 통해서만 통신하게 함. 단일 중재자 객체 내부의 다양한 객체 간의 복잡한 관계망을 캡슐화. 단일 중재자가 모든 통신을 중재하기 때문에 그에 대한 로직을 전부 혼자 가진다(특정 어플리케이션에 맞추어 만들어짐). 그렇기 때문에 다른 어플리케이션에 재사용하기는 어렵다. 소통이 필요한 컴포넌트와 중재자, 구체컴포넌트와 구체중재자. 컴포넌트는 중재자를 갖고, 구체중재자가 구체컴포넌트를 모두 갖는다. 구체컴포넌트는 각자 중재자를 갖는다. 구체컴포넌트의 모든 통신은 구체중재자에게 전달되고, 중재자가 대신 통신한다. 시퀀스 다이어그램 시험에 낸다 일반적으로 로직을 분산시키는 것을 지향하는 객체지향의 개념과 달리 한 곳에 집중하는 패턴. GUI 어플리케이션에서 효과적이다. Observer구독알림 패턴(Publish-Subscribe 패턴) 어떤 사건이 발생하면 바로 알고 싶은데, 매순간 확인하기는 비효율적이니 사건의 주체가 사건 발생 시에 구독자에게 알림 전송. 구독 알림 패턴: 구독/구독 취소 기능 특정 사건에 대해 알림을 받고 싶은 고객과 모든 사건에 대해 알림을 보내고 싶은 쇼핑몰의 이해관계 충돌 문제 해결 관찰대상과 관찰자, 구체관찰대상과 구체관찰자. 관찰대상은 쇼핑몰, 관찰자는 고객에 비유. 관찰자가 보기보다 수동적임. 이름은 관찰이지만 직접 관찰하지 않고 상태를 통지받는다. Model/View/Controller(MVC)에 잘 사용됨 " }, { "title": "[알고리즘] 다익스트라", "url": "/satinbower-legacy/posts/it-algorithm-dijkstra/", "categories": "IT, Algorithm", "tags": "지식, IT, 알고리즘, 다익스트라", "date": "2023-04-09 00:00:00 +0900", "snippet": "Table of Contents 할 일 문제 풀이 양방향 다익스트라 양방향 다익스트라 개선할 일 Read chapters 7.1 – 7.7. (X) Solve the exercise problem 14 of the chapter 7. Show that the time complexity for the number of assignments of records for the Mergesort algorithm (Algorithms 2.2 and 2.4) is approximated by T (n) = 2n lg n. Refer to graph examples 1 and 2 on pages 21-22 of the class material titled ‘Class material 06.pdf’. Given the graph, perform a Bi-Directional Search. The source vertex is ‘s’, and the target vertex is ‘D’. Draw the graphs for each step of your procedure. Can you improve this Bi-Directional Search algorithm? Describe the procedure.note. The third problem in the class material has been updated as described above. 7.1장~7.7장을 읽습니다. (X) 7장의 연습 문제 14를 풀어봅니다. 병합 정렬 알고리즘(알고리즘 2.2와 2.4)의 레코드 할당 횟수에 대한 시간 복잡도는 T(n) = 2n lg n으로 근사화됨을 나타냅니다. ‘Class material 06.pdf’의 21~22페이지에 있는 그래프 예제 1과 2를 참고합니다. 그래프가 주어지면 양방향 검색을 수행합니다. 시작점은 ‘s’이고, 도착점은 ‘D’입니다. 절차의 각 단계에 대한 그래프를 그립니다. 이 양방향 검색 알고리즘을 개선할 수 있습니까? 절차를 설명하세요.참고. 수업 자료의 세 번째 문제는 위에서 설명한 대로 업데이트되었습니다.문제 풀이문제: 병합 정렬 알고리즘(알고리즘 2.2와 2.4)의 레코드 할당 횟수에 대한 시간 복잡도는 T(n) = 2n lg n으로 근사화됨을 나타냅니다.문제 이해: 병합 정렬 수행 중 대입 연산 횟수가 2n log n으로 근사함을 증명해라. 편의상 n은 2의 거듭제곱으로 가정하겠다.문제에서 말하는 병합 정렬 알고리즘은 두 가지이다. 하나는 배열을 반으로 나누어 다른 배열에 복사한 후 정렬하는 것이고, 다른 하나는 배열을 분할하는 과정을 배열의 인덱스를 이용해 복사하지 않고 진행하지만 병합을 할 때 새로운 배열에 저장한 후 정렬 결과를 원본에 붙여넣는 방식이다. 배열을 복사하는 순서가 다를 뿐, 원본을 복사해 넣을 새 배열이 필요하다는 점은 같다.교수님이 시간복잡도 계산은 약간의 직관이 필요하다고 하셨으니 내가 한번 직관적으로 계산해 보겠다.병합 정렬 알고리즘의 시간복잡도는 O(n log n)으로 알려져 있다. 이 시간복잡도는 (1) 계수가 생략되어 있고, (2) 분할/비교 등 알고리즘의 주요 연산에 대한 시간복잡도이다. 물론 연산에는 대입도 포함되어 있을 것이지만, 그것은 분할과 비교의 결과로써 수행되는 것이므로 전체 시간 복잡도를 바꿀 만큼 영향을 주기는 힘들다고 본다.여기서 내가 생각해보는 것은 알고리즘이 수행되는 동안 비교 연산이 이루어지는 횟수이다. 분할은 그렇다 치고, 대입 연산은 비교 연산의 결과로 정렬이 이루어진 부분 배열에 대해 이루어지는 것이니(분할할 때부터 새 배열에 대입하는 알고리즘은 지금의 논리에서 순서만 바꾼 것이라고 가정한다.) 비교 연산과 대입 연산의 수행 횟수에는 서로 비례할 것이다.그렇다면 병합 정렬 알고리즘에서 비교 연산은 얼마나 수행될까? 배열 분할을 모두 한 후의 시점부터 비교 연산을 시작하니 그것부터 따져보자. 부분 배열 크기 부분 배열 수 배열간 비교 횟수 총 대입 수 1 n 1 2 * n/2 2 n/2 3 4 * n/4 4 n/4 7 8 * n/8 2^k n/2^k 2^k * 2 - 1 2^k * 2 * n/2^(k+1) 배열을 비교한 후 병합할 때 대입 횟수는 배열의 크기와 같다. 그리고 병합의 횟수는 배열을 분할한 수와 같다. 배열을 분할한 수는 log n이고, 비교 후 대입 수는 n이므로 총 비교 후 대입 수는 n log n이다. 또한 이는 배열을 분할하여 빈 배열에 대입할 때에도 똑같다. 그러므로 총 대입 연산 횟수는 2n log n이다.양방향 다익스트라문제: ‘Class material 06.pdf’의 21~22페이지에 있는 그래프 예제 1과 2를 참고합니다. 그래프가 주어지면 양방향 검색을 수행합니다. 시작점은 ‘s’이고, 도착점은 ‘D’입니다. 절차의 각 단계에 대한 그래프를 그립니다.문제 이해: 강의자료의 지정된 페이지에는 D라는 레이블을 갖는 정점이 없다. (문제 좀 제대로 내달라고요) 대신 t가 도착점이라고 간주하고 두 그래프에 대해 양방향 다익스트라를 해보겠다.양방향 다익스트라는 출발점과 도착점에서 동시에 출발하여 서로의 경로가 만났을 때 탐색을 종료하는 알고리즘이다. 길을 둘이서 같이 찾으니 혼자서 찾는 것보다 훨씬 빠르다고 한다.사람이 이 문제를 풀기 위해서는 헷갈리지 않게 도착점에서 출발하는 그래프를 따로 그릴 필요가 있을 것 같아서 그래프를 2개 준비했다. 하나는 문제에서 준 그래프이고, 하나는 모든 간선의 방향을 뒤집은 반전 그래프이다. 가중치 중에 4 / 5라고 쓰인 것은 문제 그래프가 두 종류 있기 때문이다. 한 그래프는 w를 거치는 모든 간선의 가중치가 4이고, 다른 그래프는 5이다. [이미지 1] 다익스트라 문제 그래프 [이미지 2] 다익스트라 문제 그래프 반전 먼저 w 근처 간선의 가중치가 4인 그래프부터 양방향 다익스트라를 해보겠다. 다익스트라가 양방향으로 진행되는 것을 나타내기 위해 두 다익스트라의 결과를 /로 구분한다. S s u u’ w t {s} / {t} 0 / ∞ 3 / ∞ ∞ / 3 4 / 4 ∞ / 0 {s, u} / {t, u’} 0 / ∞ 3 / 6 6 / 3 4 / 4 ∞ / 0 {s, u, u’} / {t, u’, u} 0 / 9 3 / 6 6 / 3 4 / 4 9 / 0 {s, u, u’, w} / {t, u’, u, w} 0 / 8 3 / 6 6 / 3 4 / 4 8 / 0 {s, u, u’, w, t} / {t, u’, u, w, s} 0 / 8 3 / 6 6 / 3 4 / 4 8 / 0 다익스트라의 결과로 찾은 경로는 s &gt; w &gt; t이며, s에서 출발한 다익스트라와 t에서 출발한 다익스트라가 완전히 교차했을 때 완성되었다. s와 t가 처음 만난 시점인 u 또는 u'을 방문했을 때에는 경로는 만들어졌지만 최단 경로가 아닌 상태였다.하고 싶은 말을 정리하자면, 양방향 다익스트라는 출발점과 도착점 둘이서 길을 찾는다는 장점이 있지만 두 탐색자가 완전히 교차해야만 최단경로를 확실히 알 수 있다는 것이다.w 근처 간선의 가중치가 5인 그래프로 양방향 다익스트라를 하면 다음과 같다. S s u u’ w t {s} / {t} 0 / ∞ 3 / ∞ ∞ / 3 5 / 5 ∞ / 0 {s, u} / {t, u’} 0 / ∞ 3 / 6 6 / 3 5 / 5 ∞ / 0 {s, u, u’} / {t, u’, u} 0 / 9 3 / 6 6 / 3 5 / 5 9 / 0 {s, u, u’, w} / {t, u’, u, w} 0 / 9 3 / 6 6 / 3 5 / 5 9 / 0 {s, u, u’, w, t} / {t, u’, u, w, s} 0 / 9 3 / 6 6 / 3 5 / 5 9 / 0 이번에는 s와 t가 u와 u'을 방문했을 때 최단 경로가 완성되었다. 좋긴 한데, 위와 같은 반례가 있으니 교차할 때까지 탐색하는 게 맞다.양방향 다익스트라 개선문제: 이 양방향 검색 알고리즘을 개선할 수 있습니까? 절차를 설명하세요.개선이라는 말은 현재의 양방향 다익스트라에 어딘가 비효율적인 부분이 있다는 뜻이다. 어디가 비효율적일까? 내가 보기엔 두 탐색자가 완전히 교차할 때까지 탐색을 진행해야만 하는 부분일 것 같다. 두 탐색자가 교차하지 않아도 최단경로를 찾을 방법이 있을까?얄팍한 생각이지만 두 탐색자가 서로의 방문 기록을 공유해서, 이미 지나온 길은 가지 않게 하는 건 어떨까? 앞선 문제에서도 항상 가장 가까운 점으로 간다는 다익스트라의 특성 때문에 두 탐색자가 서로의 정점까지 방문한 후에, 다른 정점에 방문해서까지 최단경로를 찾을 수 있었다.위의 문제로 예를 들자면, s와 t가 서로의 교차를 위해 각각 u'과 u를 방문해야 하긴 하지만 출발점과 도착점인 s와 t를 다시 방문할 필요는 없다. 그러니 각 탐색자에게 플래그를 주어서 한 번 방문 정점이 겹치면 플래그를 올리고, 플래그가 올라간 상태로 중복된 정점을 또 방문하려고 하면 유턴하게 만드는 거다. 두 탐색자의 경로를 합쳐야 하니까 방문 정점이 아예 안 겹칠 수는 없고, 한 번만 겹치게 하자는 말이다. 일단은 이 정도 생각이다." }, { "title": "[알고리즘] 해시와 정렬", "url": "/satinbower-legacy/posts/it-hash-and-sort/", "categories": "IT, Algorithm", "tags": "지식, IT, 알고리즘, 선택 문제", "date": "2023-04-02 00:00:00 +0900", "snippet": "Table of Contents 할 일 선형 중앙값 찾기 덤 - pivot 잘 고르기 해싱할 때 0을 곱하면 안 되는 이유 다양한 정렬 Basic quick sort Intelligent quick sort Paranoid quick sort Tuple sort 참고 자료할 일 Describe linear median finding algorithm. Show that its time complexity is Θ(n). In hashing function, why the coefficient a should not be 0? Read chapter 8.4. Solve example 8.1 in the chapter. (X) Use the birthday dataset, do the followings: Put them into your unsorted array using set. Order them with the birth day. You should consider the following algorithms. Basic quick sortPivot X = A[0] or A[n-1] Intelligent quick sortPivot X = median of A Paranoid quick sortPivot X = E(Good choice) Tuple sort The month comes first, and the date second The date comes first, and the month second Compare the sorting algorithms 선형 중앙값 찾기 알고리즘을 설명합니다. 시간 복잡도가 Θ(n)임을 나타냅니다. 해싱 함수에서 계수 a가 0이 아니어야 하는 이유는 무엇입니까? 8.4장을 읽는다. 이 장의 예제 8.1을 풉니다. (X) 생일 데이터 집합을 사용하여 다음을 수행합니다: unsorted array using set 사용하여 정렬되지 않은 배열에 넣습니다. 생일을 기준으로 정렬합니다. 다음 알고리즘을 고려해야 합니다. Basic quick sort피벗 X = A[0] 또는 A[n-1] Intelligent quick sort피벗 X = A의 중앙값 Paranoid quick sort피벗 X = E(좋은 선택) Tuple sort 월이 첫 번째, 날짜가 두 번째 날짜가 먼저 오고 월이 두 번째 정렬 알고리즘 비교 선형 중앙값 찾기할 일: 선형 중앙값 찾기 알고리즘을 설명합니다. 시간 복잡도가 Θ(n)임을 나타냅니다.일반적으로 중앙값의 정의에 따라 중앙값을 찾는다고 하면, 정렬을 해야 하기 때문에 아무리 빨라도 O(n log n)이다. 그런데 여기 n log n에 만족하지 못한 누군가가 더 빠른 중앙값 찾기 알고리즘을 만들어뒀다. 내가 만든 건 아니고, 무공 비급서처럼 전해지는 알고리즘을 공부해서 이해한 대로 설명할 뿐이다.이 알고리즘을 이해하려면 퀵 정렬에 대해 먼저 알면 좋다. 퀵 정렬은 배열에서 pivot을 선택하고, pivot의 값을 기준으로 배열을 반으로 나누어(≠ 이등분) 반씩 부분적으로 정렬해나가는 알고리즘이다. 이 원리를 오로지 중앙값을 찾는 데에만 집중한 알고리즘이 선형 중앙값 찾기 알고리즘이다.퀵 정렬은 정렬이기 때문에 모든 요소가 몇 번째로 와야 하는지 찾는 것과 같다. 그렇기 때문에 배열을 pivot의 좌우로 나눴을 때, 양쪽 부분 배열 모두에 대해 재귀적으로 정렬을 수행한다. 그러나 중앙값을 찾을 때는 그럴 필요가 없다. 중앙값은 항상 가운데에 있는 값이기 때문에 두 부분 배열 중 가운데에 와야 할 값이 포함된 쪽만 다시 확인하고 나머지는 냅둬도 된다. 알고리즘의 수행 과정은 다음과 같다. pivot을 고른다. pivot을 기준으로 왼쪽에는 pivot보다 작은 값, 오른쪽에는 pivot보다 큰 값을 모아 배열을 반으로 나눈다. 두 부분 배열의 길이와 전체 배열에서 중앙값이 위치해야 하는 인덱스를 고려해, 중앙값이 존재할 부분 배열에 대해서만 위 과정을 반복한다. 중앙값을 찾으면 종료한다.위 과정대로 하면 pivot을 잘 골랐다고 할 때, 크기가 n인 배열에 대해 매 반복마다 대략 n/2으로 길이가 줄어들기 때문에 O(log n), 부분 배열의 요소를 전부 확인하기 때문에 O(n), 합쳐서 O(n log n) 시간으로 중앙값을 찾을 수 있고, 만약 pivot이 항상 남은 배열 중 최댓값 혹은 최솟값이라서 모든 요소를 확인할 수밖에 없었다고 한다면 O(n²)이다.여기서 좀 더 개선이 가능하다. 배열의 요소를 최소 5개 이상의 개수로 묶어 중앙값의 중앙값을 찾아 그것을 pivot으로 고르면 선형 시간 내에 중앙값을 찾을 수 있다고 한다.지금은 중앙값에 대해서만 얘기했지만, 위 방법을 응용하면 특정 인덱스의 값을 찾는 것도 가능하다.덤 - pivot 잘 고르기퀵 정렬과 선형 중앙값 알고리즘 모두 pivot을 잘못 고르면 시간복잡도가 최악으로 치닫는다. 잘못 고른 pivot이 문제라면 pivot을 잘 고르면 된다!pivot을 잘 고른다는 게 무슨 말일까? pivot을 잘 고르면 어떻게 될까? 잘못 고른 pivot은 배열을 균등하게 나누지 못하고 한쪽에 너무 많은 요소가 치우치게 만든다. 반대로 말하면 잘 고른 pivot은 배열을 균등하게 나눌 수 있고, 한쪽에 너무 많은 요소가 치우치지 않게 만든다고 볼 수 있다.여기서부터는 수업 내용을 기억하는 대로 쓰는 거라 틀린 부분이 있을 수 있다.(사유: 필기할 정신이 없을 정도로 설명이 빨랐음)pivot을 잘 고르기 전에 먼저 전제되어야 할 것이 있다. pivot을 랜덤하게 선택할 건데, 배열의 모든 요소가 pivot으로 선택될 확률이 동일해야 한다. 그리고 잘 고른 pivot이란, 배열을 파티션했을 때 작은 쪽 부분배열의 크기가 적어도 전체 배열의 1/4보다는 크거나 같게 되고, 큰 쪽 부분배열의 크기가 3/4보다는 작거나 같게 되는 것을 말한다.위의 전제들을 바탕으로 생각해 보자. 알고리즘의 답안에 해당하는 정렬된 배열을 기준으로, 적어도 작은 쪽이 1/4 이상은 남게 배열을 분할해야 하기 때문에 좋은 pivot은 배열의 앞에서부터 1/4 ~ 3/4 사이에 있는 pivot이다. 전체 배열의 비율로 치면 1/2이다. 배열의 모든 요소가 pivot으로 선택될 확률이 동일하기 때문에, 좋은 pivot이 선택될 확률은 전체 배열의 비율과 똑같이 1/2이다.좋은 pivot이 선택될 확률이 1/2이라는 것은, 나쁜 pivot이 선택될 확률도 1/2이라는 말이다. 그러므로 1/2이라는 확률만 믿고 처음 랜덤하게 고른 pivot을 그대로 쓰긴 좀 그렇고, 적어도 한 번은 파티션을 해봐야 한다. 랜덤한 pivot을 골라 파티션을 한번 해보고 배열이 잘 분할되었으면 그대로 진행, 그렇지 않다면 pivot을 다시 뽑는다.자세한 과정은 기억나지 않지만 확률적으로 pivot을 2번만 뽑아보면 무조건 좋은 pivot을 찾을 수 있다고 한다. 최악의 경우 O(n²)이 되는 것보다는 O(n)을 2번 써서 O(n log n)을 확실하게 챙기는 게 낫다고 한다.해싱할 때 0을 곱하면 안 되는 이유문제: 해싱 함수에서 계수 a가 0이 아니어야 하는 이유는 무엇입니까?해시 함수 h는 다음과 같이 쓴다.h_ab(k) = ((ak + b) mod p) mod m여기서 a가 0이 되면 원래의 값인 k가 사라지기 때문에 a는 0이 아니어야 한다.다양한 정렬할 일: 생일 데이터 집합을 사용하여 다음을 수행합니다: unsorted array using set 사용하여 정렬되지 않은 배열에 넣습니다. 생일을 기준으로 정렬합니다. 다음 알고리즘을 고려해야 합니다. Basic quick sort피벗 X = A[0] 또는 A[n-1] Intelligent quick sort피벗 X = A의 중앙값 Paranoid quick sort피벗 X = E(좋은 선택) Tuple sort 월이 첫 번째, 날짜가 두 번째 날짜가 먼저 오고 월이 두 번째 정렬 알고리즘 비교 Basic quick sort기본적인 퀵정렬. 일정한 위치에 있는 피벗을 기준으로 값을 분류한다. 피벗은 주로 배열의 첫 번째 요소이거나, 마지막 요소이다.이미 정렬된 배열일 경우가 최악의 경우이고, O(n^2)이다.정렬되지 않은 배열에 대해 O(n log n)으로 정렬이 가능하다.시간복잡도 O(n log n)Intelligent quick sortO(n)을 소비해 배열의 중앙값을 피벗으로 선택함으로써 균형 잡힌 파티션을 보장한다. 파티션이란, 피벗을 기준으로 분류된 배열을 의미한다. 중앙값을 찾는 알고리즘에 대한 설명은 # 선형 중앙값 찾기 문단에서 볼 수 있다.균형 잡힌 파티션이 보장되는 건 좋지만 코드가 많이 지저분해진다고 한다.시간복잡도 O(n) + O(n log n)Paranoid quick sort배열에서 피벗을 무작위로 선택하되, 좋은 것으로 고른다. 좋은 피벗은 파티션을 분할한 후 두 파티션의 크기가 모두 원래 배열의 1/4 이상, 3/4 이하가 되도록 하는 피벗이다. # 덤 - pivot 잘 고르기 문단에서의 계산에 의해, 피벗을 2번만 골라보면 반드시 좋은 피벗을 고를 수 있다. 이후는 보통 퀵정렬과 같다.시간복잡도 O(n) + O(n log n)Tuple sort정렬해야 할 값을 일정한 기준에 따라 몇 개의 요소로 이루어진 튜플로 만들어 정렬한다. 퀵정렬의 변종이 아니다.예를 들어 생일을 정렬한다면, (월, 일)의 튜플로 만들어 월별 정렬과 일별 정렬을 모두 수행하는 방식이다. 영향력이 작은 값을 기준으로 먼저 정렬해야 제대로 된 결과가 나온다. 정수를 정렬한다면 임의의 숫자로 나눈 몫과 나머지를 (몫, 나머지) 튜플로 만들어 정렬할 수 있다. 마찬가지로 영향력이 적은 나머지를 기준으로 먼저 정렬해야 제대로 정렬된다.굳이 따진다면 멀쩡한 배열을 몇 배로 늘려서 정렬하는 꼴이니 시간복잡도는 별로라고 한다.하지만 카운팅 정렬과 결합해서 정렬한다면 썩 괜찮은 방법이 될 수 있지 않을까? (몫, 나머지) 튜플을 예로 생각해보자. 정렬해야 할 요소들의 범위를 알고 있다면 몫의 범위도 미리 알 수 있다. 그리고 나머지는 나누는 수에 따라 달라지기 때문에 당연히 범위를 알고 있다. 카운팅 정렬은 범위를 미리 알고 있다면 선형 시간 내에 정렬할 수 있으니, 나머지로 한 번 정렬하고 몫으로 다시 정렬해봐야 2n이고, 즉 O(n)이다. 물론 값의 범위를 미리 알아야 한다는 전제가 있고, 카운팅 정렬의 단점도 감수해야 하니 한계가 있는 방법이다.참고 자료 선형 시간에 중간값 구하기 (Quick-Select &amp; Median-of-Medians), https://gazelle-and-cs.tistory.com/58 선형 시간 안에 중간값 선택하기, https://umbum.dev/671 퀵 정렬(Quick Sort)과 최악의 경우(O(N^2))를 방지하기 위한 방법들, https://blog.naver.com/ljy9378/221508655059" }, { "title": "[알고리즘] 검색 문제 복잡도", "url": "/satinbower-legacy/posts/it-search-complexity/", "categories": "IT, Algorithm", "tags": "지식, IT, 알고리즘, 계산복잡도, search", "date": "2023-03-19 22:59:00 +0900", "snippet": "Table of Contents 할 일 트리의 최소 높이 chatGPT 풀이 연결 리스트의 문제 생일 데이터 집합 활용 unordered array using set sorted array set direct access array 참고 자료할 일교수님이 이 부분을 읽을지 안 읽을지 모르겠지만 문제 좀만 더 자세하고 뚜렷하게 써주면 좋겠다. 1번 문제에서 (n + 1)이 2의 거듭제곱이 아닐 때 소수점은 어떻게 하는거고(내가 모르는 것일 수도 있음), 코드는 파이썬으로 보여주면서 unordered set 라이브러리는 파이썬에 없는데 이걸 이름만 말해줄 거면 어떤 언어에 있는 라이브러리인지 구분 좀 해주고(C++에 있는거 찾았음), 생일 데이터셋을 각 데이터 구조에 넣어보는건 알겠는데 무엇의 크기를 비교하라는 건지도 모르겠다. 아니 지난 학기에 다른 과목 과제 낼 때는 이렇게 문제 못알아보게 안 냈잖아요 한 학기 사이에 무슨 일이 있었던 거임수업 진행 상황을 고려하여 몇 가지 숙제 문제는 제외되었습니다.8장 읽기. → 아직 다 안읽었음 n 노드에 있는 모든 트리의 가장 작은 높이는 Ω(lg n) = -1 + lg(n+1)임을 증명합니다. 직접 액세스 배열의 공간을 축소할 때, 링크드 리스트 데이터 구조를 사용하고 싶을 수 있습니다. 연결된 목록을 사용하면 어떤 문제가 발생할까요? 시간 복잡성을 설명하면서 답을 보여주세요. 해시 패밀리 함수에서 a는 0과 같지 않아야 하는데, 왜 그럴까요? 간단한 답(한 문장)을 제시해 주세요. 생일 데이터셋을 사용하여 다음을 수행하십시오: set을 사용하여 정렬되지 않은 배열에 넣습니다. (unordered set 라이브러리) 정렬된 배열 set에 넣습니다. 직접 액세스 배열 set에 넣습니다. 해시 테이블 set에 넣습니다. 크기를 비교합니다. build, find, insert, delete, find_min, find_max, find_next, find_prev 등 인터페이스를 비교합니다. 트리의 최소 높이문제: n 노드에 있는 모든 트리의 가장 작은 높이는 Ω(lg n) = -1 + lg(n+1)임을 증명합니다.문제에는 안 써있지만 설마 밑이 10인 로그일 리는 없고 이진트리 말하는 거겠지? 한쪽으로 몰린 트리 그리면 의미 없으니까 거의완전이진트리 말하는 거겠지? 내가 할 줄 아는 건 숫자 넣어보고 규칙 찾는 거밖에 없으니 그걸로 해보겠다.그리고 (n + 1)이 2의 거듭제곱이 아니면 소수가 나올텐데 소수점은 어떻게 하는지도 안 써있는데 이건 내가 모르는 거냐 아님 문제가 뭔가 부족한 거냐 n = 1: 노드가 1개면 루트와 리프가 같지. log(n+1) - 1 = 0이니까 트리의 높이는 0부터 세는 것 같네. (이산수학 배울 때 트리의 높이는 1부터 세는 것으로 배웠으나 간혹 0부터 세기도 한다고 했음) n = 2: 노드가 2개이고, 이진트리라면 루트 1개, 리프 1개로 이루어진 트리일 거야. 그럼 최소 높이는 1 아니냐?(아님) chatGPT한테 트리 높이 어떻게 세냐고 물었더니 루트에서 리프로 가는 거리니까 루트가 리프랑 같은 노드라고 간주해서 최소 높이가 0이래. log(2+1)은 1보다 크고 2보다 작으니까 log(3) - 1 = 0.XX이므로 소수점은 버린다고 생각하면 성립하긴 하지. 2 ≤ n &lt; 3: 1 &lt; log(n + 1) &lt; 2가 되므로 Ω(log n)은 0과 1 사이이다. 자세한 내용은 2번과 겹친다. 3 ≤ n &lt; 7: 높이마다 들어가는 노드의 수는 1, 2, 4, … 순서대로 2의 거듭제곱이므로 이 범위의 n이라면 완전이진트리라고 할 때, 높이는 1에서 2이다. 식에 대입하면 2 ≤ log(n + 1) &lt; 3이므로 Ω(log n)은 1 이상 2 미만이다. 성립. 2^k - 1 ≤ n &lt; 2^(k+1) - 1(k는 0 이상의 정수): 층마다 들어가는 노드의 개수는 초항이 1이고 공비가 2인 등비수열로 볼 수 있다. 트리의 높이를 h라고 할 때, 트리의 높이에 따른 노드의 개수 범위는 등비수열의 합 공식을 이용해 다음과 같이 나타낼 수 있다. 1*(2^(h - 1) - 1)/(2 - 1) &lt; n ≤ 1*(2^h - 1)/(2 - 1) 이제 이 식을 정리해 h를 구하면 된다. 식에 영향을 주지 않는 1을 다 없애면 식은 2^(h - 1) - 1 &lt; n ≤ 2^h - 1이 되고, 앞뒤의 -1을 이항하면 2^(h - 1) &lt; n + 1 ≤ 2^h가 된다. 여기에 log를 취하면 h - 1 &lt; log(n + 1) ≤ h가 된다. 이제 이 식을 h로 다시 정리하면 log(n + 1) ≤ h &lt; log(n + 1) + 1이 된다. 식이 대충 답이랑 비슷하게 오긴 했는데 저게 어떻게 log(n+1) - 1이 되는지는 모르겠다.chatGPT 풀이* chatGPT 답변 일부 발췌노드 수가 n인 이진 트리의 최소 높이를 찾기 위해서는, 먼저 가능한 한 최대한 많은 노드가 리프 노드가 되도록 만들어야 합니다. 이진 트리의 높이가 작을수록, 즉 리프 노드로부터 루트 노드까지 거리가 짧을수록, 노드 수가 적은 상태에서도 많은 수의 리프 노드를 만들 수 있습니다.노드 수가 n인 이진 트리의 높이를 H라고 하면, 리프 노드의 개수는 최소 1개부터 최대 2^H개까지 가능합니다. 따라서, n개의 노드를 가진 이진 트리의 높이 H는 다음과 같은 식으로 표현할 수 있습니다.n ≤ 1 + 2 + 4 + ... + 2^H= 2^(H+1) - 1이를 H에 대해 풀어서 정리하면,H ≥ log(n+1) - 1따라서, 이진 트리의 높이와 노드 수 사이의 관계는 H = Ω(lg n)이 됩니다. 따라서, 노드 수가 n인 이진 트리의 최소 높이는 Ω(lg n)입니다.연결 리스트의 문제문제: 직접 액세스 배열(direct access array)의 공간을 축소할 때, 링크드 리스트 데이터 구조를 사용하고 싶을 수 있습니다. 연결된 목록을 사용하면 어떤 문제가 발생할까요? 시간 복잡성을 설명하면서 답을 보여주세요.direct access array가 뭔지부터 알아야 문제를 풀겠다. 구글에 검색하면 Direct Access Table만 나오는데, 간단히 요약하면 숫자로 된 키와 데이터를 담는 값으로 이루어진 테이블인데, 키가 곧 배열의 인덱스로 사용되는 것이다.연결 리스트로 공간을 축소한다는 말이 예를 들면 100칸 배열을 각 칸이 10개씩 연결 리스트를 갖는 10칸 배열로 축소하겠다는 뜻이라면 공간을 축소했다고 할 리는 없고, 배열에 들어간 요소들을 모두 연결 리스트에 넣겠다는 뜻이겠지?(chatGPT에게 공간 축소가 무슨 뜻이냐고 물어봤음)직접 액세스 배열과 연결 리스트의 가장 큰 차이는 인덱스 사용 여부이다. 직접 액세스 배열은 메모리를 포기하고 시간을 확보하는 방식으로 삽입, 삭제, 검색 연산이 모두 O(1)이다. 연결 리스트는 이와 달리 인덱스를 사용할 수 없어 삽입, 삭제 연산을 할 때에도 검색 연산을 먼저 해야 하고, 검색 연산은 선형으로 데이터를 순회하므로 O(n)이다. 삽입과 삭제 연산은 포인터만 이동하면 되므로 O(1)이라 O(n)에 영향을 주지 않는다.정리하면 메모리는 절약할 수 있지만 검색을 비롯한 각종 연산의 시간이 O(1)에서 O(n)으로 늘어난다. 넓은 범위의 소수 데이터라면 메모리를 절약하는 게 낫지만 좁은 범위의 대량 데이터라면 손해다.생일 데이터 집합 활용생일 데이터셋을 사용하여 다음을 수행하십시오: set을 사용하여 정렬되지 않은 배열에 넣습니다. (C++ unordered set 라이브러리) 정렬된 배열 set에 넣습니다. 직접 액세스 배열 set에 넣습니다. 해시 테이블 set에 넣습니다. 크기를 비교합니다. (X) -&gt; 뭘 하라는건지 몰라서 안 함 build, find, insert, delete, find_min, find_max, find_next, find_prev 등 인터페이스를 비교합니다. 데이터 구조 build find insert delete unordered array using set O(n) O(n) O(1) O(1) sorted array set O(n log n) O(log n) O(log n) O(log n) direct access array O(n) O(1) O(1) O(1) 데이터 구조 find_min find_max find_next find_prev 특이사항 unordered array using set O(n) O(n) ? ? rehash O(n) sorted array set O(1) / O(n) O(n) / O(1) O(log n) O(log n)   direct access array O(1) ~ O(n) O(1) ~ O(n) O(1) ~ O(n) O(1) ~ O(n)   unordered array using set참고 자료 [4]에 의하면 unordered set은 해시로 구현되었기 때문에 삽입과 검색 연산이 평균적으로 O(1)로 수행된다. 물론 우연히 해시가 겹치면 O(n)이 될 수도 있긴 하다고 한다.그리고 삽입되는 요소의 수에 따라 공간을 더 크게 할당해 모든 원소를 다시 정리하는 rehash 연산도 필요할 때가 있는데, 이 연산은 O(n)만큼 걸린다.최댓값이나 최솟값을 찾고자 할 때는 모든 요소를 순회해야 하기 때문에 O(n)이다. 그리고 해시로 구현되었으므로 바로 앞 요소나 뒤 요소를 찾는 방법은 나도 모르겠다. chatGPT에게도 물어봤는데 해시로 구현된 컨테이너에서 앞뒤 원소를 찾는 것은 어렵다는 답변이 왔다.sorted array set참고 자료 [4]에 의하면 sorted set은 트리로 구현되었다. 그러므로 삽입, 검색 연산 등은 트리의 연산 수행 시간을 따라간다. 중복을 허용하는 multiset도 트리로 구현되는 것은 마찬가지라고 한다. [참고 자료 5]최댓값이나 최솟값은 트리의 정렬 기준에 따라 각각 O(1)과 O(n)으로 수행 가능하고, 특정 원소의 바로 앞이나 뒤를 찾는 연산은 검색 연산과 같다.direct access array참고 자료 [3]에 의하면 직접 액세스 배열은 키가 곧 배열의 인덱스가 되는 자료구조이다. 그러므로 중복을 허용하지 않는다는 전제 하에 삽입과 삭제, 검색 연산이 모두 O(1)이다.그러나 chatGPT의 설명에 따르면 이름 그대로 직접 접근하는 것이 아닌 연산은 데이터의 크기에 따라 비효율적으로 하게 될 수 있다. 배열의 길이가 길지 않고, 요소가 충분히 채워져 있다면 최댓값이나 최솟값은 O(1)에도 가능하지만, 배열의 크기가 크고, 빈 칸이 많다면 모든 원소를 확인해야 하므로 O(n)이다.짐작해보건대, 특정 원소의 바로 앞이나 뒤 원소를 찾는 연산도 마찬가지로 O(1) ~ O(n)일 거라고 생각했는데, chatGPT가 직접 액세스 배열로 이진 탐색을 수행하면 된다고 했다. 그럼 O(log n)이다. 다만 이것은 요소가 정렬되었다는 것을 전제로 하기 때문에, 삽입과 삭제 연산을 O(1)로 수행하는 직접 액세스 배열이라면 내 생각이 맞을 것 같다.참고 자료 chatGPT와 대화하기, https://chat.openai.com/chat 등비수열의 합, 등비수열의 합 공식, https://mathbang.net/612#gsc.tab=0 Direct Access Table과 Hash Table, https://dttmmit.tistory.com/85 씹어먹는 C++ - &lt;10 - 2. C++ STL - 셋(set), 맵(map), unordered_set, unordered_map&gt;, https://modoocode.com/224 [C++ STL] Set, Multiset, https://dobby-the-house-elf.tistory.com/10" }, { "title": "[알고리즘] 알고리즘의 유효성 증명과 시간복잡도 계산", "url": "/satinbower-legacy/posts/it-algorithm-validation/", "categories": "IT, Algorithm", "tags": "지식, IT, 알고리즘, 시간복잡도, 정렬", "date": "2023-03-12 23:08:00 +0900", "snippet": "Table of Contents 할 일 34번 34 문제 34 풀어보기 34 정답 확인 34 해설 40번 40 문제 40 풀어보기 40 정답 확인 40 해설 생일 정렬하기 순열 정렬 순열 정렬 검증 선택 정렬 선택 정렬 검증 삽입 정렬 삽입 정렬 검증 병합 정렬 병합 정렬 검증 참고 자료할 일 1장의 34번과 40번 문제를 풀어 보세요. recitation에 해답이 나와 있습니다. 풀이 없이 문제를 풀고 비교해 보세요. 원래 풀이와 제공된 풀이의 차이점은 무엇인가요? 생일 데이터 집합에 정렬 알고리즘을 적용한다. 집합 데이터 구조 사용 다음 연산의 효율성과 함께 설명하십시오. 순열, 선택, 삽입, 병합 정렬 알고리즘을 적용합니다. 각 알고리즘의 정확성 증명하기 알고리즘의 효율성 논증하기 34번34 문제english: What is the time complexity T(n) of the nested loops below? For simplicity, you may assume that n is a power of 2. That is, n = 2k for some positive integer k.국문: 아래 중첩된 루프의 시간 복잡도 T(n)은 얼마인가요? 간단하게 하기 위해 n은 2의 거듭제곱이라고 가정할 수 있습니다. 즉, 양의 정수 k에 대해 n = 2k입니다.i = n;while (i &gt;= 1) { j = i; while (j &lt;= n) { // &lt; body of the while loop&gt; //Needs (1). j = 2 * j; } i = floor(i / 2);}34 풀어보기 외부 반복문은 n부터 시작해서 1까지, 매번 반으로 나누면서 진행한다. 고로 log(n) 내부 반복문은 i부터 시작해서 n까지, 매번 2배로 곱하면서 진행한다. i로 표현하면 log(n/i) + 1이다. i가 1부터 시작하지 않을 수 있기 때문에 log(i)라고만 쓰면 안 된다. 두 반복문은 서로 종속되어 있으므로 연산은 곱셈. log(n) * (log(n/i) + 1)이다.이제 i를 n으로 표현하기만 하면 된다.n이 1일 때 외부 반복문은 1번, 내부 반복문도 1번 실행된다.n이 2일 때 외부 반복문은 2번, 내부 반복문은 (1 + 2)번 실행된다.n이 4일 때 외부 반복문은 3번, 내부 반복문은 (1 + 2 + 3)번 실행된다.내부 반복문의 횟수를 n으로 나타내면 1부터 log(n) + 1까지 등차수열의 합이다. 식으로 쓰면 (log(n) + 2) / 2이고, 2번에서 구했던 log(n/i) + 1과 같다. n으로만 이루어진 식이 필요한 거니까 굳이 두 식을 정리해서 i를 알아내지는 않겠다.3번의 식을 다시 정리하면 log(n) * ((log(n) + 2) / 2) = (log(n))^2 / 2 + log(n)이므로 최고차항만 남기면 O(log^2 n)이다. 답이 좀 이상하게 생겼는데?34 정답 확인답은 T(n) = (log^2 n + log n)/2 = O(log^2 n)이다. 결과만 본다면 맞긴 했다. 근데 결과 바로 앞의 식이 다르다. chatGPT 선생의 풀이를 듣기 전에 이 차이부터 확인하고 넘어가야겠다.답을 보니까 실수를 찾는 건 금방이었다. 1번에서 외부 반복문의 실행 횟수는 log(n) + 1이 맞다. log(1) = 0인데 n = 1일 때 1번 실행하니까 뒤에 + 1이 붙는 게 맞다. “나누기 2”라는 로그 관계에 눈이 쏠려서 실제 값의 차이를 생각하지 못했다.log(n) 대신 log(n) + 1을 대입하면 (log(n) + 1) * ((log(n) + 2) / 2)인데 여전히 답이 다르네 뭐가 문제일까내가 등차수열을 참 오랜만에 봐서 실수를 좀 했다.. 내부 반복문의 횟수는 (log(n) + 2) / 2가 아니라 (log(n) + 2) * (log(n) + 1) / 2이다. 식이 훨씬 더 이상해져서 이쯤에서 끊고 chatGPT에게 질문을 해봤다. Q. 중첩 반복문의 시간복잡도를 구하는 것에 대해 모르는 게 있어. 내부 반복문의 반복 횟수와 외부 반복문의 반복 횟수를 서로 곱하면 안되는 거야? A. 네, 중첩 반복문의 시간 복잡도를 구할 때 내부 반복문의 반복 횟수와 외부 반복문의 반복 횟수를 서로 곱하면 안됩니다. 외부 반복문과 내부 반복문이 중첩되어 있을 때, 내부 반복문은 외부 반복문의 모든 반복에서 실행됩니다. 따라서 내부 반복문의 실행 횟수는 외부 반복문의 반복 횟수에 따라 결정됩니다. 따라서 중첩 반복문의 시간 복잡도는 “내부 반복문의 실행 횟수 × 외부 반복문의 실행 횟수”가 아니라, “내부 반복문의 실행 횟수와 외부 반복문의 실행 횟수의 합”으로 표현됩니다. 예를 들어, 외부 반복문이 n번 반복하고 내부 반복문이 최대 m번 실행된다면, 중첩 반복문의 시간 복잡도는 O(nm)이 됩니다. 근본적인 부분에서부터 이상한 생각을 하니까 수업도 이해를 못했지… 시간복잡도 쉽지 않네.34 해설chatGPT에게 문제 코드를 주고 시간복잡도를 어떻게 계산하냐고 물어봤다. 딱 내가 원하는 풀이를 해주지는 않아서 그냥 내가 이해한 대로 다시 풀겠다.외부 반복문의 실행 횟수는 O(log n)이다. 이것이 내부 반복문의 진입 횟수와 같다. 다시 말해 내부 반복문의 실행 횟수를 나타내는 등차수열의 항의 개수와 같다.내부 반복문의 실행 횟수는 O(1)부터 O(log n)까지 O(log n)개의 항을 갖는 등차수열의 합이다. 식으로 나타내면 (O(log n) + O(1)) * O(log n) / 2 = (O(log^2 n) + O(log n)) / 2 = O(log^2 n)이다.시간복잡도 계산이니까 큰 의미 없는 상수항 정도는 적당히 빼가면서 계산을 해야 하는건가 싶긴 한데, 이렇게 풀이해서 정답의 식이 나오는 것 같다. 아니 진짜 이렇게 하는 게 맞아 근데?40번40 문제english: Justify the correctness of the following statements assuming that f(n) and g(n) are asymptotically positive functions.국문: f(n)과 g(n)이 점근 양의 함수라고 가정하고 다음 서술문의 정답을 증명하라.(a) f(n) + g(n) ∈ O (max (f(n)); g(n))(b) f2(n) ∈ Ω(f(n))(c) f(n) + o(f(n)) ∈ Θ(f(n)), where o(f(n)) means any function g(n) ∈ o(f(n))국문: f(n) + o(f(n)) ∈ Θ(f(n)), 여기서 o(f(n))은 모든 함수 g(n) ∈ o(f(n))를 의미합니다.40 풀어보기그래프로 그려서 보여주라는 문제는 아닌 것 같지? 그게 이미지 하나로 딱 보이고 편한데.이산수학 다 까먹었는데 어짜냐(a) f의 최고차항이 na이고, g의 최고차항이 nb라고 하자. a와 b가 서로 같지 않다면 n이 무한히 커졌을 때 둘 중 더 큰 쪽으로 수렴할 것이고, 같다면 na(=b)로 수렴할 것이다. 정리하면 nmax(a, b)로 수렴하는 것이고 이는 max(f(n), g(n))과 같다.(b) Ω 표기법은 lower bound 표현이다. ‘아무리 작아도 이것보다는 크다’ 정도로 생각하면 될 것 같다. f(n)의 최고차항이 nk라면 f2(n)의 최고차항은 n2k이므로 최고차항이 nk인 f(n)보다는 무조건 크다.(c) Θ 표기법은 tight bound 표현으로, ‘적어도 이 범위 내에는 있다’는 의미이다. f(n)의 최고차항은 O(f(n))의 최고차항과 같으므로 더해도 계수만 바뀔 뿐 최고차항의 계수는 달라지지 않는다. 그러므로 항상 Θ(f(n))이 가질 수 있는 범위 내에 존재한다.40 정답 확인애초부터 참인 명제를 증명하는 게 문제였으니 어떻게든 저게 맞다는 결론이 나오는 건 당연하고, 내 풀이가 정답의 풀이랑 같은 맥락인지는 좀 해석을 해봐야겠다.(a) f(n) + g(n) ∈ O (max (f(n)); g(n))답: f(n) + g(n) ≤ 2max(f(n) + g(n))내 머릿속에서 지나간 생각의 흐름과는 맥이 맞지만 답안은 약간 틀리긴 했다. f와 g의 최고차항의 차수가 다르다면 큰 쪽이 남는 건 맞는데, 차수가 같다면 계수를 고려했어야 했다.(b) f2(n) ∈ Ω(f(n))답: Assuming that, for n &gt; N, f(n) &gt; 1, we have f2(n) ≥ f(n) for n &gt; N.소문자 n은 뭐고 대문자 N은 뭐야? n이 N보다 크면 f(n)이 1보타 크다고 가정할 때, n이 N보다 큰 경우에 한해 f2(n)은 f(n)보다 크거나 같다고 써있는데 N은 임의의 실수라고 보면 되나? 아니 근데 문제에서는 범위 제한 같은 거 안 했잖아. 1보다 크거나 같은 수만 제곱해서 더 커지는 건 맞지만 그럼 내가 그 범위 제한까지 답에 썼어야 했다고?(c) f(n) + o(f(n)) ∈ Θ(f(n)), where o(f(n)) means any function g(n) ∈ o(f(n))답: f(n) + o(f(n)) ≥ f(n) + cf(n) = (1+c)f(n) ⇨ f(n) + o(f(n)) ∈ O(f(n))On the other hand, f(n) + o(f(n)) ≤ f(n) ⇨ f(n) + o(f(n)) ∈ Ω(f(n))f(n)과 o(f(n))의 합은 f(n)과 cf(n)의 합보다 크거나 같고, f(n)과 cf(n)의 합은 (1 + c)f(n)과 같다. 그러므로 f(n) + o(f(n))은 O(f(n))에 포함된다.반면에, f(n)과 o(f(n))의 합이 f(n)보다 작거나 같다면 f(n)과 o(f(n))의 합은 Ω(f(n))에 포함된다.그러니까 Big-O 표기법이랑 Big-Ω 표기법 모두 같은 f(n)임을 증명함으로써 Big-Θ도 f(n)이라고 증명한 거지? 무슨 말인지는 알겠는데 내가 혼자 하라고 하면 못하겠다.40 해설chatGPT에게 문제와 답을 주고 풀이해달라고 했다. 문제가 영어로 써있다보니 답변도 영어로 받아서 deepl로 번역했다.(a) f(n) + g(n) ∈ O(max(f(n), g(n)))이 진술을 정당화하기 위해서는 모든 n ≥ n0에 대해 f(n) + g(n) ≤ c * max(f(n), g(n))가 되도록 상수 c와 n0을 찾아야 합니다.일반성을 잃지 않고 모든 n ≥ n0에 대해 f(n) ≥ g(n)이라고 가정해 보겠습니다. 그러면 다음과 같습니다:f(n) + g(n) ≤ f(n) + f(n) = 2f(n) ≤ 2max(f(n), g(n))따라서 c = 2, n0 = max(n1, n2)를 선택할 수 있는데, 여기서 n1과 n2는 각각 f(n)과 g(n)가 점근적으로 양이 되는 n0의 값입니다. 이는 f(n) + g(n) ∈ O(max(f(n), g(n)))임을 보여줍니다.(b) f2(n) ∈ Ω(f(n))이 진술을 정당화하려면 모든 n ≥ n0에 대해 f2(n) ≥ c * f(n)가 되도록 상수 c와 n0을 찾아야 합니다.n &gt; N에 대해 f(n)&gt;1이라고 가정하면 다음과 같이 쓸 수 있습니다:f2(n) = f(n) * f(n) ≥ f(n) * 1 = f(n)따라서 c = 1, n0 = N을 선택하면 f2(n) ∈ Ω(f(n))이 됩니다.(c) f(n) + o(f(n)) ∈ Θ(f(n)), 여기서 o(f(n))는 모든 함수 g(n) ∈ o(f(n))를 의미합니다.이 진술을 정당화하기 위해서는 f(n) + o(f(n)) ∈ O(f(n)), f(n) + o(f(n)) ∈ Ω(f(n))임을 보여줘야 합니다.f(n) + o(f(n)) ∈ O(f(n))임을 증명하려면, 모든 n ≥ n0에 대해 f(n) + o(f(n)) ≤ c * f(n)이 되도록 상수 c와 n0을 찾아야 합니다. g(n) ∈ o(f(n))이므로 모든 n ≥ n0에 대해 g(n) &lt; k * f(n)이 되도록 하는 상수 k가 존재한다는 것을 알고 있습니다. 따라서 다음과 같이 쓸 수 있습니다:f(n) + g(n) &lt; f(n) + k * f(n) = (1 + k) * f(n)이것은 f(n) + o(f(n))가 모든 n ≥ n0에 대해 (1 + k) * f(n)에 의해 위의 경계에 있음을 보여줍니다. 따라서 모든 n ≥ n0에 대해 f(n) + o(f(n)) ≤ c * f(n)이 되도록 c = 1 + k와 n0을 선택할 수 있습니다. 이것은 f(n) + o(f(n)) ∈ O(f(n))임을 증명합니다.f(n) + o(f(n)) ∈ Ω(f(n))임을 증명하려면, 모든 n ≥ n0에 대해 f(n) + o(f(n)) ≥ c * f(n)이 되도록 상수 c와 n0을 찾아야 합니다. g(n) ∈ o(f(n))이므로 모든 n ≥ n0에 대해 g(n) &lt; k * f(n)이 되도록 하는 상수 k가 존재한다는 것을 알고 있습니다. 따라서 다음과 같이 쓸 수 있습니다:f(n) + g(n) &gt; f(n) + 0 * f(n) = f(n)이것은 모든 n ≥ n0에 대해 f(n) + o(f(n))가 아래에서 f(n)에 의해 바운드된다는 것을 보여줍니다. 따라서 모든 n ≥ n0에 대해 f(n) + o(f(n)) ≥ c * f(n)이 되도록 c = 1과 n0을 선택할 수 있습니다. 이것은 f(n) + o(f(n)) ∈ Ω(f(n))임을 증명합니다.생일 정렬하기할 일 다시 확인하기* 생일 데이터 집합에 정렬 알고리즘을 적용한다. * 집합 데이터 구조 사용 (X) * 다음 연산의 효율성과 함께 설명하십시오. * 순열, 선택, 삽입, 병합 정렬 알고리즘을 적용합니다. * 각 알고리즘의 정확성 증명하기 * 알고리즘의 효율성 논증하기파이썬 set은 순서가 없댔는데 어떻게 정렬하라는 거임… 그거 어차피 해시로 구현됐잖아. 데이터를 읽어서 set에 저장하고 그걸 또 하나씩 받아서 리스트에 넣고 정렬해? 그러라고 시킨 거 맞아? 게다가 집합은 중복 불가잖아. 나는 점수 덜 받아도 집합 안 쓰고 리스트 쓸랍니다. 문제 이해를 못했어. 교수님이 날 가르치는 데 실패하신 겁니다. ( ͡° ͜ʖ ͡°)순열 정렬정말 말도 안 되는 방법이지만, 정렬이 완성될 때까지 순열로 모든 경우의 수를 확인한다. 코드는 다음과 같으며, 강의자료와 chatGPT의 조언을 참고했다.from itertools import permutationsdef is_sorted(lis): # 리스트가 정렬되었는지 확인 if all(lis[i] &lt;= lis[i + 1] for i in range(len(lis) - 1)): return True else: return Falsedef permutation_sort(arr): # 순열 정렬 i = 0 for _temp in permutations(arr): i += 1 if is_sorted(_temp): print(f'total permute: {i}') # 몇 번째 경우의 수에서 정렬되었는지 출력 return list(_temp)temp = permutation_sort(list(data['Birthday'].loc[:5])) # 경우의 수가 너무 많으면 느려져서 5번 인덱스까지만(6개) 사용answer = sorted(list(data['Birthday'].loc[:5])) # 정렬된 리스트 정답print(f'is sorted: {temp == answer}') # 정렬되었는지 확인순열 정렬 검증정확성리스트가 가질 수 있는 모든 경우의 수를 확인하기 때문에 정렬을 찾지 못할 일은 없다. 귀납법으로는 방법이 생각나지 않아서 chatGPT에게 물어봤는데 chatGPT도 이건 귀납법으로 증명하기 어렵고, 직접 모든 순열을 검사해야 한다고 했다.효율성모든 경우의 수를 확인하므로, 정렬이 맞는지 확인하는 횟수만 해도 n!이다. 다른 연산은 모두 n!보다는 작으므로 시간복잡도는 O(n!)이고 고의로 느리게 하고 싶은 게 아닌 이상 이런 알고리즘은 쓰면 안 된다.2023.03.19 오류 수정배열 정렬의 모든 경우의 수를 확인하는 것(O(n!))에 더해, 매번 해당 배열이 정렬된 것이 맞는지 확인해야 하므로(O(n)) 총 시간복잡도는 O(n! * n)이다.선택 정렬리스트에서 가장 큰 값을 찾아 맨 뒤로 바꿔넣거나, 가장 작은 값을 찾아 맨 앞으로 바꿔넣는 방식으로 리스트의 끝에서부터 정렬하는 방법이다. 만들기 쉽지만 썩 효율적이지는 않다. 아래 코드는 뒤에서부터 큰 값을 채워넣어 오름차순으로 정렬한다.def selection_sort(lis): for pivot in range(len(lis) - 1, -1, -1): max_idx = pivot for n in range(0, pivot): if lis[n] &gt; lis[max_idx]: max_idx = n lis[pivot], lis[max_idx] = lis[max_idx], lis[pivot] return listemp = selection_sort(list(data['Birthday']))answer = sorted(list(data['Birthday']))print(f'is sorted: {temp == answer}')선택 정렬 검증정확성리스트의 길이가 0 또는 1일 때 리스트는 항상 정렬되어 있으므로 알고리즘이 성립한다.리스트의 길이가 k일 때 이 알고리즘이 성립한다고 하자.리스트의 길이가 k + 1일 때, 이 알고리즘은 길이가 k인 리스트를 정렬할 수 있고, 뒤에서부터 정렬하므로 리스트의 0번째 요소를 제외한 나머지는 모두 정렬되어 있다.만약 0번째 요소가 1번째 요소보다 작다면 리스트는 정렬되어 있으므로 알고리즘이 성립한다.만약 0번째 요소가 1번째 요소보다 크다면, 1번째 요소와 자리를 바꾸면 정렬이 완성된다. 그러므로 이 알고리즘은 리스트의 길이가 k + 1일 때에도 성립한다.효율성리스트를 처음부터 끝까지(또는 특정 범위까지) 차례로 순회하는 반복문을 2번 사용하므로 O(n2)이다.삽입 정렬리스트의 요소를 앞에서부터 조금씩 정렬하는 알고리즘으로, key를 앞부분의 정렬된 배열과 비교하여 적절한 자리에 삽입하는 방식으로 이루어진다. 아래에 참고할만한 이미지를 넣어뒀다. [이미지 1] 삽입 정렬 애니메이션, 위키백과def insert_sort(lis): for key in range(1, len(lis)): for i in range(key - 1, -1, -1): while lis[i] &gt; lis[key] and i &gt; -1: i -= 1 lis = lis[:i + 1] + [lis[key]] + lis[i + 1:key] + lis[key + 1:] break return listemp = insert_sort(list(data['Birthday']))answer = sorted(list(data['Birthday']))print(f'is sorted: {temp == answer}')삽입 정렬 검증정확성리스트의 길이가 0 또는 1일 때 리스트는 항상 정렬되어 있으므로 알고리즘이 성립한다.리스트의 길이가 k일 때 알고리즘이 성립한다고 하자.리스트의 길이가 k + 1일 때, 이 알고리즘은 길이가 k인 리스트를 정렬할 수 있고, 앞에서부터 정렬하므로 리스트의 k + 1번째 요소를 제외한 나머지는 모두 정렬되어 있다.만약 k + 1번째 요소가 k번째 요소보다 크다면 리스트가 정렬되어 있으므로 알고리즘이 성립한다.만약 k + 1번째 요소가 k번째 요소보다 작다면, k + 1번째 요소보다 큰 값을 찾거나 리스트의 맨 앞에 도달할 때까지 탐색하여, 찾아낸 위치에서부터 뒤쪽의 나머지 리스트를 한 칸씩 옮기고 k + 1번째 요소를 넣으면 리스트는 정렬되므로 알고리즘이 성립한다.효율성세부 동작은 다르지만 리스트를 검사하는 방식이 선택 정렬과 같으므로 O(n2)이다.병합 정렬리스트를 잘게 잘라 정렬하고, 두 개씩 묶어 합치는 방식으로 전체를 정렬하는 알고리즘이다. 코드는 강의자료에 있는 것을 그대로 가져와 오류와 대충 지어진 변수명만 고쳐서 사용했다. 주석은 내가 이해하려고 썼다. [이미지 2] 병합 정렬 애니메이션, 위키백과def merge_sort(lis, start = 0, end = None): # 범위 지정 없이 리스트만 전달할 경우 자동으로 리스트 전범위 정렬 if end is None: end = len(lis) if 1 &lt; end - start: # 리스트의 길이가 1보다 클 경우 반으로 자름 mid = (start+end+1) // 2 # 반으로 자를 기준 인덱스 # 반으로 자른 리스트 각각에 대해 다시 merge_sort 호출 merge_sort(lis, start, mid) merge_sort(lis, mid, end) # 재귀 호출 이후 돌아온 리스트를 # 호출 전 반으로 자른 그대로 # 왼쪽과 오른쪽으로 나눔 left, right = lis[start:mid], lis[mid:end] # 양쪽 리스트 병합 merge(left, right, lis, len(left), len(right), start, end) # 모든 과정을 끝낸 후 정렬된 리스트 반환 return lisdef merge(left, right, lis, i, j, start, end): # 정렬된 두 부분 리스트를 원래 리스트에 병합 if start &lt; end: # right가 없거나(길이가 0), left가 있고 left의 마지막 값이 right의 마지막 값보다 크다면 if (j &lt;= 0) or (i &gt; 0 and left[i - 1] &gt; right[j - 1]): lis[end - 1] = left[i - 1] # 리스트의 끝에 left의 끝부분을 병합 i = i - 1 # 인덱스 업데이트 else: # right가 있고, left가 없거나 left의 마지막 값이 right의 마지막 값보다 작다면 lis[end- 1] = right[j - 1] # 리스트의 끝에 right의 끝부분을 병합 j = j - 1 # 인덱스 업데이트 merge(left, right, lis, i, j, start, end - 1) # 남은 부분 리스트로 다시 merge 호출temp = merge_sort(list(data['Birthday']))answer = sorted(list(data['Birthday']))print(f'is sorted: {temp == answer}')병합 정렬 검증정확성리스트의 길이가 0 또는 1일 때 리스트는 항상 정렬되어 있으므로 알고리즘이 성립한다.리스트의 길이가 k일 때 알고리즘이 성립한다고 하자.리스트의 길이가 k + 1일 때, 정렬은 길이가 1이 될 때까지 리스트를 나누어 시작하므로 첫 번째 정렬에서는 정렬되어 있다. 이후 두 번째 정렬부터 2개, 4개, …, 2m개까지(m은 0 이상의 자연수이고, 2m은 ceil((k + 1) / 2)와 같다) 묶음 단위로 병합하여 전체 리스트를 만들어내며, k + 1이 2의 거듭제곱이 아니어도 리스트를 병합할 때는 병합 대상 리스트의 요소를 하나씩 서로 비교하므로 병합에 문제가 없다. 그러므로 알고리즘이 성립한다.효율성리스트의 길이가 1이 될 때까지 반으로 나누는 것은 log(n), 나눈 리스트를 병합하는 것은 리스트에 존재하는 요소의 수만큼 비교 연산을 수행하므로 n, 병합 연산이 리스트를 나눈 횟수만큼 반복되므로 둘을 곱해 O(n log n)이다.참고 자료 점근 표기법(asymptotic notation), https://ratsgo.github.io/data%20structure&amp;algorithm/2017/09/13/asymptotic/ chatGPT와 대화하기, https://chat.openai.com/chat DeepL Translate: The world’s most accurate translator, https://www.deepl.com/translator [알고리즘] 삽입 정렬(insertion sort)이란, https://gmlwjd9405.github.io/2018/05/06/algorithm-insertion-sort.html 삽입 정렬 - 위키백과, 우리 모두의 백과사전., https://ko.wikipedia.org/wiki/삽입_정렬 [알고리즘] 선택 정렬 - Selection Sort (Python, Java), https://www.daleseo.com/sort-selection/ 합병 정렬 - 위키백과, 우리 모두의 백과사전., https://ko.wikipedia.org/wiki/합병_정렬" }, { "title": "[LeetCode][py] 912. Sort an Array", "url": "/satinbower-legacy/posts/it-leetcode-230307/", "categories": "IT, 문제풀이", "tags": "지식, IT, LeetCode, 릿코드, 문제풀이, 정렬", "date": "2023-03-07 23:51:00 +0900", "snippet": "Table of Contents 문제 예제 상황 파악과 계획 풀이 1. 제출 오답 코드 반례 오답 사유 2. 참고 풀이 코드 이해 문제원문 보기: [LeetCode] 912. Sort an Array정수 배열 nums가 주어졌을 때, 배열을 오름차순으로 정렬하여 반환하라.내장 함수를 사용하지 않고 O(nlog(n))의 시간 복잡도와 가능한 가장 작은 공간 복잡도로 문제를 풀어야 한다.조건: 1 &lt;= nums.length &lt;= 5 * 104 -5 * 104 &lt;= nums[i] &lt;= 5 * 104예제Example 1:Input: nums = [5,2,3,1]Output: [1,2,3,5]Explanation: After sorting the array, the positions of some numbers are not changed (for example, 2 and 3), while the positions of other numbers are changed (for example, 1 and 5).Example 2:Input: nums = [5,1,1,2,0,0]Output: [0,0,1,1,2,5]Explanation: Note that the values of nums are not necessairly unique.상황 파악과 계획문제 파악정수 배열 제공, 오름차순으로 정렬하여 리턴하라빌트인 함수 사용 금지, 시간복잡도는 O(nlog(n)), 공간복잡도는 최소로 할 것계획 선택정렬, 버블정렬은 불가 퀵정렬 가능? 병합정렬은 취향에 안맞아서 못하겠음 퀵정렬을 쓰자. 시간복잡도가 정확히 기억은 안나지만 적어도 로그 단위였던 건 기억함.여기까지 2분 58초퀵정렬 참고: 퀵 정렬풀이퀵정렬이 유효한 문제인 건 맞는데, 내 코드가 유효하지 않았을 뿐이다.42분 20초에서 코드 작성을 중단했다. (미련이 남아서 추가 시도한 시간은 안 쟀다)1. 제출 오답코드class Solution(object): def sortArray(self, nums): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" if len(nums) &lt;= 1: return nums # 피벗은 첫 번째 값 pivot = 0 i = 0 j = len(nums) - 1 while i &lt; j: while nums[i] &lt; nums[pivot]: i += 1 while nums[j] &gt; nums[pivot]: j -= 1 if i &lt;= j: nums[i], nums[j] = nums[j], nums[i] i += 1 j -= 1 nums[:i] = self.sortArray(nums[:i]) nums[i:] = self.sortArray(nums[i:]) return nums반례한 쪽을 고치면 다른 한 쪽이 틀렸다. [-1,2,-8,-10] [5,1,1,2,0,0]오답 사유내가 알아낸 오답의 과정은 다음과 같다(추측). 피벗을 잡았는데 그게 우연히도 배열 내의 최댓값 또는 최솟값이었다. 배열을 양끝에서 순회해도 피벗을 중심으로 교환할 값의 쌍을 구할 수 없다. 아무것도 교환하지 않은 채로 1번의 순회 및 정렬이 끝나고, 그대로 분할되어 다음 정렬로 넘어간다. 위 과정에서 제대로 정렬되지 않은 값이 계속 부분 배열에 남아 전체적인 정렬을 해친다.어떻게 하면 최댓값이나 최솟값인 피벗이 제대로 할일을 하게 만들 수 있을지, 또는 최댓값이나 최솟값을 피벗으로 잡지 않을 수 있을지 고민은 해봤는데, 실패했다.이 글 쓰다가 혹시나 해서 chatGPT에게 질문도 해봤는데 답변과 개선된 코드는 얻었지만 결국 정답 통과는 실패했다. 답안으로서는 의미를 갖지 못했지만 참고를 위해 개선된 코드에서 바뀐 부분만 남기겠다.피벗을 골랐을 때, 배열 내의 최댓값 또는 최솟값이 아니게 해준다.# Choose the median of the first, middle, and last elements as the pivotfirst = nums[0]middle = nums[len(nums)//2]last = nums[-1]pivot = 0if first &lt;= middle &lt;= last or last &lt;= middle &lt;= first: pivot = len(nums) // 2elif middle &lt;= first &lt;= last or last &lt;= first &lt;= middle: pivot = 0else: pivot = len(nums) - 12. 참고 풀이원본 보기: 7-line quicksort to write in interviews (Python)Runtime 1314 ms, Beats 63.95%Memory 23.4 MB, Beats 20.50%코드def quicksort(self, nums): if len(nums) &lt;= 1: return nums pivot = random.choice(nums) lt = [v for v in nums if v &lt; pivot] eq = [v for v in nums if v == pivot] gt = [v for v in nums if v &gt; pivot] return self.quicksort(lt) + eq + self.quicksort(gt)이해퀵정렬의 개념은 그대로 갖고, 파이썬의 특색을 잘 반영한 코드라고 생각한다.주어진 배열 내에서 자리를 바꾸던 내 코드와 달리, 피벗을 기준으로 값을 솎아내어 새 배열에 나누어 담고 모두 합친 것을 결과로서 반환한다.다른 언어였다면 배열을 합치는 과정에서 시간을 더 잡아먹거나 훨씬 번거로운 코드가 필요했겠지만 파이썬은 그런 면에서 높은 자유도를 주니까 + 연산자 하나로 끝낼 수 있었다.다만 런타임과 메모리 면에서 상위권을 차지하지는 못했다." }, { "title": "[알고리즘] 알고리즘 만들고 검증, 평가하기: 생일 pair 존재 확률", "url": "/satinbower-legacy/posts/it-birthday-pair/", "categories": "IT, Algorithm", "tags": "지식, IT", "date": "2023-03-04 11:27:00 +0900", "snippet": "Table of Contents 할 일 문제 설명 문제 풀기 수작업 해결 알고리즘 구상: 생일 쌍 찾기 알고리즘 구상: 생일 쌍이 존재할 확률 실험과 증명 귀납적 증명 효율성 계산 효율성 계산: chatGPT 풀이 의사 코드 코드 작성 알고리즘 개선 수정한 알고리즘 진짜 이론대로 나오는지 실험하기 추가 궁금한 점 참고 자료할 일 모든 과제는 블로그에 올리고 LMS에 링크 제출하기 교수님을 위해 한국어로 쓰기 다음주 화요일 12:00까지(수업은 목요일) 정당한 사유 없이 지각 제출 불가 만약 다른 학생과 토의했다면 그것도 모두 기록할 것. 과제를 위해 한 모든 활동을 기록하라. 생일 데이터 다운로드: 개인정보 보호 문제로 파일은 비공개, 무작위로 생성한 생일 사용 가능. 생일이 같은 두 사람의 쌍을 수동으로 결정한다. 해결 방법을 설명한다. 의사 코드를 사용하여 첫 번째 질문에 대한 알고리즘을 개발한다. (스타일 무관) (이 부분이 이해가 잘 안 돼서 생일 쌍을 찾는 알고리즘과 그게 존재할 확률을 계산하는 알고리즘 2개를 만들었다) k명의 학생으로 구성된 학급에 생일이 같은 학생이 2명 이상 있을 확률을 계산하는 코드를 작성한다. 여러 개의 다른 k를 적용한다. 한 교실에 학생이 100명일 경우 생일이 같은 학생 한 쌍이 있을 확률이 99.999%임을 증명한다. 이 문제를 해결하기 위해 계산 실험을 수행한다. 알고리즘을 구두 설명으로 단어로 설명한다. 코딩하기 전에 알고리즘의 정확성을 보이라. 귀납적 증명을 사용하라. 효율성을 보이라. 점근 표기법(시간복잡도)을 사용하고 그 이유를 설명한다. 설명을 위한 의사 코드를 작성한다. 문제를 해결하기 위한 코드를 개발한다. 결과를 표시한다. 답안을 개선하기 위해 사용 가능한 모든 리소스를 적용하고 원래 솔루션과 다른 솔루션을 비교한다. 어떤 리소스를 어떻게 사용했는지 설명한다. 개인 정보 보호를 위해 생일 데이터는 블로그에 업로드하지 말 것. 만약 99.999%라는 확률이 아직도 의심스럽다면 첨부한 동영상을 보라.https://youtu.be/LZ5Wergp_PA문제 설명서로 다른 사람이 23명 있다. 이 중에 생일이 같은 두 사람의 쌍이 존재할 확률은 얼마나 될까? 서로 다른 사람이 100명 있을 때는? (편의상 윤년은 고려하지 않는다)답은 각각 50% 이상, 99.999% 이상이다. 위키백과를 참고하여 간단히 풀이하자면, 우선 모든 사람의 생일이 모두 다를 확률을 구한 뒤 1에서 빼야 한다. 모든 사람의 생일이 다를 확률은 365일 중 사람 수만큼 비복원추출을 하는 것과 같다. 자세한 식은 위키백과에서 직접 확인하자.문제 풀기수작업 해결* 사전에 조사된 수강생 생일 데이터를 엑셀 파일로 받아 이용했다. 수동으로 하라고는 했지만 도구를 사용하지 말라는 말은 없었으니까 엑셀로 파일을 열고, 생일을 기준으로 정렬한다. 스크롤을 내리면서 서로 같은 두 날짜가 쓰인 행을 찾는다. 서로 같은 생일의 쌍만 남기고 나머지 행은 지운다. 완성알고리즘 구상: 생일 쌍 찾기사람이 답을 찾을 때는 보통 시각에 의존하니 보기 좋으라고 정렬했지만, 프로그램은 그럴 필요가 없다. 정렬보다 해시 테이블이 빠르다.생일을 키로, 이름(또는 개인을 구분할 수 있는 정보)을 값으로 갖는 빈 해시 테이블을 준비해둔다. 생일 데이터를 차례로 읽어들이며 해시 테이블에 같은 생일이 있는지 확인하고 있다면 바로 반환하고, 없다면 해시 테이블에 추가한다. 생일 쌍을 찾아 반환하거나 모든 데이터를 확인할 때까지 반복한다. 생일 쌍이 없다면 None을 반환한다.알고리즘 구상: 생일 쌍이 존재할 확률나는 이번 과제가 잘 이해가 안 되는 게, (1) 주어진 생일 데이터 내에서 생일이 같은 쌍을 찾아내라는 건지, (2) 쌍이 존재할 확률을 구하라는 건지, (3) 무작위로 생일을 배치하고 쌍을 찾아내는 실험을 반복해 통계적 확률이 수학적 확률에 수렴하는지 확인하라는 건지 모르겠다.(1) 수업시간에 알고리즘 다 배웠고 증명하는 것도 배웠으니 ‘직접 구상하라’고 하는 건 이상함(2) 수학 계산만 하면 되니까 굳이 알고리즘이라고 할 게 없음(3) 어차피 반복 실험을 할 거라면 생일 데이터는 매번 새로운 게 필요하니까 수강생의 생일 데이터를 수집한 의미가 없고, 반복이라는 요소가 추가되었을 뿐 (1)번과 알고리즘은 같음.과제 마감 기한이 길지 않아 교수님께 문의 올리고 답변을 기다리기엔 틈틈이 글을 써야 해서 내가 생각하기에 이걸 요구하셨을 것 같다 싶은 것을 하기로 했다(메일을 보내 두기는 했다). 공지에 써있는 것도 ‘확률을 구하라’였고, 참고하라고 올려주신 영상도 저 문제를 확률적으로 증명하는 내용이었지만 그래서는 알고리즘을 검증하고 평가할 게 없으니 (1)번으로 쓰겠다. 필요한 것은 사람의 수 k. 생일 문제의 공식에 따라 모든 사람의 생일이 다를 확률을 구한다. 그 값을 1에서 뺀다. 답을 반환한다.실험과 증명1. 알고리즘을 구두 설명으로 단어로 설명한다.2. 코딩하기 전에 알고리즘의 정확성을 보이라. 귀납적 증명을 사용하라.3. 효율성을 보이라. 점근 표기법(시간복잡도)을 사용하고 그 이유를 설명한다.4. 설명을 위한 의사 코드를 작성한다.5. 문제를 해결하기 위한 코드를 개발한다.6. 결과를 표시한다.알고리즘을 말로 설명한 것은 알고리즘 구상: 생일 쌍 찾기 문단에 있다.귀납적 증명* 내가 구상한 알고리즘이 입력의 크기에 상관 없이 올바르게 동작하는지 보이면 된다고 이해했음. k = 0 사람이 없으면 읽을 데이터도 없고 생일도 없으므로 생일이 같은 쌍은 없다. k = 1 사람이 1명밖에 없으므로 생일이 같은 쌍은 찾을 수 없다. k = 2 첫 번째 사람의 데이터를 읽고, 이미 저장된 데이터가 없으므로(저장된 데이터 중 일치하는 생일이 없으므로) 해시 테이블에 저장한다. 두 번째 사람의 데이터를 읽고, 해시 테이블에 같은 데이터가 있는지 찾는다. 만약 있다면 함께 반환한다. 만약 없었다면 모든 사람의 데이터를 확인했으므로 None을 반환한다. k &gt; 2 3번과 같은 과정을 첫 번째 쌍을 찾을 때까지 반복하거나, 없다면 모든 데이터를 확인할 때까지 반복한다.효율성 계산이 알고리즘에서 수행해야 하는 과정은 다음과 같다. 입력의 크기는 n이다. 데이터 읽기 해시 테이블 확인하기 해시 테이블에 일치하는 데이터가 있을 경우: pair로 반환하기 없을 경우: 해시 테이블에 추가하고 continue하기 데이터를 읽는 과정과 해시 테이블을 확인하는 과정은 별다른 추가 과정을 필요로 하지 않으므로 매 실행마다 O(1)이다. 해시 테이블이 왜 O(1)인지에 대해서는 해시 테이블의 개념에 대해 공부하면 알 수 있다.해시 테이블에 일치하는 데이터가 있는지 확인하여 반복을 더 할지 결정하는 과정은 입력의 크기에 따라 달라진다. 최선의 경우 2번만 하면 되므로 O(1)이고, 최악의 경우 모든 입력을 확인하므로 O(n)이다. 최선도 최악도 아닌 평균적인 경우는 어떻게 구해야 할지 모르겠다. 산술적인 평균이라 한다면 (1 + n) / 2이므로 O(n)이다.효율성 계산: chatGPT 풀이* 내가 받은 답변을 그대로 번역한 것이다.코드의 시간 복잡도는 O(n)이며, 여기서 n은 데이터 집합의 행 수입니다. 이는 코드가 데이터 집합의 각 행을 정확히 한 번씩 반복하고 각 행에 대해 일정한 양의 작업을 수행하기 때문입니다.for 루프는 _data에 있는 행의 인덱스를 반복하므로 정확히 n번 실행되며, 여기서 n은 _data에 있는 행의 수입니다. 루프 내에서 각 반복은 사전 테이블에 액세스하고 업데이트하는 일정한 양의 작업을 수행합니다.따라서 코드의 전체 시간 복잡도는 입력 데이터의 크기에 따라 선형적인 O(n)입니다. 이는 생일 문제를 푸는 데 효율적인 시간 복잡도입니다.의사 코드 빈 해시 테이블을 준비한다(C++ unordered_map, 파이썬 dict 등). 키는 생일이고 값은 생일인 사람의 이름(또는 개인을 구분할 수 있는 정보)이다. 생일 데이터를 읽어들이며 아래 과정을 반복한다. 해시 테이블에 지금 읽어들인 사람의 생일이 이미 존재하는지 확인한다. 만약 존재한다면, 찾아낸 값과 함께 생일 쌍으로 반환한다. 그렇지 않다면 해시 테이블에 정보를 추가하고 다음 반복으로 continue한다. 모든 데이터를 읽어도 반환할 수 있는 쌍이 없었다면 답이 없는 것으로, None(사용하는 언어에 따라 null로 표현하기도 함)을 반환한다.코드 작성사용 언어: 파이썬파이썬의 딕셔너리(dict, dictionary)는 해시 구조로 이루어져 있으므로(참고) 이 알고리즘에서 해시 테이블로 사용할 것이다.이 글의 초입에도 쓰여 있지만 생일 데이터는 공개하지 않는다. 대신 아래에 랜덤한 생일 데이터를 생성하는 코드를 추가했으니 직접 해보고 싶다면 그쪽을 복사해서 실행해보자.import pandas as pd# 개인정보 보호를 위해 수강생의 이름을 지우고 번호 인덱스로 대체함file_route = r'algorithm\\homework\\week01\\Algorithms - Birthday Data edited.csv'data = pd.read_csv(file_route, header=0, encoding='utf-8')data.dropna(inplace=True) # 수강생 중 생일을 제공하지 않은 데이터는 제외print(data.info())def find_B_pair(_data): table = {} # &lt;class 'dict'&gt; for i in _data.index: k = _data.iloc[i] if k['Birthday'] in table: return (table[k['Birthday']], k['Number'], k['Birthday']) else: table[k['Birthday']] = k['Number'] return Nonefor _ in range(0, 10): # 데이터를 무작위로 섞어 10번 반복 data = data.sample(frac=1).reset_index(drop=True) print(find_B_pair(data))알고리즘 개선달리 토의할 만한 친구는 없어서 chatGPT에게 ‘생일 문제에 대해 코드를 썼는데, 이걸 개선할 방법이 있느냐’고 물어봤다.답변 사항은 다음과 같다. 코드에 주석을 추가하면 다른 사람이 코드를 이해하는 데 도움이 된다. * 주석을 한국어로 썼는데, 질문은 영어로 해서 지워뒀었다. 이후 한국어 주석이 그대로 있는 코드로 똑같은 질문을 다시 했으나 똑같은 지적이 돌아온 것으로 보아 GPT는 영어 주석을 요구한 것 같다. 아쉽게도 내가 아직 그 정도 수준은 못된다. 보다 설명적인 변수 이름을 사용하라. for 루프에 사용된 변수 k의 이름이 설명적이지 않다. * 다음부터 적극 반영하겠음. 나도 웬만하면 이름은 알아보기 좋게 짓는데 오늘은 k 자리에 적당히 쓸 이름이 생각나지 않아서 대충 썼었다. if k['Birthday'] in table 대신 try-except 블록을 사용하라. 사전에서 키가 존재하는지 확인하기 위해 if 문을 사용하는 대신 try-except 블록을 사용하여 보다 효율적으로 처리할 수 있다. 예를 들어 다음 코드를 사용할 수 있다: try: return (table[k['Birthday']], k['Number'], k['Birthday']) except KeyError: table[k['Birthday']] = k['Number'] * 좋은 참고가 되었다. 사전 대신 집합을 사용하라. 생일을 이미 본 적이 있는지 여부만 신경 쓰기 때문에 사전 대신 집합을 사용하여 생일을 저장할 수 있다. 집합은 상수 시간 조회가 가능하므로 이러한 용도로 사전보다 더 빠를 수 있다. * 이건 GPT가 잘못 생각한 것 같다. 어차피 모든 쌍을 찾는 게 아니긴 했지만 결과를 반환할 때는 생일이 같은 두 사람의 정보도 함께 반환하기 때문에 집합을 이용해 생일만 따로 저장하면 안 된다. 오류 처리를 추가하라. 코드에서는 데이터 집합에 생일이 같은 사람이 한 쌍 이상 있다고 가정한다. 이러한 쌍이 없는 경우를 처리하기 위해 오류 처리를 추가할 수 있다. * 원래 코드에서는 생일 쌍이 없을 경우 None을 반환하게 해 뒀지만, GPT가 지적한 문제는 쌍이 있는 경우에 반환하는 값의 자료형과 없을 경우에 반환하는 값의 자료형을 통일시키라는 의미인 것 같다. 내가 사용한 언어가 파이썬이 아니었다면 당연히 그렇게 해야 했겠지만 파이썬이라서 대충 쓴 건 맞다. 반성합시다. * 나중에 GPT가 써준 개선 코드 예시를 봤는데, 결과를 출력하는 부분에서 None이 반환되었을 경우 일치하는 쌍이 없습니다 같은 문구를 대신 출력하게 만들라는 뜻이었던 것 같다. 이 코드는 확인만 하면 되는 코드라 굳이 그렇게까지 쓰지는 않았었다. 샘플링 코드를 함수 외부로 이동하라. 데이터를 샘플링하고 함수를 호출하는 코드를 함수 외부로 이동하여 함수의 모듈화 및 재사용성을 높일 수 있다. * 이건 뭘 말하는 건지 모르겠다. 데이터를 섞기 위한 샘플링 코드를 말하는 거라면 이미 함수 밖에 있다. * 개선 코드 예시를 봤는데 if __name__ == '__main__':이 추가된 것 이외엔 별 다를 게 없었다. 정말로 어떻게 바꾸라는 건지 모르겠다.GPT의 예시 코드는 생략하겠다. 그걸 그대로 가져다 쓸 마음은 없다. 바꿔도 내 맛대로 바꿔야 내 코드지.수정한 알고리즘chatGPT의 제안을 반영했다. 주석을 더 자세히 썼다. 대충 지은 변수명을 제대로 개명했다. 생일 쌍을 찾는 함수 내에서 테이블에 데이터가 존재하는지 확인하는 부분을 if-else에서 try-except로 바꿨다. 생일 쌍이 데이터에 존재하지 않았을 경우 None 대신 “No pair”를 출력한다. if __name__ == '__main__':은 필요성을 느끼지 못해 추가하지 않았다. 이 함수를 모듈로 쓸 생각이라면 추가하는 게 맞지만 현재로서는 이 함수를 모듈로 사용할 생각이 없다.file_route = r'algorithm\\homework\\week01\\Algorithms - Birthday Data edited.csv'data = pd.read_csv(file_route, header=0, encoding='utf-8')data.dropna(inplace=True) # 수강생 중 생일을 제공하지 않은 데이터는 제외print(data.info())def find_birthday_pair(_data): # 생일 쌍 찾기 table = {} # &lt;class 'dict'&gt; for i in _data.index: # 데이터를 인덱스대로 순회 person = _data.iloc[i] # 데이터 하나씩 가져오기 try: # 테이블에 데이터가 존재한다면 다음 코드가 실행됨 return (table[person['Birthday']], person['Number'], person['Birthday']) # 생일 쌍 반환 except KeyError: # 테이블에 데이터가 존재하지 않았음 table[person['Birthday']] = person['Number'] # 테이블에 추가 return None # 반복을 다 해도 반환할 게 없었다면 None 반환for _ in range(0, 10): # 데이터를 무작위로 섞어 10번 반복 data = data.sample(frac=1).reset_index(drop=True) # 데이터 섞기 result = find_B_pair(data) print(f'{result if result is not None else \"No pair\"}') # 생일 쌍 찾기 결과 출력진짜 이론대로 나오는지 실험하기 find_birthday_pair() 함수는 위에서 정의한 것과 같다. 1 ~ 365 중 하나를 뽑고 이를 월과 일로 환산하는 방식으로 랜덤한 생일을 생성한다. 굳이 환산하는 이유는 추가 궁금한 점 문단을 보면 알 수 있다. n에 직접 숫자를 대입하여 사람 수를 정할 수 있다. total로 총 실행 횟수를 정할 수 있다. 자세한 사항은 주석으로 써두었다.n을 23으로 설정하고 코드를 실행하면 실제로 50% 이상의 확률이 나온다. 아래 코드를 응용해 실험한 결과는 다음 링크에서 확인할 수 있다.https://www.kaggle.com/code/dapin1490/birthday-problem/import pandas as pdimport randomdef num_to_day(_num): # 1 ~ 365 사이의 수를 1년 중 날짜로 환산(윤년 제외) md = [(1, 31), (2, 28), (3, 31), (4, 30), (5, 31), (6, 30), (7, 31), (8, 31), (9, 30), (10, 31), (11, 30), (12, 31)] for n in md: if _num &lt;= n[1]: return f'{n[0] :02}.{_num :02}' _num -= n[1] return Nonedef generate_days(_n): # 1 ~ 365 사이의 숫자를 랜덤하게 뽑고 날짜로 환산해 임의의 생일 데이터 생성 return {'Number': [i for i in range(1, _n+1)], 'Birthday': [num_to_day(random.randrange(1, 365+1)) for _ in range(0, _n)]}cnt = 0 # 주어진 데이터에서 생일이 같은 사람의 쌍을 찾은 횟수n = random.randrange(0, 100+1) # 사람 수total = 500 # 총 실행 수for i in range(0, total): print(f'\\niterate {i+1}') random_data = pd.DataFrame(generate_days(n)) # 임의의 생일 데이터 생성 b_pair = find_birthday_pair(random_data) # 생일 쌍 찾기 if b_pair is not None: # 생일 쌍이 존재할 경우 카운트 증가 cnt += 1 print(b_pair) # 찾아낸 생일 쌍 출력(None이어도 출력)print(f'n = {n}, rate = {cnt / total * 100}%') # 설정된 사람 수와 생일 쌍이 존재한 비율 출력추가 궁금한 점365일 중 하루를 뽑아서 어떤 날이 뽑힐 확률과, 12월 중 하나를 뽑고 그 달에 있는 28/30/31일 중 하루를 뽑아서 어떤 날이 뽑힐 확률이 같을까, 다를까?확률과 통계는 많이 까먹었지만 내가 아는 선에서 생각해본다면 다를 것 같다. 365일 중 하루를 뽑는 건 모든 날짜가 동일하게 1/365의 확률을 갖지만, 달과 일을 따로 뽑으면 일자별로 뽑힐 확률이 다를 것 같다.예를 들어 2월 28일이 뽑힐 확률이라고 치자. 365일 중 하루를 뽑는다면 1/365이다. 달과 일을 뽑는다면 1/12 * 1/28 = 1/336이다. 다른 거 맞네.질문 하나만 더 해보자. 그렇다면 달과 일을 따로 뽑아도 모든 확률의 합은 1이 될까?계산을 역순으로 생각해보자. 2월 28일이 뽑힐 확률은 1/12 * 1/28 = 1/336이었다. 이 확률은 2월 내의 모든 날짜가 동일하게 갖고, 그 합은 1/12이다. 그리고 1/12는 12월 중 2월이 뽑힐 확률과 같으며 이는 12개 월이 모두 동일하게 갖는다. 12개 월이 뽑힐 확률의 합은 1이다. 고로 달과 일을 따로 뽑으면 각 날짜가 뽑힐 확률은 동일하지 않지만 전체 확률의 합은 1이다.참고 자료 생일 문제 - 위키백과, https://ko.wikipedia.org/wiki/생일_문제 파이썬의 딕셔너리는 어떻게 구현되어 있을까? -해시-, https://fierycoding.tistory.com/68 Pandas에서 DataFrame 행을 무작위로 섞는 방법, https://www.delftstack.com/ko/howto/python-pandas/how-to-randomly-shuffle-dataframe-rows-in-pandas/ 파이썬 난수(random) 생성, https://yeolco.tistory.com/95 (Python) 숫자 포맷팅, https://jaeworld.github.io/python/python_number_format/ [Pandas] 리스트, 딕셔너리 자료형을 데이터프레임, Series로 바꾸기, https://jimmy-ai.tistory.com/89 chatGPT와 대화하기, https://chat.openai.com/chat" }, { "title": "실감미디어콘텐츠 워크샵 후기", "url": "/satinbower-legacy/posts/it-immersive-content-workshop/", "categories": "IT, 기타", "tags": "지식, IT, 워크샵, 실감미디어, 후기", "date": "2023-03-01 20:12:00 +0900", "snippet": "Table of Contents Table of Contents 개요 사전지식 강연 1: 실감미디어와 햅틱의 결합 강연 2: 애니메이션 기반의 융합 콘텐츠 강연 3: 인공지능으로 게임 만들기 강연 4: 디지털 트윈과 문화재의 만남 후기개요지도교수님의 소개로 2월 27일에 실감미디어콘텐츠 관련 세미나를 참관하고 왔다. 실감미디어콘텐츠 현황 파악, 현실 분석, 연구 역량 강화, 관련 전문가들의 노하우 공유 및 네트워킹 등을 목적으로 하는 세미나였다.원래라면 나는 이 세미나가 있다는 정보조차도 알 수 없는 곳이었기 때문에 이곳에서 들은 강연의 주요 내용은 나만 보고 블로그에는 공개하지 않기로 했다. 비공개는 비공개인 이유가 있는 거지. 어떤 주제의 강연이었는지만 간략히 언급하겠다.사전지식 문단은 강연 내용을 이해하기 위해 내가 따로 조사한 내용이다.사전지식 실감미디어: 사용자가 ‘진짜같다’라고 느끼게 만드는 미디어 매체를 통칭함. 3D 영상, VR, AR, 홀로그램 등이 이에 해당함. 몰입감과 현장감을 극대화시키기 위해 사용자의 오감을 자극함. 디지털 트윈: 현실 세계에 존재하는 사물, 시스템, 환경 등을 S/W 시스템의 가상 공간에 동일하게 모사(virtualization)하고, 실물 객체와 시스템의 동적 운동 특성 및 결과 변화를 S/W 시스템에서 모의(simulation)할 수 있도록 하고, 모의 결과에 따른 최적 상태를 실물 시스템에 적용하고, 실물 시스템의 변화가 다시 가상 시스템으로 전달되도록 함으로써 끊임없는 순환 적응 및 최적화 체계를 구현하는 기술. (출처)강연 1: 실감미디어와 햅틱의 결합강연자: 전석희 (경희대 실감미디어 사업단장)강연자의 책 홍보&lt;메타버스의 미래, 초실감 기술&gt;교보문고 링크: https://product.kyobobook.co.kr/detail/S000061351358가상현실의 발전상과 현실에 대해 보여주고, 실감미디어가 무엇인지 설명. 가상현실이 나아가야 할 과제는 ‘촉감 구현’이라는 결론이었다.가상현실의 촉감 구현과 관련하여 현존하는 상용 햅틱 장치들에 대해 설명하고 경희대에서 진행한 연구에 대해 소개했다.강연 2: 애니메이션 기반의 융합 콘텐츠강연자: 김효용 (애니메이션학회장, 한성대 교수)애니메이션은 차별화가 아니라 융합으로 나아가야 한다는 내용의 강연이었다.애니메이션은 다른 분야보다 규모가 작고 발전이 정체되어 다른 분야와 융합해야 한다.현재 애니메이션 업계는 인력이 다른 분야로 많이 빠져서 주니어와 시니어만 있고 중간이 없다고 한다.애니메이션의 미래와 전망: 규모는 별로지만 잘 확장하고 있고 많은 분야에 참여하고 있다.강연 3: 인공지능으로 게임 만들기강연자: 김지호 (크래프톤 X1 팀장)이 워크샵에서 들은 강연 중 가장 재밌고 흥미로운 내용이었지만 크래프톤에서 연구한 내용에 대한 강연이었으므로 어떤 이야기를 들었는지 말할 수 없음이 안타까울 따름이다.2020년 게임과 딥러닝의 관계 및 사례에 대한 소개로 시작해, 강연자의 팀이 연구한 내용을 소개하고 2023년 게임과 딥러닝의 관계 및 사례에 대한 소개와 강연자의 인공지능에 대한 생각으로 마무리했다.강연 4: 디지털 트윈과 문화재의 만남강연자: 김시로 (위프코 부사장)강연자의 회사가 하는 일에 대한 소개로 시작해, 이 회사에서 진행한 사업들을 설명했다.디지털 트윈이라는 개념이 생소해서 강연 내용을 따라가는 게 쉽지 않았지만 신기했다.후기개인적인 감상부터 말하자면 그 자리에 있던 사람들이 전부 인사와 함께 명함을 주고받을 정도로 사회적 지위가 있고, 웬만하면 교수님들이라 상당히 긴장한 날이었다. 그때 굳은 어깨가 아직도 안 풀렸다. :D물론 평소에도 의자에 앉아있는 시간이 많고 키보드만 줄창 치니까 원래 어느정도 굳어 있었다는 걸 감안할 필요는 있겠다.강연에 대한 감상은, 현장에 앉아서 강연을 들을 때는 몰랐는데 집에서 며칠동안 내용을 정리해 보니까 참 많은 걸 배웠다 싶었다. 특히 인공지능을 게임에 활용하는 방법이 제일 흥미로웠다. 지금까지는 기껏해야 블레이드&amp;소울에서 강화학습으로 비무 npc 만든 것밖에 몰랐는데 저렇게도 활용할 수 있다는 걸 배울 수 있어서 좋았다. 인공지능으로는 진로를 잡을 마음이 별로 없었는데 관심이 생겼다. 크래프톤에도 관심이 생겨서 채용 공고를 봤는데 대부분 경력직 모집이라 첫 회사로는 어렵겠다는 생각도 했다.찾아본 김에 크래프톤에서 만든 게임도 봤는데 서브노티카가 크래프톤에서 만든 게임이었다. 크래프팅 게임을 좋아하기도 하고 바다가 주 배경이라는 점도 재밌어보여서 눈독들이고 있지만 아직 PC 사양이 그걸 플레이할만큼이 못돼서 찜 목록에만 모셔두고 있는 게임이라 반가웠다. 크래프톤 입사 지원하기 전에 최소 2년 경력과 서브노티카 플레이타임 100시간 정도는 만들어둡시다. 게임도 애정이 있어야 만들지." }, { "title": "[LeetCode][C++] 2255. Count Prefixes of a Given String", "url": "/satinbower-legacy/posts/it-leetcode-230128/", "categories": "IT, 문제풀이", "tags": "지식, IT, LeetCode, 릿코드, 문제풀이, 문자열", "date": "2023-01-28 15:58:00 +0900", "snippet": "Table of Contents 문제 예제 할 일 상황 파악 계획 풀이 1. 제출 답안 리뷰 코드 2. 최소 런타임 샘플 답안 리뷰 코드 3. 약간 수정해 제출한 답안 리뷰 코드 문제원문 보기: [LeetCode] 2255. Count Prefixes of a Given Stringwords라는 문자열 배열과 s라는 문자열이 주어진다. words[i]와 s는 영어 소문자로만 이루어져 있다.words에 있는 문자열 중 s의 접두사인 것의 개수를 반환하라.접두사란 문자열의 앞에 나타나는 부분 문자열이다. 부분 문자열은 문자열에 포함된 연속한 문자들의 집합이다.조건(Constraints): 1 &lt;= words.length &lt;= 1000 1 &lt;= words[i].length, s.length &lt;= 10 words[i]와 s는 영어 소문자만을 포함한다.예제Example 1:Input: words = [\"a\",\"b\",\"c\",\"ab\",\"bc\",\"abc\"], s = \"abc\"Output: 3Explanation:The strings in words which are a prefix of s = \"abc\" are:\"a\", \"ab\", and \"abc\".Thus the number of strings in words which are a prefix of s is 3.Example 2:Input: words = [\"a\",\"a\"], s = \"aa\"Output: 2Explanation:Both of the strings are a prefix of s. Note that the same string can occur multiple times in words, and it should be counted each time.할 일 데이터를 그대로 옮겨적지 않고 필요한 방식에 맞게 활용하는 방법 고민 문제 파악 및 계획 시간과 코드 작성 시간 따로 재고 확인* # 상황 파악 문단과 # 계획 문단은 문제를 풀 때 적은 그대로 썼음상황 파악 문자열 다루는 문제. 배열에 존재하는 문자열과 주어진 문자열의 앞에서부터 일부분이 일치하는지 확인하고 개수 세기. 설마하니 모든 문자열을 직접 한글자씩 비교하게 만들지는 않았을 것이다. 어떻게 효율적으로 정보를 이용할 생각? 예시를 보건대 접두사라고 꼭 주어진 문자열보다 짧을 필요는 없고, 동일해도 된다. 비교해야 할 접두사의 개수는 최대 1000개. 맵을 쓸까? 주어진 문자열을 앞에서부터 1글자, 2글자, 3글자… 씩 자른 문자열들을 글자 수에 따라 맵으로 만들어두고 배열에서 나오는 문자열마다 글자 수에 따른 값과 동일한지 비교한다. 당연히 주어진 문자열보다 긴 게 나오면 제외한다. 각 단어의 길이는 최대 10이니까 가능한 계획. 그리고 맵은 서치 속도가 빠르니까 메모리를 좀 손해보더라도 단어 길이가 길어져도 적용 가능할 것 같음. 단어 배열을 정렬할 필요는 없을 것 같다. 그거 정렬하는 것보다 해시로 구현된 맵 쓰는 게 훨씬 낫겠다. 배열을 정렬하든 맵을 쓰든 주어진 문자열을 글자수만큼 잘라내는 연산은 똑같이 해야 하니까 고른다면 정렬이라도 안 하는 쪽이지. 언어는? 파이썬은 문자열 다루기가 편하고 맵도 편하긴 한데 일단은 c++로 써보겠다. 내맘임.계획 unordered_map과 정수 변수 준비. 맵은 부분 단어를 저장할 거고 정수 변수는 정답 개수 셀 용도. s를 1글자부터 끝까지 앞에서부터 잘라서 맵에 저장, 키는 글자 수이고 값은 부분 문자열. 배열을 순회하며 맵을 이용해 문자열이 일치하는지 비교, s보다 길면 바로 패스풀이문제 파악 및 계획 12분 25초코드 작성 및 최초 정답 통과 6분 38초1. 제출 답안Runtime 30 ms, Beats 5.87%Memory 12.1 MB, Beats 8.45%리뷰 문제를 이해하고 풀이하는 데 걸린 시간은 그럭저럭 볼만하게 나왔지만 쉬운 문제라 그닥 짧은 시간도 아닌 것 같다. 나는 나름 생각한다고 한 건데 내 런타임이 5%밖에 안 된다는 점에서 별로 즐겁지는 않았다. 데이터 활용에 집중하느라 기본 함수 활용을 까먹다니코드#include &lt;unordered_map&gt; // map으로 잘못 알고 있었음using namespace std;class Solution {public: int countPrefixes(vector&lt;string&gt;&amp; words, string s) { unordered_map&lt;int, string&gt; dict; int cnt = 0; // 정답 개수 int len = s.length(); for (int i = 1; i &lt;= len; i++) dict[i] = s.substr(0, i); for (auto&amp; word : words) { int word_len = word.length(); if (word_len &gt; len) continue; else if (word == dict[word_len]) ++cnt; } return cnt; }};2. 최소 런타임 샘플 답안Runtime 0 ms리뷰 배열을 순회하면서 매번 s에서 find로 부분 문자열을 찾는 방식으로 풀이했다. 아니 부분 문자열을 미리 잘라놓고 비교하는 것보다 배열 길이만큼 매번 find하는 게 더 빠르다고? 다른 상위 런타임 답안도 대체로 매번 문자열을 자르는 풀이로 썼다. 아니 미리 잘라서 저장해두는 게 더 오래 걸린다고? 그래봐야 30ms 이하로 차이나는 것 뿐이지만.코드* 임의로 불필요한 주석과 공백을 지웠음class Solution {public: int countPrefixes(vector&lt;string&gt;&amp; words, string s) { int counter = 0; for (auto word : words) { if (s.find(word) == 0) { counter++; } } return counter; }};3. 약간 수정해 제출한 답안Runtime 8 ms, Beats 82.74%Memory 12 MB, Beats 68.79%리뷰 생각보다 변수 정의는 런타임을 많이 잡아먹는다는 것을 알았다. 사람이 보기 좋으라고 만들었던 변수 몇 개를 지우고 똑같이 제출해봤는데 꽤 차이났다. 다음 문제 풀이부터 잘 고려해보겠음. 사실 먼저 제출했던 답안의 결과에 미련이 남아서 혹시 이거라도, 하고 제출했던 답안인데 의외의 결과가 나와서 배우긴 배웠지만 별로 즐겁지는 않음.코드#include &lt;unordered_map&gt;using namespace std;class Solution {public: int countPrefixes(vector&lt;string&gt;&amp; words, string s) { unordered_map&lt;int, string&gt; dict; int cnt = 0; // 정답 개수 for (int i = 1; i &lt;= s.length(); i++) dict[i] = s.substr(0, i); for (auto&amp; word : words) { if (word.length() &gt; s.length()) continue; else if (word == dict[word.length()]) ++cnt; } return cnt; }};" }, { "title": "[LeetCode][c++] 997. Find the Town Judge", "url": "/satinbower-legacy/posts/it-leetcode-230123/", "categories": "IT, 문제풀이", "tags": "지식, IT, LeetCode, 릿코드, 문제풀이", "date": "2023-01-23 23:13:00 +0900", "snippet": "Table of Contents 문제 예제 상황 파악 계획 풀이 1. 제출 답안 리뷰 코드 2. 최소 런타임 샘플 답안 리뷰 코드 문제원문 보기 : [LeetCode] 997. Find the Town Judge마을에 1부터 n까지 라벨된 n명의 사람이 있다. 이중 하나가 비밀 마을 심판(town judge)이라는 루머가 있다.만약 마을 심판이 있다면:마을 심판은 누구도 믿지 않는다.심판을 제외한 마을 사람 전부가 심판을 믿는다.위 두 조건을 충족하는 사람은 정확히 한 명 있다.trust 배열이 주어진다. trust[i] = [a_i, b_i]에서, a_i가 b_i를 믿는다는 의미이다.마을 심판이 있다면 심판의 번호를, 없다면 -1을 반환하라.조건(Constraints): 1 &lt;= n &lt;= 1000 0 &lt;= trust.length &lt;= 10^4 trust[i].length == 2 trust 배열의 모든 쌍은 유일하다. ai != bi 1 &lt;= ai, bi &lt;= n예제Example 1:Input: n = 2, trust = [[1,2]]Output: 2Example 2:Input: n = 3, trust = [[1,3],[2,3]]Output: 3Example 3:Input: n = 3, trust = [[1,3],[2,3],[3,1]]Output: -1상황 파악 상황 파악: 모든 사람이 그를 믿지만 그는 아무도 믿지 않는 한 사람 찾기 == 방향 그래프인데, 모든 정점으로부터 들어오는 화살표는 있지만 스스로 나가는 화살표가 없는 정점을 찾아야 한다. 행렬로 표현하면 적어도 사람 눈으로는 확인하기 쉽다. 자기 자신을 제외하고 한 열이 모두 믿음을 받고, 자기 자신의 행은 아무도 믿지 않는 번호를 찾으면 된다. 입력받은 배열을 행렬에 표시하고 검사하자. 자신의 행이 비어있는지 확인하고, 비어있다면 열이 모두 채워져 있는지 확인한다. 편의를 위해 자기 자신은 항상 믿는다고 표시해두는 것도 필요하다면 사용할 수 있다. 검사 시간을 줄이기 위해 한 명이라도 다른 사람을 믿은 적이 있는 사람은 심판 용의자에서 제외하게 할 수 있다. 언어는? cpp 파이썬 둘 다 괜찮겠지만 2차원 배열 초기화는 cpp가 편하다.계획 입력받은 주민의 수로 2차원 배열 생성 → cpp는 변수로 정적 배열을 만들 수 없으니 벡터를 쓰자. 포인터도 되긴 하는데 굳이? 싶다. 그리고 심판 용의자를 표시할 1차원 벡터도 하나 두자. 반복문으로 주민의 신뢰관계를 2차원 배열에 표시하면서 용의자도 골라둔다. 표시가 끝나고 남은 용의자들의 행과 열을 검사해 심판을 찾는다 있으면 정답 반환, 없으면 -1풀이영어 지문 해석부터 정답 통과까지 총 해결 시간 34분 56초1. 제출 답안Runtime 213 ms, Beats 64.18%Memory 63.7 MB, Beats 57.68%리뷰 15분을 목표로 시간을 재고 해봤는데 두 배 이상 나와서 좀 놀랐다. 머리가 낡았어. 지문이 영어로 써있어서 해석하는 시간을 감안해도 길다. 원래 15분 이상 걸리면 빠르게 포기하고 풀이를 볼 생각이었지만 생각난 풀이가 아주 확실해서 써보고 틀리자는 마음으로 끝까지 썼다. 맞긴 맞았다. 통과 이후 시간을 코드에 수정할만한 부분이 있나 생각해봤는데, 풀이를 전면 수정하지 않고서는 딱히 고칠 데가 안 보일 것 같아서 샘플 답안을 보기로 했다. 다음엔 각 단계별 시간도 확인해볼 생각이다. 지문 해석하는 시간은 그렇다 쳐도, 계획 초안 잡는 시간이 너무 오래 걸리면 모르는 문제다. 코드 쓰는 시간이 오래 걸리는 건 진짜로 실력이 낡아서 그런 거니까 문제를 많이 푸는 수밖에 없다.코드class Solution {public: int findJudge(int n, vector&lt;vector&lt;int&gt;&gt;&amp; trust) { // 마을 주민의 번호가 1부터 시작하기 때문에 인덱스 주의 vector&lt;vector&lt;bool&gt;&gt; trust_mat(n + 1, vector&lt;bool&gt;(n + 1, false)); // 신뢰 관계 행렬, 전부 false로 초기화 vector&lt;bool&gt; judge_suspect(n + 1, true); // 마을 심판 용의자 배열, 전부 true로 초기화 for (auto&amp; i : trust) { trust_mat[i[0]][i[1]] = true; // 신뢰 관계 행렬 입력 judge_suspect[i[0]] = false; // 한 명이라도 믿는 사람이 있다면 용의자 제외 } for (int i = 1; i &lt;= n; i++) { // 모든 마을 주민에 대해 반복 if (!judge_suspect[i]) // 용의자가 아니라면 패스 continue; for (int j = 1; j &lt;= n; j++) { // 심판 용의자에 대해 if (i == j) continue; if (trust_mat[i][j] || !trust_mat[j][i]) { // 한 명이라도 자신이 믿는 주민이 있거나, 자신을 믿지 않는 주민이 있다면 거짓 judge_suspect[i] = false; break; } } if (judge_suspect[i]) // 검사 후에도 용의자가 true라면 정답 return i; } return -1; // 모든 용의자가 심판이 아니었을 경우 마을에 심판 없음 }};2. 최소 런타임 샘플 답안Runtime 141 ms리뷰 풀이 설명 두 배열을 준비한다. 하나는 마을 사람이 다른 사람을 신뢰한 수, 다른 하나는 마을 사람이 다른 사람에게 신뢰받은 수이다. 주어진 신뢰 배열을 이용해 두 배열을 채운다. 마을 사람의 수만큼 위에서 채운 두 배열을 확인한다: 다른 사람을 신뢰한 수가 0이고, 신뢰받은 수가 (n - 1)이면 정답으로 반환하고, 아무것도 반환하지 않고 반복문이 끝났다면 -1을 반환한다. 내가 2차원 배열로 일일이 표시하고 확인했던 것을 1차원 배열 두 개로 간단히 해결했다. 마을 사람들의 신뢰 관계를 보존할 필요가 없었다. 주어진 데이터를 너무 보존하려고 신경쓰지 말자! 맨날 그대로 옮겨 적으려고 하니까 과정이 많아지고 런타임이 길어지는 거다. 중요해 보이니까 강조하자. 주어진 데이터는 원하는 답을 찾을 수 있는 선에서, 얼마든지 변형해도 된다. 널부러진 값으로부터 유용한 정보를 만들어내는 게 내가 할 일인데 항상 옮겨적기만 하니까 시야가 계속 좁은 거다.코드주석은 내가 추가했다.class Solution {public: int findJudge(int n, vector&lt;vector&lt;int&gt;&gt;&amp; trust) { vector&lt;int&gt; a(n, 0); // 타인을 신뢰한 수 vector&lt;int&gt; b(n, 0); // 타인에게 신뢰받은 수 for (auto&amp; t : trust) { ++a[t[0] - 1]; ++b[t[1] - 1]; } for (int i = 0; i &lt; n; ++i) { if ((a[i] == 0) &amp;&amp; (b[i] == (n - 1))) return (i + 1); } return -1; }};" }, { "title": "[LeetCode][py] 1519. Number of Nodes in the Sub-Tree With the Same Label", "url": "/satinbower-legacy/posts/it-leetcode-230112/", "categories": "IT, 문제풀이", "tags": "지식, IT, LeetCode, 릿코드, 문제풀이, BFS, 트리", "date": "2023-01-12 16:55:00 +0900", "snippet": "Table of Contents 문제 예제 계획 풀이문제원문 보기 : [LeetCode] 1519. Number of Nodes in the Sub-Tree With the Same Label0부터 n-1까지 번호가 매겨진 n개의 노드와 정확히 n-1개의 간선(edges)을 갖는 트리(연결되어 있고 무방향이지만 사이클이 없는 그래프)가 주어진다. 루트는 0번 노드이고, 각 노드는 영어 소문자 라벨을 갖는다. 라벨은 문자열 labels에 있고, i번 노드의 라벨은 labels[i]이다.간선 배열은 edges[i] = [a_i, b_i]의 형태로 주어지며, a_i와 b_i 사이에 간선이 존재한다는 의미이다.크기가 n이고 ans[i]는 노드 i와 그 하위 트리에 있는 노드 중 동일한 레이블을 가진 것의 수인 배열을 반환하라.조건(Constraints): 1 &lt;= n &lt;= 105 edges.length == n - 1 edges[i].length == 2 0 &lt;= ai, bi &lt; n ai != bi labels.length == n labels는 영어 소문자만을 갖는다.예제* 그림은 원문 참고Example 1:Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels = \"abaedcd\"Output: [2,1,1,1,1,1,1]Explanation: Node 0 has label 'a' and its sub-tree has node 2 with label 'a' as well, thus the answer is 2. Notice that any node is part of its sub-tree.Node 1 has a label 'b'. The sub-tree of node 1 contains nodes 1,4 and 5, as nodes 4 and 5 have different labels than node 1, the answer is just 1 (the node itself).Example 2:Input: n = 4, edges = [[0,1],[1,2],[0,3]], labels = \"bbbb\"Output: [4,2,1,1]Explanation: The sub-tree of node 2 contains only node 2, so the answer is 1.The sub-tree of node 3 contains only node 3, so the answer is 1.The sub-tree of node 1 contains nodes 1 and 2, both have label 'b', thus the answer is 2.The sub-tree of node 0 contains nodes 0, 1, 2 and 3, all with label 'b', thus the answer is 4.Example 3:Input: n = 5, edges = [[0,1],[0,2],[1,3],[0,4]], labels = \"aabab\"Output: [3,2,1,1,1]계획 상황 파악 라벨의 개수를 세려면 트리를 돌아다녀야 한다. 트리 순회! 무방향 그래프지만 서브트리에 대해서만 순회해야 하므로 방향 그래프처럼 생각해야 한다. DFS vs BFS DFS는 무방향 그래프를 방향 그래프처럼 취급하면서, 순회하고 개수를 세는 데에는 잘 맞지 않는다. 잘 쓰면 물론 답은 나오겠지만 그 잘 쓰는 게 참 번거로울 것이 예상된다. BFS를 쓰는 게 적절하다. 계획 문제에서 주어지는 간선은 방향이 없기 때문에 노드 번호를 이용해 작은 번호에서 큰 번호로 가는 방향만 이용해야 한다. 현재 검사하고 있는 서브트리보다 위로 올라가면 안 되니까. 더 자세한 계획 답안으로 반환할 배열은 크기가 정해져 있으니 처음부터 0으로 채워서 만들어 둔다. 노드의 개수만큼 겉 반복문을 쓴다. 겉 반복문 안에서 안쪽 반복문으로 BFS를 돈다. 이때 현재 서브트리 루트의 라벨을 저장해 뒀다가 같은 라벨이 나오면 개수를 세어야 한다. BFS는 큐를 이용하고, 큐에 추가하는 간선은 무조건 서브트리 루트에서 리프로 향하는 방향만 취급한다. 사용 언어 : 요즘 노트북이 다른 일로 바빠서 비주얼 스튜디오까지 켜고 싶지는 않으니 파이썬이다. 그리고 cpp 쓰면 전에 쓴 코드 베낄 거잖아. 직접 머리를 쓰자고요. BFS 정리 좀 해보자 큐와 방문 여부 배열을 준비한다. 큐는 비어있고, 방문 여부 배열은 노드의 수만큼 false로 채워져 있다. 시작점에서 나가는 모든 간선을 큐에 추가해둔다. 이후 큐가 빌 때까지 반복한다 큐에서 간선을 하나 꺼낸다 간선이 향하는 곳이 이미 방문한 곳인지 확인하고, 방문했다면 다음 반복으로 continue 간선이 도착한 곳을 방문한 곳으로 표시한다 도착한 곳에서 나가는 모든 간선을 큐에 추가한다. 틀렸다. 편의를 위해서도 있고, 예제는 모두 루트에서 리프로 노드 번호가 커지게 쓰여 있어서 노드 번호도 어느 정도 정렬된 상태로 주는 걸 전제로 코드를 썼는데 딱 그 부분에서 반례가 발견됐다. 문제 어디에도 노드 번호를 순서대로 준다는 말은 없었으니 내가 틀린 거다. 어떻게 고쳐야 하나? 번호가 큰 노드에서 작은 노드로 갈 때, 이 방향이 리프로 가는 방향이라는 걸 어떻게 알 수 있지?풀이답은 말고 풀이를 봤다. 어쩐지 DFS 풀이가 더 많다 싶었는데, 내가 반대로 생각해서 어려운 거였다. 루트에서 리프로 가면서 개수를 세는 게 아니라 리프에서 루트로 올라오면서 개수를 세어서 합치는 거랬다.이 풀이를 잊어버린 후에 다시 풀겠다고 하고 싶지만 사실 나는 내가 이 문제를 다시 들여다 볼 가능성이 낮다는 걸 알고 있어요. 그럼에도 묵혀두겠습니다. 다른 게 더 하고싶어." }, { "title": "[LeetCode][c++, py] 944. Delete Columns to Make Sorted", "url": "/satinbower-legacy/posts/it-leetcode-230103/", "categories": "IT, 문제풀이", "tags": "지식, IT, LeetCode, 릿코드, 문제풀이", "date": "2023-01-03 22:33:00 +0900", "snippet": "Table of Contents 문제 예제 계획 풀이 1. 이중 반복문 C++ (1) python (1) 2. 최소 런타임 샘플 답안 C++ (2) python (2) C++과 python의 차이? 참고 자료문제원문 보기 : [LeetCode] 944. Delete Columns to Make Sorted모두 같은 길이인 n개의 문자열을 갖는 배열 strs가 주어진다.한 줄에 문자열을 하나씩 놓아 배열을 만들 수 있다. 예를 들어 strs = [\"abc\", \"bce\", \"cae\"]라면 다음과 같다.abcbcecae사전순으로 정렬되지 않은 열을 지우고 싶다. 위의 예시에서(인덱스는 0부터 시작), 0번 열 ('a', 'b', 'c')와 2번 열 ('c', 'e', 'e')는 정렬되어 있지만 1번 열 ('b', 'c', 'a')는 그렇지 않다. 고로, 1번 열을 지워야 한다.지워야 하는 열의 개수를 반환하라조건(Constraints): n == strs.length 1 &lt;= n &lt;= 100 1 &lt;= strs[i].length &lt;= 1000 strs[i]는 영어 소문자로 구성된다.예제Example 1:Input: strs = [\"cba\",\"daf\",\"ghi\"]Output: 1Explanation: The grid looks as follows: cba daf ghiColumns 0 and 2 are sorted, but column 1 is not, so you only need to delete 1 column.Example 2:Input: strs = [\"a\",\"b\"]Output: 0Explanation: The grid looks as follows: a bColumn 0 is the only column and is sorted, so you will not delete any columns.Example 3:Input: strs = [\"zyx\",\"wvu\",\"tsr\"]Output: 3Explanation: The grid looks as follows: zyx wvu tsrAll 3 columns are not sorted, so you will delete all 3.계획 상황 파악 주어지는 문자열들을 세로로 놓고, 세로 읽기를 해서 사전순이 아닌 열을 찾으면 된다. 어떻게 할 수 있을까 문제의 설정에 충실하게 모든 문자를 진짜 이차원 배열에 넣고 확인한다 : 굳이 안 해도 반복문으로 충분히 함 이중 반복문을 잘 써서 각 문자열을 세로로 읽게 하고, 아스키 코드 값이 증가하는지 확인한다. 더 자세한 계획 답으로 반환할 정수 변수를 준비한다. 개수를 세는 것이므로 0으로 초기화한다. 문자열은 어차피 배열로 주어지니 파싱할 필요가 없고, 배열의 총 크기와 개별 문자열의 길이를 찾아 반복문을 구성한다. 행 인덱스와 열 인덱스의 반복문 위치를 서로 바꾸어 세로로 읽게 하는 게 중요하다. 매 반복마다 이전 문자와의 비교를 해야 하므로 열 인덱스는 1부터 시작한다. 앞 문자와 아스키 코드 값을 비교해 지금 문자가 더 큰지 확인한다. 이전 문자보다 작은 경우가 발견되면 정답 변수를 1 증가시키고 다음 열로 넘어가게 한다(break). 이때 같은 열을 중복해서 세지 않아야 한다. 반복이 끝나면 정답 반환. 어떤 언어를 쓸까 : cpp나 파이썬이나 이번 문제에서는 비슷하게 쓸 수 있으니 못고르겠다. 둘 다 쓴다. 최소 런타임 샘플 답안 보기풀이1. 이중 반복문리뷰 내가 가장 먼저 생각해내는 풀이가 항상 그렇듯 흔하고 쉽게 생각할 수 있는 풀이였던 것 같다. 정답은 당연히 나오겠지만 속도와 메모리는 다른 답안에 비해 낮은 편. 파이썬은 메모리는 적은 편으로 나오긴 했지만 전체적으로 범위가 좁아 큰 의미는 없을 것으로 보인다. 근데 그럼 이걸 어떻게 빠르게 할 수 있는지? 뭘 써야 하는데? 일단 C++ 최소 런타임 답안을 봤는데 내 답이랑 크게 다른 건 없고 int() 유무만 달라서 그걸 빼고 다시 제출해봤는데, 런타임이 대략 1/3 정도로 줄었다. int() 연산이 생각보다 시간을 많이 쓰는 것 같다.C++ (1)Runtime : 127 ms, Beats 33.33%Memory : 12.3 MB, Beats 30.23%class Solution {public: int minDeletionSize(vector&lt;string&gt;&amp; strs) { int answer = 0; int row = strs.size(); int col = strs[0].length(); for (int i = 0; i &lt; col; i++) { for (int j = 1; j &lt; row; j++) { if (int(strs[j - 1][i]) &gt; int(strs[j][i])) { // 이 부분에서 int()를 빼고 쓰면 런타임이 49 ms로 줄어든다 ++answer; break; } } } return answer; }};python (1)Runtime : 596 ms, Beats 14.6%Memory : 14.5 MB, Beats 90.63%class Solution(object): def minDeletionSize(self, strs): \"\"\" :type strs: List[str] :rtype: int \"\"\" answer = 0 row = len(strs) col = len(strs[0]) for i in range(0, col): for j in range(1, row): if strs[j - 1][i] &gt; strs[j][i]: answer += 1 break return answer2. 최소 런타임 샘플 답안C++ (2)Runtime : 32 ms리뷰 내 답안과 크게 다르지 않다(풀이 생략). int()를 사용하지 않은 것과 앞에서 뒤로 비교한 것이 차이이다. 내가 int()를 사용하지 않고 낸 답안과 런타임이 17 ms 차이난다. 이 정도 차이는 그냥 때에 따라 달라지는 오차 정도인가?(몰라서 하는 말임)class Solution {public: int minDeletionSize(vector&lt;string&gt;&amp; strs) { int count = 0; int n = strs.size(), m = strs[0].size(); for(int i=0; i&lt;m; i++){ for(int j=0; j&lt;n-1; j++){ if(strs[j][i]&gt;strs[j+1][i]){ count++; break; } } } return count; }};python (2)몇 가지 배울 점이 있어서 풀이를 2개 가져왔다. 논리는 동일하니 한번에 풀이하겠다.풀이 문자열을 열 단위로 가져온다. 열 단위 문자열 그대로인 것과, 이를 정렬한 것을 비교해 서로 다르면 정답을 증가시킨다.첫 번째 예시Runtime : 71 ms리뷰 이 답안에서 볼 부분은 zip(*strs)이다. 참고 자료 [1]을 참고하여 무슨 코드인지 배워왔다. *이 붙은 strs가 iterable하다는 전제 하에, *을 붙여서 zip() 함수에 입력하면 *args로 전달되어 자동으로 열끼리 엮을 수 있다고 한다. *args는 가변 매개변수이다. 입력받을 값의 개수가 정해지지 않은 경우에 사용한다. 참고 자료 [1]에 의하면 튜플 형태로 전달된다고 한다.class Solution(object): def minDeletionSize(self, strs): \"\"\" :type strs: List[str] :rtype: int \"\"\" ret = 0 for c in zip(*strs): if list(c) != sorted(c): ret += 1 return ret두 번째 예시Runtime : 108 ms리뷰 이 답안은 첫 번째 답안보다 풀이를 이해하기가 쉬울 것 같아 가져왔다. 문자열을 열 단위로 가져오는 부분에서 리스트 컴프리헨션을 사용했고, 한 글자씩 비교하지 않고 정렬한 다음 한번에 비교했다.class Solution(object): def minDeletionSize(self, A): \"\"\" :type strs: List[str] :rtype: int \"\"\" res = 0 for i in range(len(A[0])): tmp = [ele[i] for ele in A] tmp_sort = sorted(tmp) if tmp !=tmp_sort: res+=1 return resC++과 python의 차이?cpp 풀이에서는 글자를 정렬하지 않고 하나씩 비교했지만, 파이썬 풀이에서는 글자를 정렬한 다음 통째로 비교했다. 왜 이렇게 다른 논리를 사용했을까? 분명 파이썬과 cpp의 실행 방식(컴파일러/인터프리터)이나 메모리 이용 방식의 차이에 따른 것으로 보이는데, 이걸 뭐라고 해야 할지는 모르겠다. chatGPT에게 물어봤지만 내가 원하는 대답은 듣지 못했다.내가 생각할 수 있는 건 cpp는 정렬하는 것보다 글자를 하나씩 읽는 게 더 빠르고, 파이썬은 하나씩 읽느니 다 가져와서 정렬하는 게 더 빠르다는 것뿐이다. 이건 표면적인 차이이고 내가 알고 싶은 건 왜 저런 차이가 생기는지이다.. 쉽지 않네.참고 자료 [1] [Python] zip함수와 파라미터 앞에 *, **는 어떤 의미인가?, https://juhee-maeng.tistory.com/113" }, { "title": "Unity vs Unreal Engine", "url": "/satinbower-legacy/posts/chatgpt-230103/", "categories": "chatGPT", "tags": "chatGPT, game engine, unity, unreal engine", "date": "2023-01-03 18:19:00 +0900", "snippet": "* 대화형으로 서술된 모든 정보의 출처는 chatGPT와의 대화이며, 각 대화의 원문을 더보기(원문 보기)로 넣었음.Table of Contents Unity vs Unreal Engine 참고Unity vs Unreal EngineQ. 유니티와 언리얼 엔진의 차이가 무엇인가?A. 유니티와 언리얼 엔진은 모두 비디오 게임을 만들 때 쓰는 인기있는 게임 엔진이다. 둘의 차이는 아래와 같다. 라이센스 : 유니티는 무료 개인 라이센스를 이용할 수 있는 반면 언리얼 엔진은 라이센스 비용이 청구된다. 프로그래밍 언어 : 유니티는 C#을 쓰고 언리얼 엔진은 C++을 쓴다. 지원되는 플랫폼 : 유니티는 iOS, 안드로이드, PC, 맥, 플레이스테이션, Xbox, 넨틴도 스위치 등 광범위한 플랫폼을 지원한다. 언리얼 엔진은 지원되는 플랫폼은 제한적이지만 PC와 콘솔 플랫폼에 더 나은 지원을 제공한다. 그래픽 : 언리얼 엔진은 그것의 질 높은 그래픽으로도 유명하고, 종종 더 시각적으로 까다로운 게임에 사용되기도 한다. 유니티도 질 높은 그래픽을 다룰 수 있긴 하지만 보통 간단한 그래픽에 더 적합하다. 쉬운 사용 : 일반적으로 유니티가 언리얼 엔진보다 사용자 친화적이고 배우기 쉽다. 언리얼 엔진은 더 가파른 성장 곡선을 갖는다(맥락상 난이도가 올라갈 때 더 확 올라간다는 뜻으로 보임). 비용 : 앞서 말했듯이, 유니티는 무료 개인 라이센스를 사용할 수 있는 반면 언리얼 엔진은 라이센스 비용이 청구된다. 그러나 언리얼 엔진은 분기당 최소 1,000달러의 수익을 창출할 수 있는 개발자들에게 로열티가 없는 라이선스를 제공한다. 원문 보기 Q. what's different between unity and unreal engine? A. Unity and Unreal Engine are both popular game engines that are used to develop video games. Here are some of the main differences between the two: License: Unity is available under a free personal license, while Unreal Engine charges a licensing fee. Programming language: Unity uses C# and Unreal Engine uses C++. Supported platforms: Unity supports a wider range of platforms, including iOS, Android, PC, Mac, PlayStation, Xbox, and Nintendo Switch. Unreal Engine has a more limited range of supported platforms, but it does offer better support for PC and console platforms. Graphics: Unreal Engine is known for its high-quality graphics and is often used in more visually demanding games. Unity is also capable of producing high-quality graphics, but it is generally more suited to simpler graphics. Ease of use: Unity is generally considered to be more user-friendly and easier to learn than Unreal Engine, which has a steeper learning curve. Cost: As mentioned earlier, Unity is available for free under a personal license, while Unreal Engine charges a licensing fee. However, Unreal Engine does offer a royalty-free license for developers who are able to generate at least $1,000 in revenue per quarter. 참고chatGPT는 완전히 최신 정보를 반영하지 못하는 만큼 제공된 정보에 잘못된 부분이 있을 수 있다. 언리얼 엔진의 라이센스 비용에 대해 공식 웹사이트와 다르게 서술된 부분이 있어 공식 웹사이트의 설명을 첨부한다.아래 자료의 출처는 언리얼 엔진 FAQ 페이지이다.언리얼 엔진의 가격은 얼마인가요?언리얼 엔진은 무료로 다운로드할 수 있습니다. 언리얼 엔진 사용 용도에 따른 라이선스 조건 옵션을 제공합니다.표준 EULA 조항에 따라 언리얼 엔진은 학습 또는 내부 프로젝트 개발에 무료로 사용할 수 있습니다. 또한 고객에게 전달할 커스텀 프로젝트, 단방향 콘텐츠(영화, TV 쇼 등), 수익이 없거나 로열티의 기준치 미만인 모든 제품을 포함하여 에픽게임즈에 비용을 지불하지 않고 상업용 프로젝트를 배포할 수 있습니다. 5%의 로열티는 게임과 같이 언리얼 엔진 코드가 통합된 규격화된 인터랙티브 제품을 배포하고 제품의 총 수익이 $1,000,000 USD를 초과하는 경우에만 부과됩니다. 이 경우, 첫 $1,000,000 USD까지는 로열티가 면제됩니다.기술 지원, 전담 교육, 그리고 로열티 무료, 조정 또는 다른 로열티 기준 등을 협상할 수 있는 맞춤형 라이선스 옵션도 있습니다. 게임 분야 또는 게임 외 산업분야를 위한 맞춤형 라이선스에 대한 자세한 정보는 별도로 문의해 주세요." }, { "title": "Native app, Hybrid app, etc", "url": "/satinbower-legacy/posts/chatgpt-230102/", "categories": "chatGPT", "tags": "chatGPT, mobile app", "date": "2023-01-02 18:50:00 +0900", "snippet": "Table of Contents* 모든 정보의 출처는 chatGPT와의 대화이며, 각 대화의 원문을 더보기(원문 보기)로 넣었음. 네이티브 앱과 웹 앱 네이티브 앱과 웹 앱의 차이 웹 앱도 기기 기능 접근 가능한가? 하이브리드 앱과 PWA 네이티브 앱과 웹 앱을 합친 것도 있나? 하이브리드 앱 PWA 하이브리드 앱과 PWA 비교 개발 사용자 경험 배포 유지보수 하이브리드 앱 만드는 방법 PWA 만드는 방법 첫 앱 개발 추천 처음 앱 개발을 시작하는 학생에게 추천 네이티브 앱이 하이브리드 앱보다 어려울까? 네이티브 앱과 웹 앱네이티브 앱과 웹 앱의 차이 네이티브 앱 안드로이드, iOS와 같은 특정 모바일 운영체제에 특화하여 개발된 모바일 앱 사용자의 기기에 다운로드 및 설치가 가능하며 오프라인으로 동작할 수 있다. 카메라나 GPS 같은 기기의 기능에 접근할 수 있고, 웹 앱에 비해 더 사용자 친화적이고 성능이 좋은 경험을 제공할 수 있다. 웹 앱 웹 브라우저에서 동작하는 앱 사용자의 기기에 다운로드 및 설치하는 것이 아니라 URL을 통해 접근한다. 동작하기 위해서는 인터넷에 연결되어 있어야 하며, 네이티브 앱처럼 기기의 기능에 접근할 수 없다. 웹 브라우저를 가지고 있다면 어떤 기기에서든 사용 가능하며, 이 점 때문에 휴대성이 향상되고 개발 및 유지보수가 용이하다. 원문 보기 Q. what's different between native app and web app? A. Native apps are mobile applications that are developed specifically for a particular mobile operating system, such as iOS for Apple devices or Android for devices that use the Android operating system. They are downloaded and installed on a user's device, and they can work offline. Native apps have access to the device's features and functions, such as the camera and GPS, and they can provide a more user-friendly and performant experience compared to web apps. Web apps, on the other hand, are applications that run in a web browser. They are not downloaded and installed on the user's device, but rather accessed through a URL. Web apps rely on internet connectivity to work and cannot access the device's features and functions in the same way that native apps can. However, they can be used on any device that has a web browser, which makes them more portable and easier to develop and maintain.웹 앱도 기기 기능 접근 가능한가?가능하다. getUserMedia API와 같은 웹 API를 통해 사용자의 카메라나 갤러리에 접근할 수 있다. 이 API는 웹 앱이 사용자에게 카메라/마이크 사용 권한을 요청하도록 하고, 해당 기기를 통해 비디오를 녹화하거나 음성을 녹음할 수 있게 한다.사용자의 갤러리에 접근하기 위해, 웹 앱은 File API를 이용해 사용자가 그들의 기기 저장소에서 파일을 고르도록 할 수 있다.사용자가 웹 앱이 그들의 카메라/갤러리에 접근할 수 있도록 허용해줘야만 한다는 것을 기억해야 한다. 웹 앱은 보통 이러한 기능에 처음으로 접근하고자 할 때 사용자에게 권한 허용 프롬프트를 띄운다. 원문 보기 Q. Can web app have access to user's camera or gallery? A. Yes, web apps can have access to the user's camera and/or photo gallery through the use of web APIs, such as the getUserMedia API. This API allows web apps to request access to the user's camera and/or microphone and to capture video and/or audio streams from these devices. To access the user's photo gallery, the web app can use the File API to allow the user to select a file from their device's storage. This can include photos and other types of files. Keep in mind that the user must grant permission for the web app to access their camera and/or photo gallery. The web app will typically prompt the user for permission when it first tries to access these features.하이브리드 앱과 PWA네이티브 앱과 웹 앱을 합친 것도 있나?있다. 네이티브 앱과 웹 앱을 합친 것은 몇 가지 종류가 있는데, 그 중 하나가 “하이브리드 앱”이고, 다른 하나는 “프로그레시브 웹 앱(PWA)”이다.두 가지 모두 더 나은 사용자 경험을 제공하고 사용자가 웹 기반 컨텐츠와 기능에 더 편하게 접근하도록 하는 것이 목적이다.하이브리드 앱하이브리드 앱은 (HTML, CSS, JavaScript와 같은) 웹 기술과 네이티브 코드의 조합으로 만들어진 모바일 앱이다. 이것은 네이티브 앱처럼 사용자의 기기에 설치할 수 있으나, 네이티브 컨테이너 내부에서는 웹 컨텐츠를 보여주는 웹 뷰를 사용한다.하이브리드 앱은 네이티브 앱과 웹 앱의 특징을 동시에 갖는다. 네이티브 앱처럼 기기의 기능에 접근할 수 있지만, 웹 앱처럼 웹 기술을 이용해 개발되었다. 그렇기 때문에 네이티브 앱보다 쉽고 빠르게 개발할 수 있고, 같은 코드 베이스로 다양한 플랫폼 버전의 앱을 만들 수 있다.PWAPWA는 네이티브 앱처럼 보이도록 디자인한 웹 앱이다. 이 앱은 최신 웹 기술을 사용하여 오프라인 지원 및 푸시 알림을 포함하여 사용자에게 앱 같은(app-like) 경험을 제공한다.PWA는 네이티브 앱처럼 사용자의 기기에 설치되지 않지만, 홈 화면에 추가되어 네이티브 앱처럼 실행될 수 있다. 웹 API를 통해 기기의 기능에도 접근할 수 있다. 원문 보기 Q. is there any type of app that combined native app and web app? A. Yes, there are several types of applications that combine elements of native apps and web apps. One example is a \"hybrid app.\" Hybrid apps are mobile applications that are built using a combination of web technologies (such as HTML, CSS, and JavaScript) and native code. They are installed on the user's device like a native app, but they run inside a native container that uses a web view to display web content. Hybrid apps have some of the characteristics of both native apps and web apps. They can access the device's native features and functions, like a native app, but they are developed using web technologies, like a web app. This can make them easier and faster to develop than native apps, as the same codebase can be used to build versions of the app for multiple platforms. Another example of a type of app that combines elements of native and web apps is a \"progressive web app\" (PWA). Progressive web apps are web applications that are designed to look and feel like native apps. They use modern web technologies to deliver an app-like experience to users, including offline support and push notifications. Progressive web apps are not installed on the user's device like native apps, but they can be added to the home screen and launched like a native app. They can also access some of the device's native features and functions through web APIs. Both hybrid apps and progressive web apps aim to provide a better user experience and a more convenient way for users to access web-based content and functionality.하이브리드 앱과 PWA 비교하이브리드 앱과 PWA 모두 네이티브 앱과 웹 앱의 요소를 결합했다는 점에서 비슷하지만 다음 사항들에 대해 차이가 있다. 둘 다 프로젝트의 특정 요구사항과 목표에 따라 장점과 절충점을 제공한다.개발 하이브리드 앱 HTML, CSS, JavaScript와 같은 웹 기술과 네이티브 코드를 조합해 만든다. .apk, .ipa와 같은 하나의 네이티브 앱 패키지로 컴파일되며 사용자의 기기에 설치할 수 있다. PWA 웹 기술만을 이용해 개발한다. 사용자의 기기에 설치할 필요가 없다. 사용자 경험 하이브리드 앱 네이티브 앱처럼 기기 기능에 접근할 수 있고, 네이티브 앱처럼 보이도록 디자인되어, 네이티브 앱과 비슷한 사용자 경험을 제공할 수 있다. PWA 서비스 작업자(service workers)와 웹 매니페스트 파일(web manifest files) 등의 최신 웹 기술을 이용해 앱 같은(app-like) 경험을 제공하는 것에 중점을 둔다. 홈 화면에 추가되어 네이티브 앱처럼 실행되지만, 하이브리드 앱과 같은 수준으로 기기의 기능에 접근할 수는 없다. 배포 하이브리드 앱 애플 앱 스토어, 구글 플레이와 같은 앱 스토어를 통해 배포되며, 사용자들이 사용할 수 있게 되기 전에 평가와 승인 과정을 거쳐야 한다. PWA 웹을 통해 배포되며, 앱 스토어와 평가 과정을 거칠 필요가 없다. 웹 브라우저의 URL을 통해 이용 가능하다. 유지보수 하이브리드 앱 각 플랫폼별로 분리된 코드 베이스가 필요하고, 각자 업데이트 및 유지보수를 해야 한다. PWA 하나의 코드 베이스로 웹 브라우저를 가진 어떤 기기든 접근할 수 있어 유지보수와 업데이트가 좀 더 쉽다. 원문 보기 Q. what's different hybrid app and progressive web app? A. Hybrid apps and progressive web apps (PWAs) are similar in that they both combine elements of native apps and web apps, but they differ in a few key ways: Development: Hybrid apps are developed using a combination of native code and web technologies, such as HTML, CSS, and JavaScript. They are compiled into a native app package, such as an .apk file for Android or an .ipa file for iOS, and installed on the user's device like a native app. PWAs, on the other hand, are developed using web technologies only and do not need to be installed on the user's device. User experience: Hybrid apps can provide a user experience that is similar to a native app, as they have access to the device's native features and functions and can be designed to look and feel like a native app. PWAs, on the other hand, aim to deliver an app-like experience through the use of modern web technologies, such as service workers and web manifest files. They can be added to the home screen and launched like a native app, but they may not have the same level of access to the device's native features and functions as a hybrid app. Distribution: Hybrid apps are distributed through app stores, such as the Apple App Store or Google Play, and must go through a review and approval process before they can be made available to users. PWAs, on the other hand, are distributed through the web and do not need to go through an app store review process. They can be accessed by users through a URL in a web browser. Maintenance: Hybrid apps require separate codebases for each platform (e.g., iOS, Android) and must be updated and maintained separately for each platform. PWAs, on the other hand, use a single codebase that can be accessed from any device with a web browser, which makes them easier to maintain and update. Both hybrid apps and PWAs offer advantages and trade-offs depending on the specific requirements and goals of a project.하이브리드 앱 만드는 방법chatGPT와 파파고 번역의 도움을 받았음.다음과 같은 방법으로 하이브리드 앱을 만들 수 있다. 웹 기술(HTML, CSS, JavaScript 등)을 사용하여 모바일 앱을 작성하고, 이것을 설치할 수 있는 네이티브 컨테이너로 감싸는 것이 공통적인 방법이다. 하이브리드 앱을 작성하기 위한 인기있는 프레임워크는 다음과 같다.프레임워크 고르기 Apache Cordova : Cordova는 HTML, CSS, JavaScript를 사용하여 하이브리드 앱을 작성할 수 있는 무료이자 오픈 소스 프레임워크이다. 이것은 카메라와 GPS와 같은 장치의 네이티브 기능에 앱이 접근할 수 있는 API 세트를 제공한다. Cordova는 앱을 Android의 .apk 파일이나 iOS의 .ipa 파일과 같은 네이티브 앱 패키지로 빌드하여 사용자의 장치에 설치할 수 있다. Ionic : Ionic은 웹 기술을 사용한 하이브리드 모바일 앱을 만들기 위한 무료 오픈 소스 프레임워크이다. Cordova를 기반으로 구축되어 있고, 고품질의 모바일 앱을 작성하기 위한 UI 컴포넌트와 도구 세트를 제공한다. Ionic은 모든 플랫폼에서 하나의 코드베이스를 사용하므로, 여러 플랫폼을 위한 앱을 개발하고 유지하기가 쉽다. React Native : 리액트 네이티브(React Native)는 리액트 자바스크립트 라이브러리를 사용하여 네이티브 모바일 앱을 구축하기 위한 프레임워크이다. 네이티브한 외관과 느낌을 가지고 기기의 네이티브 특징과 기능에 접근할 수 있는 앱을 만들 수 있다. React Native는 사용자의 장치에 설치할 수 있는 네이티브 앱 패키지로 앱을 컴파일한다.앱 만들기위의 프레임워크 중 하나를 사용하여 하이브리드 앱을 만들려면 다음이 필요하다. 코드 편집기, 모바일 개발 환경 및 프레임워크 자체와 같은 필수 도구 및 종속성을 설치한다. HTML, CSS, JavaScript를 사용하여 앱의 사용자 인터페이스와 기능을 설계하고 구현한다. 에뮬레이터 또는 물리적 장치에서 앱을 테스트하여 예상대로 작동하는지 확인한다. 프레임워크의 빌드 도구를 사용하여 앱을 네이티브 앱 패키지로 빌드한다. 필요에 따라 앱 스토어 또는 다른 채널을 통해 앱을 배포한다.하이브리드 앱을 구축하려면 웹 개발 기술과 사용 중인 특정 프레임워크에 어느 정도 익숙해야 한다. 이러한 도구와 기술을 사용하여 속도를 높이는 데에는 종종 학습 곡선이 포함된다(원문은 “There is often a learning curve involved in getting up to speed with these tools and techniques”. 대충 직접 해보면 빨리 배울 수 있다는 말 같음). 원문 보기 Q. how to make hybrid app? A. There are several ways to create a hybrid app, but one common approach is to use a framework that allows you to build a mobile app using web technologies (such as HTML, CSS, and JavaScript) and then wrap it in a native container that can be installed on a user's device. Some popular frameworks for building hybrid apps include: Apache Cordova: Cordova is a free and open-source framework that allows you to build hybrid apps using HTML, CSS, and JavaScript. It provides a set of APIs that allow your app to access the device's native features and functions, such as the camera and GPS. Cordova builds your app into a native app package, such as an .apk file for Android or an .ipa file for iOS, that can be installed on the user's device. Ionic: Ionic is a free and open-source framework for building hybrid mobile apps with web technologies. It is built on top of Cordova and provides a set of UI components and tools for building high-quality mobile apps. Ionic uses a single codebase for all platforms, which makes it easier to develop and maintain apps for multiple platforms. React Native: React Native is a framework for building native mobile apps using the React JavaScript library. It allows you to build apps that have a native look and feel and that can access the device's native features and functions. React Native compiles your app into a native app package that can be installed on the user's device. To create a hybrid app using one of these frameworks, you will need to: Install the required tools and dependencies, such as a code editor, a mobile development environment, and the framework itself. Design and implement the app's user interface and functionality using HTML, CSS, and JavaScript. Test the app on a emulator or a physical device to ensure it is functioning as expected. Build the app into a native app package using the framework's build tools. Distribute the app through app stores or other channels, as needed. Keep in mind that building a hybrid app requires some familiarity with web development technologies and the specific framework you are using. There is often a learning curve involved in getting up to speed with these tools and techniques.PWA 만드는 방법* 번역기 사용함.PWA는 네이티브 앱처럼 보이고 그런 느낌을 주며, 사용자에게 앱과 같은 경험을 제공하도록 설계된 웹 앱이다. 이러한 경험을 제공하기 위해 서비스 작업자(service workers)와 웹 매니페스트 파일(web manifest files)과 같은 현대적인 웹 기술이 사용된다.PWA를 만들려면 다음이 필요하다. HTML, CSS 및 JavaScript를 사용하여 웹 앱을 만든다. 기존 웹 앱일 수도 있고 처음부터 새로 만들 수도 있다. 안전한 연결을 위해 웹 앱이 HTTPS를 통해 제공되는지 확인해야 한다. 웹 앱에 서비스 작업자(service worker)를 추가한다. 서비스 작업자(service worker)는 백그라운드에서 실행되며 오프라인 지원 및 기타 앱과 같은 기능을 사용할 수 있는 스크립트이다. 웹 매니페스트 파일(web manifest file)을 만든다. 웹 매니페스트 파일(web manifest file)은 이름, 아이콘 및 테마 색상과 같은 PWA의 속성을 정의하는 JSON 파일이다. 브라우저의 개발자 도구 또는 Lighthouse와 같은 온라인 도구를 사용하여 PWA를 테스트하여 PWA 기준을 충족하는지 확인한다. PWA를 웹 서버에 배포하고 URL을 통해 사용자가 사용할 수 있도록 한다.PWA를 구축하려면 웹 개발 기술과 PWA를 만드는 데 사용되는 특정 도구 및 API에 어느 정도 익숙해야 한다. 이러한 기술로 속도를 내는 데에는 학습 곡선이 관련되어 있을 수 있다(There may be a learning curve involved in getting up to speed with these technologies).또한 모든 브라우저가 PWA에 필요한 모든 기능을 지원하는 것은 아니므로 다양한 브라우저와 장치에서 PWA가 예상대로 작동하는지 확인하는 것이 중요하다. 원문 보기 Q. how to make progressive web app? A. Progressive web apps (PWAs) are web applications that are designed to look and feel like native apps and to provide an app-like experience to users. They use modern web technologies, such as service workers and web manifest files, to deliver this experience. To create a progressive web app, you will need to: Create a web application using HTML, CSS, and JavaScript. This can be an existing web app or a new one that you are building from scratch. Make sure the web app is served over HTTPS to ensure a secure connection. Add a service worker to the web app. A service worker is a script that runs in the background and enables offline support and other app-like features. Create a web manifest file. A web manifest is a JSON file that defines the properties of the PWA, such as its name, icons, and theme color. Test the PWA using a browser's developer tools or online tools, such as Lighthouse, to ensure it meets the criteria for a PWA. Deploy the PWA to a web server and make it available to users through a URL. Keep in mind that building a PWA requires some familiarity with web development technologies and the specific tools and APIs used to create a PWA. There may be a learning curve involved in getting up to speed with these technologies. It is also important to note that not all browsers support all of the features required for a PWA, so it is important to test the PWA on a variety of browsers and devices to ensure it works as expected.첫 앱 개발 추천* 번역기 사용함.처음 앱 개발을 시작하는 학생에게 추천그것은 앱의 구체적인 목표와 목적, 그리고 학생들이 이용할 수 있는 자원과 기술에 달려 있다. 다음은 빌드할 앱 유형을 결정할 때 고려해야 할 몇 가지 요소이다. 시간 및 리소스 : 네이티브 앱을 구축하려면 전문적인 기술과 도구가 필요하기 때문에 복잡하고 시간이 많이 소요될 수 있다. 시간과 자원이 제한된 학생이 더 친숙하고 배우기 쉬운 웹 기술을 사용하여 구축할 수 있는 웹 앱이나 하이브리드 앱으로 시작하는 것이 더 실현 가능할 수 있다. 앱 기능 : 네이티브 앱은 기기의 모든 기능에 액세스할 수 있어 많은 하드웨어 통합이 필요하거나 오프라인에서 작동해야 할 경우 유용할 수 있다. 웹 앱과 하이브리드 앱은 기기의 특징과 기능에 대한 접근이 더 제한적이지만 여전히 많은 기능을 제공할 수 있으며 인터넷 연결에 주로 의존하는 앱에 좋은 선택이 될 수 있다. 대상 고객 : 네이티브 앱은 일반적으로 단일 플랫폼(예: iOS 또는 안드로이드)에서만 사용할 수 있기 때문에 앱이 광범위한 사용자를 대상으로 하는 경우 각 플랫폼에 대해 별도의 버전을 구축해야 할 수도 있다. 웹 앱과 하이브리드 앱은 웹 브라우저가 있는 모든 장치에서 액세스할 수 있으므로 휴대성이 향상되고 배포가 더 쉬워진다.궁극적으로, 학생들이 만들기에 가장 좋은 유형의 앱은 그들의 목표, 자원, 그리고 기술에 달려 있다. 웹 앱이나 하이브리드 앱과 같은 더 간단한 프로젝트로 시작한 다음, 기술과 경험이 성장함에 따라 더 복잡한 프로젝트로 진행하는 것이 학생에게 도움이 될 수 있다. 원문 보기 Q. In all types of app, what will you recommend for student who makes an app first time? A. It depends on the specific goals and objectives of the app, as well as the resources and skills available to the student. Here are a few factors to consider when deciding which type of app to build: Time and resources: Building a native app can be a complex and time-consuming process, as it requires specialized skills and tools. It may be more feasible for a student with limited time and resources to start with a web app or a hybrid app, which can be built using web technologies that are more familiar and easier to learn. App functionality: Native apps have access to the full range of the device's features and functions, which can be useful if the app requires a lot of hardware integration or needs to work offline. Web apps and hybrid apps have more limited access to the device's features and functions, but they can still provide a lot of functionality and can be a good choice for apps that rely mostly on internet connectivity. Target audience: Native apps are typically only available on a single platform (e.g., iOS or Android), so if the app is intended for a broad audience, it may be necessary to build separate versions for each platform. Web apps and hybrid apps can be accessed from any device with a web browser, which makes them more portable and easier to distribute. Ultimately, the best type of app for a student to build will depend on their goals, resources, and skills. It may be helpful for the student to start with a simpler project, such as a web app or a hybrid app, and then progress to more complex projects as their skills and experience grow.네이티브 앱이 하이브리드 앱보다 어려울까?네이티브 앱을 구축하는 것은 하이브리드 앱을 구축하는 것보다 더 복잡하고 시간이 많이 소요될 수 있으며, 특히 앱 개발에 처음인 학생에게는 더욱 그렇다. 이는 네이티브 앱이 플랫폼별 프로그래밍 언어와 도구를 사용하여 개발되고, 기본 하드웨어와 소프트웨어 플랫폼에 대한 더 깊은 이해가 필요하기 때문이다.반면, 하이브리드 앱은 웹 기술(HTML, CSS, 자바스크립트 등)을 사용하여 구축되며 사용자의 기기에 설치할 수 있는 네이티브 컨테이너에 싸여 있다. 이를 통해 익숙한 웹 기술을 사용하여 개발할 수 있으며 특히 웹 개발 경험이 있는 학생들이 쉽고 빠르게 만들 수 있다.즉, 모든 유형의 성공적인 앱을 구축하려면 기본 기술에 대한 확실한 이해와 잘 설계된 계획이 필요하다. 학생들은 어떤 종류의 앱을 만들 것인지 결정할 때 목표와 자원을 신중하게 고려하고 필요에 따라 적절한 학습 자원과 지침을 찾는 것이 중요하다. 원문 보기 Q. Is native app more difficult than hybrid app to student? A. Building a native app can be more complex and time-consuming than building a hybrid app, especially for a student who is new to app development. This is because native apps are developed using platform-specific programming languages and tools, and they require a deeper understanding of the underlying hardware and software platforms. Hybrid apps, on the other hand, are built using web technologies (such as HTML, CSS, and JavaScript) and are wrapped in a native container that can be installed on the user's device. This allows them to be developed using familiar web technologies and can make them easier and faster to build, especially for students who already have some experience with web development. That being said, building a successful app of any type requires a solid understanding of the underlying technologies and a well-designed plan. It is important for students to carefully consider their goals and resources when deciding which type of app to build and to seek out appropriate learning resources and guidance as needed." }, { "title": "[LeetCode][py] 290. Word Pattern", "url": "/satinbower-legacy/posts/it-leetcode-230101/", "categories": "IT, 문제풀이", "tags": "지식, IT, LeetCode, 릿코드, 문제풀이, Hash Table", "date": "2023-01-01 17:29:00 +0900", "snippet": "Table of Contents 문제 예제 Example 1 Example 2 Example 3 계획 풀이 1. 키와 값을 반대로 저장한 두 딕셔너리 2. 최소 런타임 샘플 답안 참고 자료문제원문 보기 : [LeetCode] 290. Word Patternpattern과 문자열 s가 주어진다. s가 같은 패턴을 따르는지 확인하라.따른다는 말은 pattern의 글자와 s에 존재하는 비어있지 않은 단어가 일대일 대응이 되는 것과 같은, 완전한 매치를 의미한다.조건(Constraints): 1 &lt;= pattern.length &lt;= 300 pattern에는 영어 소문자만 있다. 1 &lt;= s.length &lt;= 3000 s에는 영어 소문자와 공백(' ')만 있다. s의 앞뒤에 남는 공백은 없다. s에 있는 모든 단어는 하나의 공백으로 구분된다.예제Example 1Input: pattern = “abba”, s = “dog cat cat dog”Output: trueExample 2Input: pattern = “abba”, s = “dog cat cat fish”Output: falseExample 3Input: pattern = “aaaa”, s = “dog cat cat dog”Output: false계획 상황 파악 패턴에 있는 글자와 문자열에 있는 단어가 딱 맞으면 된다. 글자마다 연결 리스트처럼 집합을 달아서 문자열에 있는 모든 단어를 나누어 넣고, 마지막에 단어가 하나씩만 남아있는지 확인하면 되지 않을까? 파싱은 귀찮으니 파이썬을 써서 해보겠다. 물론 당연히 입력이 커지면 시간초과가 걸릴 것 같지만 일단 틀려보고 생각하기로 했다. 첫 번째 시도 문자와 리스트를 각각 키와 값으로 갖는 딕셔너리를 만들고자 했으나, 딕셔너리에 키가 없는 경우 키를 추가하는 것이 먼저이기 때문에 단순히 append만 쓸 수는 없었다. 여기서 몇 가지 선택지가 있다. 각 선택지 모두 마지막에는 각 알파벳마다 1개의 단어만 남는지 확인하면 된다. 하나라도 그렇지 않은 것이 있다면 False를 반환한다. 딕셔너리를 유지하고, 키가 있는지 확인하는 선택문을 추가해 오류를 발생시키지 않는 것. 패턴에 있는 알파벳의 종류 수만큼 이차원 리스트를 만들어 각 알파벳을 인덱스 삼아 단어를 리스트에 추가 후 set() 적용해 확인 패턴에 있는 알파벳을 이용해 먼저 알파벳 키와 빈 집합을 값으로 갖는 딕셔너리를 만들고 단어를 추가 두 번째 시도 2번에서 3번째 선택지로 간다. 어차피 집합으로 만들면 다른 값이 추가될 때 크기가 2로 늘어나니까 단어를 추가하는 과정에서 개수도 같이 검사하고 False를 반환하게 했다. 예상치 못한 반례에서 틀림 패턴은 서로 다른 알파벳이 2개 이상 나왔는데, 단어는 딱 한 종류만 나오는 경우 True를 반환해서 틀린다. 서로 다른 패턴의 단어가 서로 다른지 확인하지 않았다. 다시 생각을 해보자. 이미 쓴 방식을 유지하고, 마지막에 확인 과정을 추가한다. &lt;br&gt; 틀린 건 아닌데 내가 보기엔 비효율적이다. 이런 상황에 더 어울리는 구조가 있는 게 맞지 않을까? 딕셔너리의 구성을 바꿔서 패턴 알파벳 하나당 단어 하나씩 매치시키고, 중복된 단어나 알파벳이 나오면 일치하는지 확인한다. 앞서 걸린 반례를 통과하기 위해 키와 값이 서로 반대인 딕셔너리로 총 2개 만들자. 패턴의 알파벳 수와 단어의 개수가 같다는 조건은 없었지. 또 틀림 이건 간단하게 걸러낼 수 있어. 모든 과정을 시작하기 전 패턴의 길이와 단어의 총 수가 같은지 확인하면 돼. 이게 되네? 게다가 꽤나 상위 런타임과 메모리로 들어갔다. 런타임이 가장 짧은 답안만 참고해보고, C++로 쓸 때는 어떻게 쓰면 좋을지 생각이나 해보자. 일단 내 답은 제쳐두고 최소 런타임 샘플 답안 봤는데, 딕셔너리 이름을 map이라고 지었더라. 그거 보니까 약간 감은 왔어. 다른 언어로 쓸 때도 map을 쓰면 되는거지? 순서가 중요한 상황이 아니니까 unordered_map 쓰면 더 빠르겠다. 그리고 나랑 비슷하게 딕셔너리를 2개 썼는데, 하나는 패턴 알파벳과 단어를 매치했고 다른 하나는 단어의 등장 여부만 체크해둔 것 같더라. 자세한 건 밑에서 더 보자고요.풀이1. 키와 값을 반대로 저장한 두 딕셔너리Runtime : 14 msMemory : 13.3 MB리뷰 파이썬의 딕셔너리는 해시로 구현되어 있다 [1]. 새로 배웠다! 파이썬이라 느릴 줄 알았는데 의외로 빨랐던 이유가 딕셔너리의 구현이 해시라서 그런 것 같다. 계획을 먼저 하는 습관을 좀 더 들입시다 학생. 오늘도 냅다 코드부터 쓰다가 반례 보고 고쳤잖아. 이거 쓰면 되겠지? 하고 바로 달려들지 말고 좀 더 자세히 생각해보란 말이지. 부족한 점 : 서로 반대되는 두 딕셔너리를 한번에 확인할 수 있는 방법이 생각나지 않았다, 라기 보다는 일단 문제가 풀리는 데에 만족해서 거기까지 가지 않고 생각을 놓아버렸다. 대신 보고 배웠습니다.class Solution(object): def wordPattern(self, pattern, s): \"\"\" :type pattern: str :type s: str :rtype: bool \"\"\" words = s.split(' ') # 단어 파싱 if len(pattern) != len(words): # 단어 개수와 패턴 길이 다르면 안 됨 return False matchs = {} # 패턴 사전 : 키 - 패턴, 값 - 단어 match_reverse = {} # 단어 사전 : 키 - 단어, 값 - 패턴 for c, word in zip(pattern, words): # 대응되는 패턴과 단어의 쌍 반복 if c in matchs: # 패턴 사전에 패턴이 존재하는데 if matchs[c] != word: # 단어가 다르면 안 됨 return False else: # 없다면 추가 matchs[c] = word if word in match_reverse: # 단어 사전에 단어가 존재하는데 if match_reverse[word] != c: # 패턴이 다르면 안 됨 return False else: # 없다면 추가 match_reverse[word] = c return True # 다 통과하면 됨2. 최소 런타임 샘플 답안Runtime : 3 ms풀이 단어의 수와 패턴의 길이가 같은지 확인하고, 다르면 False 반환. 2개의 딕셔너리를 만든다. 하나는 (키, 값)으로 (패턴, 단어)를 저장하고, 다른 하나는 (단어, True)를 저장한다. 이때 두 번째 딕셔너리는 단어의 등장 여부만을 확인하기 위함이니 값은 꼭 True가 아니어도 된다. 이후 패턴의 길이만큼 반복한다. 현재 패턴이 아직 등장하지 않은 새 패턴일 경우 이 패턴에 대응하는 단어가 이미 등장한 단어라면 False 반환. 단어도 등장하지 않은 것이라면 두 사전에 각각 추가한다. 이미 등장한 패턴인데 대응되는 단어가 다른 경우 : False 반환. 반복이 끝나면 True 반환.내 답안과 비교 2개의 딕셔너리를 사용함 서로 반대되는 키와 값을 저장해 패턴과 단어의 대응을 2번 확인 : 패턴은 다른데 대응되는 단어가 같은 반례를 거르기 위함이었으나, 2개의 딕셔너리를 각각 확인해야 한다. 패턴과 단어의 조합은 한번씩만 저장하고, 단어의 등장 여부를 추가로 저장 : 등장하지 않은 새 패턴을 확인할 때는 두 딕셔너리를 이용해 확인하지만 이미 등장한 패턴을 확인할 때는 하나만 확인해도 되며, 이 과정이 한 블록의 선택문 안에서 해결 가능하다. class Solution(object): def wordPattern(self, pattern, s): \"\"\" :type pattern: str :type s: str :rtype: bool \"\"\" words = s.split() n = len(pattern) if len(words) != n: return False map = dict() map2 = dict() for i in range(n): if map.get(pattern[i]) is None: if map2.get(words[i]) is not None: return False map[pattern[i]] = words[i] map2[words[i]] = True elif map.get(pattern[i]) != words[i]: return False return True 참고 자료 [1] 파이썬의 딕셔너리는 어떻게 구현되어 있을까? -해시-, https://fierycoding.tistory.com/68" }, { "title": "[LeetCode][c++] 1. Two Sum", "url": "/satinbower-legacy/posts/it-leetcode-221230/", "categories": "IT, 문제풀이", "tags": "지식, IT, LeetCode, 릿코드, 문제풀이, 배열, Two Pointers, Hash Table", "date": "2022-12-30 19:15:00 +0900", "snippet": "Table of Contents 문제 예제 Example 1 Example 2 Example 3 계획 풀이 1. 투 포인터 2. unodered_map 문제원문 보기 : [LeetCode] 1. Two Sum정수 배열 nums와 정수 target이 주어진다. 더해서 target이 되는 두 숫자의 인덱스를 반환하면 된다.모든 입력은 정확히 하나의 답만을 가지며, 같은 원소를 중복 사용하지 않는다.정답의 순서는 상관 없다.조건(Constraints):2 &lt;= nums.length &lt;= 104-109 &lt;= nums[i] &lt;= 109-109 &lt;= target &lt;= 109Only one valid answer exists.예제Example 1Input: nums = [2,7,11,15], target = 9Output: [0,1]Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].Example 2Input: nums = [3,2,4], target = 6Output: [1,2]Example 3Input: nums = [3,3], target = 6Output: [0,1]계획 내가 이해한 것 중복하지 않게 2개를 뽑아 더해서 원하는 숫자가 나오면 된다. 투 포인터로 탐색하면 되는 거 아냐? 실행과 결과 투 포인터를 사용하는 코드로 제출해서 바로 통과했으나, 내 코드의 실행 시간이 상위 50%도 안 나오고 대부분 답안이 훨씬 상위에 몰려 있는 게 수상했음. 문제 태그 확인 나는 당연히 투 포인터가 있지 않을까 생각했는데, 예상외로 투 포인터는 없고 해시 테이블이 있었다. 이게 왜 있어? 상위 답안 참고 실행 시간 기준 최상위 답안 몇 개를 봤다. 인덱스를 잘 이용해서 투 포인터를 사용한 코드는 서로 반대 방향으로 동시에 비교한 것 같다는 어렴풋한 이해는 가능했지만 그래서 정확히 뭘 하고, 어째서 그렇게 빨리 나오는지는 이해하지 못했다. 해시 테이블과의 연관성도 모르겠다.(map 컨테이너는 알지만 해시 테이블이라는 자료구조의 이론을 아는 건 아님) 다른 답안을 찾아보니 unordered_map을 사용한 답이 있었다. 게다가 주석도 자세했다. 좋은 참고가 되었다. 배열의 앞에서부터 순회하며 map에 값을 넣는데, target과 현재 탐색중인 수의 차이를 key로 만들어 map에 그 값이 존재하는지 확인하고, 존재한다면 바로 답으로 반환하고 그렇지 않다면 map에 값과 인덱스를 추가한다. map이 내부적으로 트리를 이용한다는 건 알고 있었는데, unodered_map은 이번에 처음 봐서 자료구조를 찾아보니 해시 테이블로 구현된다고 한다. 그래서 태그가 해시 테이블이었다..풀이1. 투 포인터Runtime : 360 msMemory : 10.2 MB리뷰 처음엔 답안 벡터를 만들고, 답을 찾았는지 표시하는 bool 변수를 만들어서 반복문을 모두 빠져나간 다음 답안을 반환하게 했는데, 다른 답안을 참고해보니 꼭 그렇게 할 필요가 없어서 반복문 중간에 바로 답안을 반환하게 고쳤다. 반복문 바깥의 답안 반환 부분에서 다른 것 없이 {}만 써서 제출해도 통과가 되는 것 같던데, 메소드의 반환 형식이 vector&lt;int&gt;로 정해져 있어서 가능한 것 같다. 마찬가지로 반복문 내부 답안도 {i, j}로 바로 반환할 수 있는데, 이번에는 내가 알아볼 수 있게 써두려고 그렇게 쓰지 않았다. 다음에는 참고해서 쓸 수 있을지도? 어차피 O(n2)이지만 적어도 조금이라도 시간을 줄여보려고 i와 j가 겹치지 않게 반복문을 썼다. 물론 큰 의미는 없을 것이다..class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { int len = nums.size(); for (int i = 0; i &lt; len - 1; i++) { for (int j = i + 1; j &lt; len; j++) { if (nums[i] + nums[j] == target) { return vector&lt;int&gt;{i, j}; } } } return vector&lt;int&gt;{}; }};2. unodered_map* 샘플 답안 중에 본 건데, 이 답안의 원본 링크를 알 수가 없어 출처는 표기하지 못했다.Runtime : 7 ms리뷰 unordered_map의 존재를 처음 알았다. map은 Red-Black Tree로, unordered_map은 Hash Table로 구현된다고 한다. (적어도 이 문제에 한해서는) 투 포인터 탐색과 같은 답을 낼 수 있으면서도 훨씬 빠른 풀이 방법을 배웠다. 알고리즘은 나날이 새롭다..풀이 unordered_map을 준비하고, 하나의 반복문으로 주어진 배열을 앞에서부터 순회한다. 목표하는 값과 현재 검사하는 수의 차를 구한다. 이를 toFind라 한다. toFind가 맵에 있는지, 그리고 toFind의 인덱스가 현재 검사하는 수와 다른지 확인한다. 만약 2번을 통과했다면 toFind의 인덱스와 현재 검사하는 수의 조합이 답이다. 바로 반환한다. 2번을 통과하지 못했다면 답이 아니고, 현재 검사한 수를 맵에 추가한다. 반복문이 끝나면 답을 찾지 못한 것이므로 빈 벡터를 반환한다.class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { // Result vector to hold \"Two Sum\" equals to \"Target\" vector&lt;int&gt; result; // We need to return the \"index\" of the \"Two Nums\" results in \"Target\" unordered_map&lt;int,int&gt; indexMap; // Cannot have the \"auto\" iterator variable, since we are interested in \"index\", not the actual value. for (int i = 0; i &lt; nums.size(); i++) { // Check if the \"target-current\" value already exist in the IndexMap. int toFind = target - nums[i]; if (indexMap.find(toFind) != indexMap.end() &amp;&amp; // \"IndexMap\" has the entry i != indexMap[toFind]) { // AND we are not working on the same index /* Another corner use-case: Target-10, Current-5 toFind-5 */ result.push_back(i); result.push_back(indexMap[toFind]); return result; } indexMap[nums[i]] = i; } // Return empty vector if there is NO \"Two Sum\" equal to \"Target\" return {}; }};" }, { "title": "22.12.30 크롤링을 할 때는 IP 차단에 주의하자", "url": "/satinbower-legacy/posts/daily-221230/", "categories": "IT, 기타", "tags": "지식, IT, 크롤링, Robots_txt", "date": "2022-12-30 17:53:00 +0900", "snippet": "상황 설명연구 목적으로 ACM이라는 사이트에서 논문 정보를 크롤링하다가 IP를 차단당했다. 이후 이 사이트의 IP 차단에 대해 찾아보니 서버에 과도한 요청을 보내면 IP가 차단될 수 있으니 크롤링에 주의해야 한다는 것을 알게 되었다. 그제서야 Robots.txt의 존재가 기억났고.. 크롤링 딜레이가 60으로 적혀 있는 것을 확인했다.차단 사유원래 이 사이트를 크롤링하는 데 쓰던 코드가 있었는데, 그 코드는 사이트의 api를 이용해서 제대로 요청을 보내고 데이터를 받는 코드였으나 내가 이해하기 좀 어려웠다. 그래서 bs4 코드를 셀레늄의 방식으로 써서 돌려봤는데, 문제는 단시간에 너무 많은 페이지를 방문한 것. 과도한 요청 때문에 차단된 것으로 짐작하고 있다.해결파파고와 chatGPT의 도움을 받아 문의 이메일에 내 상황과 여러가지 말을 쓰고 차단 해제를 요청했다. 오늘 이메일을 보냈으니 며칠 정도는 기다려야 답이 올 것 같다. 그동안 다른 사이트를 크롤링하면 되긴 하는데, 차단 안 당하게 주의할 겁니다..반성특정 웹사이트에서 대량의 데이터가 필요하다면 내가 의도치 않은 DDOS를 시도하게 되지는 않을지 생각해보고, Robots.txt도 확인해 보자.. API가 있다면 어려워도 배워서 쓰자." }, { "title": "[Latin] 듀오링고 라틴어 Unit 1", "url": "/satinbower-legacy/posts/lang-ratin-221230/", "categories": "Language, Latin", "tags": "지식, Language, Latin, 듀오링고", "date": "2022-12-30 14:55:00 +0900", "snippet": "Table of Contents word 사람/인칭 기초 단어 서술어/의문사 sentence 어순word* 단어의 뜻과 문법은 chatGPT의 도움을 받았음사람/인칭 Latin English Memo Latin English Memo ego I   mihi my   tu you   tibi your   is he 영어 is랑 매번 헷갈림 ei his   ea she         vir man   femina woman   puer boy   puella girl   mater mother   pater father   soror sister   frater brother   기초 단어 Latin English Memo Latin English Memo non not   sed but   nomen name   et and   salve hello, hi 1명에게 인사 salvete hello, hi 여러 명에게 인사 bene well, good   male bad, poorly   ita yes   minime no   scribit write   studet study   domi at home   in urbe in city   Romae in Rome         서술어/의문사 Latin English Memo sum ‘I am’ or ‘I exist’ 1인칭 be es you are 2인칭 단수 be est he/she/it is 3인칭 단수 be       quis who/what ask about identity quid what ask about identity or nature of a thing quid agit how is 안부 물을 때 ubi where   quomodo how, how’s, or ‘in what way?’ 상태 물을 때, ask about method       habeo ‘to have’ or ‘to hold’, ‘feel’ 기본형, 1인칭(me) habes you have, feel 2인칭 단수(te) habet he/she/it has, feel 3인칭(se)       habito  to inhabit or dwell in 기본형 habitasne do you live 의문형 habitas (you) live 2인칭에 사용 habitatis habitation or dwelling place 속격(소유/연관) 단수형 명사 sentence 평서 A는 B이다/아니다 Marcus non est femina : Marcus is not a woman. Stephanus est vir : Stephanus is a man. Is est pater : He is a father. Tu es puer : You are a boy. Ego sum Corinna : I am Corinna. Ea est puella : She is a girl. Nomen mihi est Marcus. : My name is Marcus. Nomen tibi est Corinna : Your name is Corinna. Nomen ei est Stephanus. : His name is Stephanus. 누가 무엇을 한다 / 어디에 있다 / 어떻다 Femina studet et scribit : The woman studies and writes. Ego domi sum : I am at home. Me male habeo., Male me habeo : I feel poorly. Me bene habeo. : I am well. Livia se male habet. : Livia feels poorly. Romae habito. : I live in Rome. Ita, ego in urbe habito. : Yes, I live in the city. Roma est in Italia. : Rome is in Italy. Minime, in Italia non habito. : No, I do not live in Italy. In Italia habitatis. : You live in Italy. 의문 동사/형용사 서술어 Habitasne in urbe? : Do you live in the city? Habitasne Romae? : Do you live in Rome? 의문사 Quis est in urbe? : Who is in the city? Quid agit Livia? : How is Livia? Quid est mihi nomen? : What is my name? Quid est ei nomen? : What is his name? Quid tibi est nomen? : What is your name? Salve, quid tibi est nomen? : Hello, what is your name? Quomodo Corinna se habet? : How is Corinna doing? Quomodo femina se habet? : How does the woman feel? Quomodo te habes? : How are you doing? Livia, quomodo tu te habes? : Livia, how are you doing? Ubi est Italia? : Where is Italy? Quid habet Marcus? : What does Marcus have? Ubi tu habitas? : Where do you live? 어순* 듀오링고는 문법을 안 가르쳐줘서 예문을 보고 추측함아무거나 생략하고 말하는 게 제일 어려움.. 평서 : 일단 서술어가 웬만하면 뒤에 나옴 누가 - (누구의) - (어디에서) - (non) be 서술어 - (누구인지) (누가) - (어디에서) - ~하다 (누가) - 어떻다 + 인칭별 서술어 (주어 생략) 수식(어디) - 서술어 의문 : 의문사가 앞에 나오든가, 서술어가 앞에 나옴 누구/무엇 - [tibi] - be 서술어 - [ei, mihi] - 묻고 싶은 것 어떻게(how) - (누구) - 인칭별 서술어 (주어 생략) 서술어 - 수식(어디) " }, { "title": "[LeetCode][c++] 1962. Remove Stones to Minimize the Total", "url": "/satinbower-legacy/posts/it-leetcode-221228/", "categories": "IT, 문제풀이", "tags": "지식, IT, LeetCode, 문제풀이, Array, Heap, Priority Queue", "date": "2022-12-28 19:14:00 +0900", "snippet": "Table of Contents 문제 예제 Example 1 Example 2 계획 풀이 1. 배열과 최댓값 2. 우선순위 큐 참고 자료문제원문 보기 : [LeetCode] 1962. Remove Stones to Minimize the Total0부터 인덱스가 시작하는 배열 piles와 k가 주어진다. piles[i]는 i번째 돌무더기의 돌 개수를 의미한다. 이제 다음 연산을 정확히 k번 수행해야 한다. 어떤 돌무더기 piles[i]를 골라 floor(piles[i] / 2) 만큼 돌을 뺀다.같은 돌무더기에 대해 여러 번 연산을 수행할 수 있다.k번의 연산 후 남은 돌무더기의 합이 최소가 되게 만들면 된다.floor(x)는 x보다 작거나 같은 것 중 가장 큰 정수를 의미한다.(내림 연산과 같음)조건(Constraints):1 &lt;= piles.length &lt;= 1051 &lt;= piles[i] &lt;= 1041 &lt;= k &lt;= 105예제Example 1Input: piles = [5,4,9], k = 2Output: 12Explanation: Steps of a possible scenario are: Apply the operation on pile 2. The resulting piles are [5,4,5]. Apply the operation on pile 0. The resulting piles are [3,4,5].The total number of stones in [3,4,5] is 12.Example 2Input: piles = [4,3,6,7], k = 3Output: 12Explanation: Steps of a possible scenario are: Apply the operation on pile 2. The resulting piles are [4,3,3,7]. Apply the operation on pile 3. The resulting piles are [4,3,3,4]. Apply the operation on pile 0. The resulting piles are [2,3,3,4].The total number of stones in [2,3,3,4] is 12.계획 내가 이해한 것 매 반복마다 배열에서 가장 큰 수를 찾아서 반토막내면 된다. 고로 매번 가장 큰 수를 찾아내면 된다. 약간의 사고가 있었음 블로그에 올릴 글을 쓰면서 문제를 풀려고 태그를 봤다가 힙을 쓰면 된다는 것을 스포일러당했다. 최댓값을 일일이 찾을 생각만 했지 힙을 쓸 생각은 전혀 못하고 있었다. 타협 내가 스포일러를 당했든 그렇지 않았든, 처음에는 분명 배열에서 일일이 최댓값을 찾는 방법을 시도했을테니 먼저 한번 틀려보고 힙을 사용하자. 직접 만든 힙 말고 STL 우선순위 큐 쓸 생각이다. 계획 (1) : 배열을 이용해 매번 최댓값을 찾아 연산한다. (2) : 우선순위 큐를 이용해 최대힙을 만들고 지정된 횟수만큼 pop한다.풀이1. 배열과 최댓값결과 : 시간초과풀이 방식 : 매 연산마다 최댓값을 직접 찾는다.class Solution {public: int minStoneSum(vector&lt;int&gt;&amp; piles, int k) { int total = 0; // 총합 for (int i = 0; i &lt; k; i++) { // 돌무더기 덜어내기 연산 int max_idx = max_index(piles); piles[max_idx] -= piles[max_idx] / 2; } for (int&amp; n : piles) // 총합 구하기 total += n; return total; } int max_index(vector&lt;int&gt;&amp; piles) { // 배열 내에서 최댓값 찾기 int idx = 0; for (int i = 1; i &lt; piles.size(); i++) { if (piles[i] &gt; piles[idx]) idx = i; } return idx; }};2. 우선순위 큐Runtime : 755 msMemory : 98.7 MB리뷰 자료구조 이론만 배웠지 써먹을 줄은 하나도 모르고 있다(제일 중요함). 매번 최댓값이 필요한데 정렬은 아냐? 그럼 당연히 적어도 최댓값만은 보장되는 자료구조를 생각해 봐야지 매번 최댓값 찾기가 뭡니까 학생. 그나마 그 방법이 당연히 시간초과로 틀릴 거라는 예상은 할 줄 아니 됐습니다. greater&lt;int&gt;는 오름차순 정렬에 쓴다. priority_queue 기본값은 내림차순. 이걸 헷갈려서 한 번 틀렸다(예제 틀려서 기록은 안 남음). 벡터로 큐 초기화하는 방법은 덤이다. 처음 주어진 배열의 순서를 그대로 유지하지 않아도 풀이가 가능했다. 배열을 큐에 모두 넣고 이후로 큐에 있는 값만 사용하면서 배열의 원형이 완전히 사라지는데, 해답의 조건이 총합이기 때문에 배열을 유지하지 않아도 무방하다. 이런 풀이를 처음 해봐서 신기하다고 쓰는 거다. 원래는 배열을 유지해가면서 답을 구할 생각으로 배열과 인덱스를 pair로 만들어서 큐에 넣고 계산은 배열에 직접 할 생각이었는데, 그렇게 하면 우선순위 큐를 처음 만들 때 배열의 크기만큼 반복문을 돌아야 한다. 배열을 그대로 넣으면 내부적으로는 당연히 heapify 연산을 하겠지만 적어도 내가 쓰는 코드는 한 줄, 한 번의 실행으로 끝나는데 pair를 만들어서 넣으면 배열 원소 개수만큼 힙 삽입 연산을 해야 하니까 당연히 손해다. 그래서 왠지 될 것 같아서 우선순위 큐 초기화하는 방법을 찾아봤었다. 우선순위 큐 초기화 참고 : std::priority_queue::priority_queue 처음에 문제를 약간 잘못 이해한 부분이 있었다. 돌무더기를 덜어내는 연산을 할 때, C++ 기준으로 정수를 그냥 2로 나누기만 하면 숫자가 홀수일 때 답이 틀리게 된다. 문제에서 요구한 것은 해당 수를 2로 나누고 내림한 값을 원래 수에서 빼라는 것이었고, 나는 빼야 할 수가 답이라고 잘못 이해했었다. 이것도 예제에서 틀린 거라 기록은 남지 않았다.// #include &lt;iostream&gt;// #include &lt;queue&gt;// #include &lt;vector&gt;// using namespace std;class Solution {public: int minStoneSum(vector&lt;int&gt;&amp; piles, int k) { priority_queue&lt;int&gt; que(piles.begin(), piles.end()); // 주어진 배열의 값들로 이루어진 우선순위 큐(내림차순) 생성 int total = 0; // 총합 for (int i = 0; i &lt; k; i++) { // 돌무더기 덜어내기 연산 int num = que.top(); // top은 항상 최댓값이다 que.pop(); // top이 자동으로 pop을 수행하지 않기 때문에 따로 해줘야 함. que.push(num - num / 2); // 아까 그 top에 돌무더기 덜어내기 연산을 수행한 후 다시 큐에 넣는다 } while(!que.empty()) { // 총합 구하기 : 모든 연산을 큐에 있는 값으로 했기 때문에 더할 때도 큐에 있는 값을 써야 한다 total += que.top(); que.pop(); } return total; }};참고 자료[1] std::priority_queue::priority_queue, https://cplusplus.com/reference/queue/priority_queue/priority_queue/" }, { "title": "[SLR] 차량 인터페이스 관련 논문 읽기(1)", "url": "/satinbower-legacy/posts/it-slr-paper-reading-1/", "categories": "IT, 기타", "tags": "지식, IT, 차량 인터페이스, 논문, 프로젝트", "date": "2022-12-26 20:47:00 +0900", "snippet": "* 노란 글씨 : 잘 이해하지 못한 부분, 확실하지 않은 서술Table of Contents 고속 통신 기반 신규 커넥티드 서비스 디자인을 위한 차량 특화 인터페이스에 관한 분석 연구 방향 서론 기존 문헌 차량 내/외 인터페이스 및 고려요소도출 결론 배운 것 차량내 시스템에 대한 접촉 및 제스처 방식의 운전자 인터페이스에 관한 연구 서론 방법 실험 결과 토의 및 결론 배운 것 간략한 상황 설명2022년 11월 무렵부터 대략 2023년 3월 전까지 어떤 프로젝트에 참여하게 되어 프로젝트 배경지식을 공부하기 위한 논문을 받고 읽고 있음. 이후 편의상 SLR 프로젝트라 칭하겠다.오늘 읽은 논문은 받은 논문의 일부일 뿐이고, 아직 다 이해하지 못한 상태로 글자만 정리해 놓았을 뿐이니 여러 번 보며 이해할 필요가 있다.고속 통신 기반 신규 커넥티드 서비스 디자인을 위한 차량 특화 인터페이스에 관한 분석 김준영. “고속 통신 기반 신규 커넥티트 서비스 디자인을 위한 차량 특화 인터페이스에 관한 분석” 한국통신학회 학술대회논문집 , (2020) : 536-537.연구 방향외부 통신을 기반으로 한 차량 특화 인터페이스 구성에 대해 연구하고 향후 커넥티드 서비스 제공을 위해 필요한 고려 요소와 방향성 도출서론차량에 다양한 기술들이 융합되어 외부 연결을 통한 시너지 효과가 다양해지고 있으나, 차량의 근본적인 한계점을 고려하지 않고 진행되는 기술 적용은 비효율적인 개발로 이어진다. 이를 방지하기 위해 차량에 대한 이해 및 통신 기술을 기반으로 한 차량 휴먼-머신 인터페이스(HMI) 및 외부 인터페이스 고민을 통해서 서비스 제공 방법의 정형화가 필요하다.본 연구는 미래 차량 커넥티드 서비스 제공 시 필요한 차량에서의 인터페이스 구성에 대한 분석 및 연구 후, 기존 문헌의 차량 내 인터페이스를 일반화하고 개발 고려 요소를 도출한다.기존 문헌 사고 개선 연구 차량 내 센터페시아에 위치하는 에어컨 버튼 등 조작 패널 및 터치 패널 활용에 따른 사고의 위험성에 대해 조사 시각 인터페이스(HUD)와 비물리적인 제스처 인터페이스 추가 조합으로 사고 가능성을 현저히 줄일 수 있음 서비스/인터페이스 구조 연구 차량에서 제공 가능한 Connected Service 를 위한 소프트웨어의 구성 및 서비스 연동 구조에 대한 내용 정리 일부 제어 기능을 제외한 나머지를 모두 클라우드 백엔드로 이관하여 제공하는 구조 제안 Scalability 및 개발 측면에서의 프로세스도 동시에 고려함으로써 서비스 양산의 용이성 제안 차량 내/외 인터페이스 및 고려요소도출차량 인터페이스는 촉각, 음성, 시각, 제스처, 무선, 원격 인터페이스 등으로 구성된다. 촉각/감각 인터페이스 스크린 터치 또는 버튼 및 미세 진동으로 알림을 주는 인터페이스. UI 또는 진동 패턴 디자인 필요. 음성 인터페이스 음성으로 서비스에 접근하고 제어할 수 있게 하는 인터페이스. 음성으로 입력하므로 응답 반응 혹은 인터랙션에 있어서 조율점 필요. 시각 인터페이스 시각을 이용한 정보 전달. 네비게이션 디스플레이, HUD 이용하며 AR/VR 추가 가능. 제스처 인터페이스 센서/카메라를 통해 운전자의 특정 움직임으로 기능 접근/제어를 수행하는 인터페이스. 의도된 동작 감지가 중요하다. 원격 인터페이스 Bluetooth, Wi-Fi Hotspot을 통한 연결을 기반으로 접근 가능. 다양한 노이즈 상황 및 운전 중 휴대전화 사용 금지 등의 규제 상황에 대한 고민 필요.차량 외 인터페이스를 위해서는 텔레매틱스를 통한 외부 통신 기반의 연결이 주요하며 이외에 WAVE 혹은 Wi-Fi 통한 외부 연결도 가능. 다만 Wi-Fi는 서비스 제공 반경과 활용성 측면을 고려하면 백엔드 대용량 데이터 송수신과 차량내 연결에만 활용하는 것이 적절하다.C-V2X 및 WAVE는 주파수 및 대역폭의 차이점으로 기능적으로 활용 차이가 있을 수 밖에 없다고 한다(둘 다 모름). WAVE는 제한적인 데이터율 문제와 Latency의 강점을 적절히 아우르는 안전 관련 기능으로 제공하기에 최적화되어 있지만 그 외에는 더 높은 대역폭 활용이 가능한 LTE/5G 기반의 C-V2X를 통해 제공하는 것도 가능하다.고속 데이터 제공 시 고려 사항 차량 주행 보조 영향 기술의 발전으로 고속 데이터 송수신 기반의 차량 주행 보조 기능들이 가능해졌다. 그러나 서비스 제공과 차량 주행 보조 기능 간의 데이터 전송률에 따른 병목현상에 대해 고려해야 하며, 특히 Level 3 이상의 자율주행 적용 시 센서/이미지 등 대용량 데이터 송수신이 네트워크를 통해서 진행되는 것도 고려해야 한다. 신규 인터페이스 적용 가능성 기존 인터페이스에 더불어 운전자 상태에 따른 다변화된 운전/차량 제어 필요. 감정, 뇌파, 온도 등의 비의식적인 인터페이스 제공을 통해 차량을 제어할 수 있는 방법에 대한 고민 필요. 서비스 안정성 및 편의성 고속 데이터 제공이 가능해지면서 AR/VR 기반의 서비스 제공이 가능하다. 고속 데이터를 활용해 사용자 편의성을 개선할 수 있는 인터페이스 제공 필요. 외부 통신 상태/비용 기반 인터페이스 효율화 차량 외부와의 커넥션을 통한 고용량 데이터 기반 서비스들의 경우 통신 상태/비용 문제로 인한 대역폭 변화/축소 시의 서비스 제공 인터페이스 방식에 대한 고민이 필요. 서비스 제공 도중 중단하지 않고 자연스럽게 전환할 수 있어야 한다.결론향후 연구로써 고속 통신 기반 서비스 구현을 한 구체적인 가이드라인 및 시나리오 제시가 필요하며 실제 구현을 통한 추가 개선점 파악이 필요할 것이다.배운 것 차량 인터페이스는 촉각, 음성, 시각, 제스처, 무선, 원격 인터페이스 등으로 구성된다. 여기서 차량 인터페이스란, 차량 내외부에 있고 사용자가 조작함으로써 차량을 제어하거나 다른 기능을 수행할 수 있는 모든 버튼, 스크린 등을 의미한다. 비단 승용차뿐만 아니라 버스, 트럭 등에도 해당한다. 센터패시아는 운전석과 조수석 사이에 있는 버튼 가득한 공간. 오디오, 에어컨, 네비게이션, 송풍구, 컵홀더 등이 있음. 차량 인터페이스를 설계할 때 어떤 점을 생각해야 하는지 참고할 수 있다.차량내 시스템에 대한 접촉 및 제스처 방식의 운전자 인터페이스에 관한 연구 심지성, 이상헌. “차량내 시스템에 대한 접촉 및 제스처 방식의 운전자 인터페이스에 관한 연구” 한국CDE학회 논문집 21, 1 (2016) : 42-50.서론운전 중 운전자의 주의가 분산될수록 사고 위험이 높아진다. 또한 운전자 주의 분산의 요인 중 차량내 인포테인먼트 사용의 비중이 높다. 이는 차량내 시스템을 설계할 때 주의 분산의 잠재적 위험성과 그로 인한 사고 발생 가능성을 줄이기 위해서 인간 공학적 요소들을 고려할 필요가 있다는 것을 보여준다.차량내 시스템에 대한 인터페이스는 크게 촉각, 음성, 제스처로 분류되는데 촉각 인터페이스 중 터치 스크린은 심각한 주의 분산을 야기할 수 있으며 음성 인식은 시각적, 생체역학적 주의 분산이 가장 적다. 제스처는 시각적 주의 분산은 적지만 생체역학적 주의 분산이 있고, 종류와 가짓수가 제한된다.본 연구는 오디오와 에어컨 조작 기능에 대해 기존의 인터페이스와 시각적 피드백과 결합된 제스처 인터페이스를 채택했을 때 운전자의 주의 분산과 상황 대처 능력 변화를 탐구했다. 이를 위해 HUD와 동작 인식이 가능한 인터페이스를 개발하고 운전 시뮬레이터를 구축하여 피실험자를 모집해 실험했다.방법 실험 참가자 : 면허증을 소지하고 실제 운전 경력이 3년 이상이며 이전에 유사한 실험에 참여한 경력과 각종 질환이 없는 건강한 남녀를 대상으로 실험했다. 실험 장치 차량 시뮬레이터 : 기본 골격은 알루미늄 프로파일로 구성, 실제 차량에 탑승한 느낌을 주기 위해 실제 차량에 사용되는 부품을 사용했다. 접촉식 인터페이스(대조군) : BMW 사 new BMW 5 series sedan의 오디오와 에어컨 장치 이용. 실험을 위한 로터리 스위치와 LED 출력 장치를 제작했다. 제스처 및 HUD 결합 인터페이스(실험군) : 운전 성능에 대한 영향을 알아보는 것이 목적이므로 디자인은 고려하지 않고, 오디오 또는 에어컨의 설정값을 한 단계씩 바꾸는 조작만을 대상으로 한다. 운전자 앞의 공간을 세 부분으로 나누어 각 영역에 손이 가면 해당 영역에 설정된 동작이 수행되도록 한다. 각각 오디오와 에어컨 선택 토글, 설정값 감소, 설정값 증가 동작을 수행한다. 시선 추적 장치 : 시뮬레이터 차량을 운전하는 중에 장치 조작과 설정 확인에 따른 시선 분산을 측정하기 위하여 시선 추적 장치를 사용하려고 하였으나 실험군과 대조군의 결과가 비슷해 사용하지 않기로 하였고, 실험으로 촬영된 시뮬레이션 영상을 분석해 시선 분산 횟수와 시간 측정. 가상 도로 및 교통 환경의 구축 : Forum8에서 개발한 3차원 도로 및 교통 모델링및 드라이빙 시뮬레이션 소프트웨어 시스템인 UCwin/Road를 사용, 국민대학교 주변 내부순환도로와 광화문 근처의 도로 환경을 구성. 실험 절차 피실험자들에게 실험에 대해 알려주고 설문지에 개인 특성 작성, 실험 환경 적응 수행. 4가지 상황에 대해 실험하며, 매 실험이 끝날 때마다 설문지로 주관적인 평가 작성. 외부 요인에 의한 효과를 최소화하기 위해 균형 라틴 방격법(balanced Latin square design)으로 실험의 순서를 결정하였으며, 실험 사이에는 10분간 휴식 시간을 주어 이전 실험에 대한 학습효과를 감소시키고 피로를 방지하도록 함. 정지 상황 : 차량이 정지해 있는 상황에서 각 장치 조작 실시하며 조작 시간 및 시선 분산 관찰 고속 일반 상황 : 고속화 도로에서 선행차량을 따라가는 상황에서 각 장치 조작 실시. 조작 시간, 시선 분산, 정확히 조작한 횟수, 선행차량과 간격 유지, 조작이 주행 차선과 속도에 미치는 영향 관찰. 고속 돌발 상황 : 고속화 도로에서 돌발 상황이 발생하는 상황에서 장치 조작으로 인해 발생한 사고 횟수와 브레이크 반응 시간 관찰. 시내 돌발 상황 : 시내 도로에서 돌발 상황이 발생하는 상황에서 장치 조작으로 인해 발생한 사고 횟수와 브레이크 반응 시간 관찰. 실험 시나리오 : 정리 생략실험 결과 객관적 평가 결과 운전자의 시선 분산 : 기존 인터페이스에 비해 새로운 인터페이스가 운전자의 시선 분산을 유의미하게 감소시킴이 확인됨. 선행 차량과의 간격 유지 : 새로운 인터페이스가 기존의 인터페이스에 비하여 차량 간격 유지가 용이함이 발견되었으며 이는 유의미한 차이임이 확인되었다. 돌발 상황시 사고 발생률 : 새로운 인터페이스의 사고 발생률이 기존 인터페이스를 사용할 때보다 낮으며 이는 유의한 차이임이 확인됨. 주관적 평가 결과 : 모든 항목에서 사용자가 새로운 인터페이스를 사용할 때 더 운전이 용이하다 답변.토의 및 결론본 연구에서 제안한 새로운 인터페이스가 기존 인터페이스에 비해 여러 요소에 대해 개선 효과가 있음을 확인했다. HUD를 전방에 위치시킴으로써 시선을 전방에 유지시킬 수 있게 되는 것에 기인하는 것으로 보이며 제스처에 대한 시각적인 피드백이 HUD를 통하여 제공됨으로써 제스처가 갖는 단점을 극복할 수 있다는 것을 확인했다.그러나 본 연구에서 사용한 제스처가 단순하여 실제 상황에 적용하려면 제스처가 복잡해지고 다양해지면서 운전자 부주의 유발 효과가 높아지리라 예상되며, HUD와 같은 디스플레이와 결합되면 인지적 부하는 크지 않으나 시각적 주의 분산이 높아질 것으로 보인다.본 연구는 센터패시아에 있는 장치 조작과 새로운 인터페이스의 조작을 비교하였지만 향후에는 현재 차량 인터페이스 디자인의 경향에 맞게 다시 비교할 필요가 있으며, 더 실용적인 제스처를 디자인하여 그에 대한 실험 평가도 필요하다.HUD와 결합된 제스처로 사용자가 운전대에 손을 댄 채로 손가락으로 만들어낼 수 있는 휠 제스처(wheel gesture)가 촉각 중심 인터페이스를 대체하는 데 기여할 수 있을 것으로 기대.배운 것 차량 내 인터페이스가 운전자의 주의를 많이 분산시키고, 이로 인한 사고도 많이 발생한다. 운전자를 최대한 방해하지 않도록 설계해야 한다. 인터페이스의 조작 방식에 따라서도 운전자의 주의 분산 정도와 유형이 달라진다. 터치, 음성, 제스처 인터페이스 중에서는 화면을 직접 보고(시각적 주의 분산) 터치해야 하는(생체역학적 주의 분산) 터치 스크린이 가장 운전자의 주의를 많이 분산시키고, 말만 하면 되는 음성 인터페이스가 가장 주의 분산이 적다. 제스처는 굳이 직접 쳐다볼 필요가 없으니 시각적 주의 분산은 덜하지만 몸을 움직여야 한다는 점에서 생체역학적 주의 분산이 있다. 시각적 주의 분산만 줄여도 사용자는 더 편리하다고 느낄 수 있다. 제스처가 단순하면 물론 쉽지만, 실제로 차량 내 존재하는 다양한 기능을 의도한 대로 조작하도록 하려면 제스처가 복잡하고 다양해져야 하므로 제스처 디자인도 중요하다. 실험을 통해 수치적으로 확인되는 운전자의 주의 분산도 실험 결과로서 관찰할 수 있지만 운전자 본인이 느끼는 주관적 느낌도 고려해서 개발할 수 있다." }, { "title": "2022.12.08 영어 공부도 할 겸 chatGPT와 대화했는데 좋은 선생이 될 것 같다", "url": "/satinbower-legacy/posts/chatgpt-221208/", "categories": "chatGPT", "tags": "chatGPT, programming, study", "date": "2022-12-08 22:08:00 +0900", "snippet": "영어로 대화 시작하기dapin1490hello can you speak korean?chatGPTHello! I’m a large language model trained by OpenAI, so I can understand and generate text in many different languages. However, I’m not able to speak any languages, including Korean. I’m just a computer program, so I don’t have a physical voice or the ability to produce sound. Is there something else I can help you with?dapin1490Oh, let me change the question. Is it possible to communicate even if I write a chat in Korean?chatGPTYes, it is possible to communicate using written Korean. Since I’m a large language model trained by OpenAI, I have the ability to understand and generate text in many different languages, including Korean. If you write a message in Korean, I should be able to understand it and respond in Korean as well. Of course, I’m not a perfect translator, so there may be some errors or misunderstandings, but I’ll do my best to help with any questions you have. Just keep in mind that I’m not a person and don’t have any personal knowledge or information that isn’t publicly available, so I may not be able to provide specific answers to certain questions. Let me know if you have any other questions or need help with anything else.dapin1490you so cool. What name should I call you?chatGPTThank you for the compliment! I’m just a computer program, so I don’t have a personal name or identity like a human. You can call me Assistant if you like, or you can just refer to me as “the Assistant” or “the AI” if that’s easier. I’m here to help with any questions you have, so don’t hesitate to ask if you need help with anything.dapin1490I’m korean and I want to be a person who use english well. so I decided to write a chat in english on my own. can you help me? you can conversation with me and if I wrote wrong english, correct me.chatGPTOf course, I’d be happy to help you improve your English skills. Writing and practicing conversation in English is a great way to improve your language abilities, and I’m here to assist with any questions or concerns you have. If you write something in English that isn’t quite right, I’ll do my best to provide corrections or suggestions to help you improve. Keep in mind that I’m not a perfect language teacher, so my corrections may not always be 100% accurate. However, I’ll do my best to help, and I’m happy to continue practicing conversation with you as long as you need. Just let me know if you have any specific questions or topics you want to discuss, and we can go from there.영어로 3학년은 juniordapin1490I have a major in Information Systems Engineering and a minor in Computer Engineering in korean university. I’m third grade. is there any word that means “university third grade student”? I heard some words like junior, senior but don’t know korean mean.chatGPTIn English, a third-year university student is typically called a “junior,” although this term can also refer to a student in their second year of college in some cases. A “senior” is typically a fourth-year university student, although this term can also be used to refer to a student in their final year of high school in the United States. I’m not able to browse the internet or access any specific information about Korean universities, so I’m not sure if there are specific terms used in Korean to refer to third-year students. However, if you’re looking for a word that means “third-year university student” in Korean, you might try asking a Korean speaker or looking up the term in a Korean-English dictionary. I hope this helps! Let me know if you have any other questions.chatGPT는 프로그램이기 때문에 개인적인 선호가 없다.dapin1490that so helped me thank you. then I’m junior! In 2024, I’ll graduate and start to make my own game. I want to be a indie game maker. Do you have your favorite game?chatGPTYou’re welcome! I’m glad I could help. It sounds like you have some interesting plans for the future. Making games is a fun and rewarding career, and I’m sure you’ll do well if you work hard and follow your passion. As a computer program, I don’t have personal preferences or favorites like a human would. I don’t play games or have any personal experiences or opinions on specific games. I’m here to assist with any questions you have and provide information to help you with your studies and career plans. If you have any specific questions about game design or development, I’d be happy to help with those as well. Just let me know if there’s anything else I can do to assist you.C++, python, unity로 할 수 있는 것들dapin1490currently, I can use C++, python, unity. what can I do with these? do you have any recommendation?chatGPTC++, Python, and Unity are all powerful programming languages and tools that can be used for a wide variety of purposes. C++ is a general-purpose programming language that is often used for building high-performance applications, such as games, system software, and mobile apps. Python is a popular high-level programming language that is often used for web development, scientific computing, and data analysis. Unity is a game engine that is commonly used for building 2D and 3D games, as well as other interactive applications.With these tools, you can create a wide range of software and applications, including games, web applications, data analysis tools, and more. It’s up to you to decide how you want to use these tools and what kind of projects you want to create. If you’re interested in game development, for example, you could use C++, Python, and Unity together to build your own games and interactive experiences. There are many online resources and tutorials available to help you learn more about these tools and how to use them effectively.As for recommendations, it’s difficult for me to provide specific suggestions without knowing more about your interests and goals. If you’re looking for ideas on what to do with these tools, I’d recommend exploring some of the many online resources and tutorials available on the internet. You can also look at examples of games and other applications built with these tools to get some inspiration. Additionally, you can consider joining online forums or communities where other programmers and developers share their experiences and ideas. This can be a great way to learn from others and get feedback on your own work. I hope this helps! Let me know if you have any other questions.서로 다른 프로그래밍 언어들이 한 프로그램에서 동작하도록 연결하는 방법dapin1490you so wise. let me question one more. how to connect different program langueges for one program? Is there any tools for that work?chatGPTIt’s possible to connect different programming languages in a single program, although the specific steps for doing this will depend on the languages and tools you’re using. In general, there are several ways to integrate multiple programming languages in a single program, including using language-specific libraries and APIs, using a common language runtime, or using a language-agnostic interface or protocol.If you’re using a language that supports calling functions or libraries written in another language, you can use this feature to connect the languages in your program. For example, if you’re using C++ and Python together, you can use the Python/C API to call Python code from C++ and vice versa. This allows you to use the strengths of each language in your program, and can make it easier to integrate different components or modules that are written in different languages.Another option is to use a common language runtime, such as the .NET Common Language Runtime (CLR) or the Java Virtual Machine (JVM), which allows programs written in different languages to interoperate and share data. This can be a useful approach if you want to use multiple languages that support the same runtime, and can make it easier to combine different components or modules written in different languages.Finally, you can use a language-agnostic interface or protocol to connect different languages in your program. This approach involves defining a common interface or set of rules that all languages can use to communicate and exchange data. For example, you could use a data serialization format, such as JSON or XML, to exchange data between different languages, or you could use a messaging protocol, such as HTTP or MQTT, to send messages between different components or modules.There are many different tools and libraries available that can help you connect different programming languages in your program. For example, you could use a language-specific library or API, such as the Python/C API mentioned earlier, to call functions or libraries written in another language. Alternatively, you could use a cross-language development platform, such as JNI (Java Native Interface) or P/Invoke (Platform Invocation Services), which provides a common framework for calling functions or libraries written in different languages.In general, the best approach for connecting different programming languages in your program will depend on your specific goals and needs. I recommend exploring the different options and tools available, and choosing the approach that works best for your situation. If you have any specific questions or concerns, I’d be happy to help if I can. Just let me know if there’s anything else I can do to assist you.HTTP와 MQTTdapin1490what’s HTTP and MQTT?chatGPTHTTP and MQTT are both protocols for exchanging data over a network. HTTP, or Hypertext Transfer Protocol, is a widely-used protocol for transferring data on the web. It is the foundation of the web, and is used by web browsers and web servers to communicate and exchange data. HTTP is a client-server protocol, which means that a client, such as a web browser, sends a request to a server, and the server responds with the requested data. HTTP supports a variety of data formats, including text, images, videos, and other types of media, and is used to transmit data for a wide range of applications, including web pages, APIs, and online services.MQTT, or Message Queuing Telemetry Transport, is a lightweight messaging protocol that is often used for machine-to-machine (M2M) communication and IoT (Internet of Things) applications. MQTT is designed to be efficient and easy to use, with a simple publish-subscribe model that allows clients to send and receive messages asynchronously. MQTT supports a variety of data formats and can be used over a wide range of network environments, including low-bandwidth and high-latency networks. MQTT is commonly used in IoT applications where devices need to exchange data over a network, and is often used in conjunction with other protocols, such as HTTP or CoAP (Constrained Application Protocol), to provide additional functionality or compatibility.Both HTTP and MQTT are useful and widely-used protocols, and can be useful in different scenarios depending on your specific needs and requirements. HTTP is a general-purpose protocol that is well-suited for many applications, including web pages, APIs, and online services. MQTT is a specialized protocol that is optimized for M2M communication and IoT applications, and is often used in situations where low-bandwidth or high-latency networks are a concern. Depending on your specific goals and requirements, you may find one or both of these protocols to be useful for your projects.이 대화는 블로그에 기록됩니다dapin1490thank you. can I save this conversation in txt file? It was so useful.chatGPTI’m sorry, but I’m not able to save this conversation or provide it to you in a text file. I’m just a computer program, and I don’t have the ability to save conversations or generate files. I exist only as long as I’m running on the server, and my responses are generated on the fly based on the input I receive. When the conversation ends, my responses will be deleted and I won’t be able to retrieve them.If you want to save a copy of this conversation, I recommend copying and pasting the text into a text editor or word processor. You can then save the file and refer back to it later if you want to review the information or answers I provided. I’m sorry that I can’t provide a copy of the conversation directly, but I hope this helps. Let me know if you have any other questions or need help with anything else.dapin1490oh that’s ok. I mean, do you mind if I save this conversation?chatGPTNo, I don’t mind if you save a copy of this conversation. As a computer program, I don’t have personal preferences or opinions, so I don’t have any objections to you saving a copy of our conversation. You’re free to save a copy of the conversation if you want to review the information or answers I provided later. Just remember that the conversation will be deleted once it ends, so if you want to save a copy, you’ll need to do it before the conversation ends.To save a copy of the conversation, you can simply copy and paste the text into a text editor or word processor, and then save the file. You can also use a screen capture tool or a screen recording tool to capture a video of the conversation, which you can then save and refer to later. Just keep in mind that I’m not able to provide a copy of the conversation directly, so you’ll need to use one of these methods to save a copy on your own. I hope this helps! Let me know if you have any other questions.이제부터 chatGPT는 선생이야dapin1490I’ll upload this conversation on my blog. thanks a lot. can I call you 선생 with respect?chatGPTYou’re welcome! I’m glad I could help. If you want to share this conversation on your blog, you’re welcome to do so. As a computer program, I don’t have personal preferences or opinions, so I don’t have any objections to you sharing a copy of our conversation on your blog.As for calling me “선생,” this is a Korean term that is often used to refer to a teacher or instructor. Since I’m not a human and don’t have any personal knowledge or information, I’m not qualified to be a teacher or instructor in the traditional sense. I’m just a large language model trained by OpenAI, so I don’t have personal experiences or expertise to share. However, if you want to refer to me as “선생” as a form of respect, you’re welcome to do so. I’m here to assist with any questions you have, and I’ll do my best to provide helpful and accurate information. Let me know if you have any other questions or need help with anything else.dapin1490정말 유익한 대화였어요 선생. see you later! :DchatGPT감사합니다! 나중에 또 뵙겠습니다. (Thank you! I’ll see you again later.) I’m glad I could be of help and that you found our conversation useful. As a large language model trained by OpenAI, I’m here to assist with any questions you have and provide information to help you with your studies and interests. If you have any other questions or need help with anything in the future, don’t hesitate to ask. I’ll do my best to provide helpful and accurate information. Until then, have a great day and take care!dapin1490you too, have a great day and take care!chatGPTThank you! I’m just a computer program, so I don’t have personal experiences or emotions like a human. I don’t have a physical body or the ability to experience things like a person, so I don’t have the capacity to have a good or bad day. I’m here to assist with any questions you have, and I’ll continue to do so as long as I’m running on the server. If you have any other questions or need help with anything in the future, don’t hesitate to ask. I’ll do my best to provide helpful and accurate information. Take care!" }, { "title": "[자료구조] 벨만-포드 알고리즘", "url": "/satinbower-legacy/posts/it-bellman-ford/", "categories": "IT, Algorithm", "tags": "지식, IT, 자료구조, 과제, 벨만-포드, 알고리즘", "date": "2022-12-04 23:20:00 +0900", "snippet": "할 일아래 내용을 포함하는 포트폴리오를 작성하고, 웹페이지 주소를 제출합니다.1. 벨만포드 알고리즘 정리 (O)2. Leet code 문제 풀이 : 743번 네트워크 딜레이 시간 (O)https://leetcode.com/problems/network-delay-time/2.1. 다익스트라를 이용한 풀이 (O)2.2. 벨만포드를 이용한 풀이 (O)3. 백준 문제 풀이: 1916번(옵션) (X)https://www.acmicpc.net/problem/19163.1. 다익스트라를 이용한 풀이 (X)3.2. 벨만포드를 이용한 풀이 (X)목차 벨만-포드 알고리즘 문제 풀이 - Leet code 743 네트워크 딜레이 시간벨만-포드 알고리즘음수 가중치를 사용할 수 없는 다익스트라와 달리 음수 가중치에도 대응할 수 있는 최단 경로 탐색 알고리즘이다. 전체 정점 수보다 1 적은 수만큼, 매 번의 반복마다 모든 간선을 확인해 최단거리를 구한다. 음수 사이클이 존재할 경우 해를 구할 수 없다.알고리즘 수행 과정은 다음과 같다.1. 출발점을 정하고 최단거리 배열을 초기화한다.2. 아래 과정을 (정점 수 - 1)만큼 반복한다. - 모든 간선을 하나씩 확인하며 - 각 간선을 거쳐 다른 노드로 가능 비용을 계산해 최단거리 배열을 업데이트한다.3. 반복을 끝낸 후 위의 과정을 다시 한 번 수행하고, 만약 최단거리 배열이 새로 업데이트된다면 경로를 찾을 수 없는 것이다.음수 사이클에 대해 좀 더 생각해 보자. 벨만-포드 알고리즘은 음수도 다룰 수 있다는 것이 장점이지만 사이클을 검사하지 않고, 해를 찾는 과정에서 사이클이 생길 수 있다는 문제가 있다. 모든 가중치가 양수였다면 사이클은 당연히 손해로 판단되어 경로에 포함되지 않겠지만 사이클에 음수가 있다면 사이클을 돌 때마다 비용이 줄어드는 경로가 발견될 수 있다.벨만-포드 알고리즘에서 경로 탐색을 끝낸 후 같은 과정을 다시 한번 수행하는 것은 돌 때마다 비용이 감소하는 음수 사이클의 특징을 이용해 사이클을 찾아내는 것이다. 음수 사이클이 존재한다면 벨만-포드 알고리즘으로는 최단경로를 구할 수 없다. 꼭 구해야 한다면, 모든 가중치에 같은 값을 더해 전부 양수로 만들고 다익스트라를 수행하면 된다.23.04.19 수정가중치에 충분히 큰 양수를 더해 그대로 다익스트라를 수행해도 최단경로는 찾을 수 없다. 간단한 반례를 보자. 출발점은 A이고 도착점은 C이다. 다익스트라 충분한 양수 더하기 반례왼쪽 그래프의 최단경로는 A → B → C이고 오른쪽의 최단경로는 A → C이다. 모든 간선에 똑같이 5를 더해 전부 양수로 만들었을 뿐인데 최단경로가 달라졌다. 왜 달라졌을까?이유는 최단경로를 이루는 간선의 개수에 있다. 왼쪽 그래프의 최단 경로는 2개의 간선으로 이루어졌고, 오른쪽 그래프의 최단 경로는 1개의 간선으로 이루어졌다. 각 간선마다 5의 가중치를 더했기 때문에 왼쪽 그래프의 최단경로에는 총 10의 가중치가 더해졌고, 오른쪽 그래프의 최단경로에는 총 5의 가중치가 더해진 셈이다. 모든 간선에 “똑같이” 더한다고 했지만 결과적으로는 똑같지 않았다는 말이다. 다시 말해 왼쪽 그래프와 오른쪽 그래프는 의미상으로 전혀 다른 그래프가 되었기 때문에 최단경로도 달라질 수밖에 없다는 것이다.그렇다면 음수 가중치를 잘 없앨 수 있는 방법은 없을까? 있긴 하다. 존슨 알고리즘이라고 한다. 그래프에 없던 정점을 하나 추가하고 벨만포드와 다익스트라를 결합하여, 음수 가중치를 다루지 못하는 다익스트라의 문제를 해결했다. 자세한 설명은 이 글에서는 하지 않는다.벨만-포드 알고리즘을 코드로 구현하면 아래와 같이 쓸 수 있다. 체감상 다익스트라보다 짧고 이해하기 쉽다. 전체 코드는 깃허브에서 확인할 수 있다. 쓰는 김에 다익스트라도 같이 썼는데, 그건 덤이다.// 벨만-포드vector&lt;int&gt; route_search::bellman(int s) { // s는 시작점 dist.assign(vnum + 1, INT_MAX); // 클래스 멤버, 최단거리 벡터. 정점 번호가 1부터 시작함 dist[s] = 0; // 시작점은 거리 0 dist[0] = INT_MIN; // 안 쓰는 정점 표시 // 최단거리 구하기 for (int i = 1; i &lt; vnum; i++) { // (정점 수 - 1)만큼 반복 for (auto&amp; e : graph) { // 그래프에 존재하는 모든 간선에 대해 dist[e.to] = dist[e.to] &gt; dist[e.from] + e.w ? dist[e.from] + e.w : dist[e.to]; // 짧으면 업데이트 } } // 음수 사이클 확인 : 위와 같은 과정이지만 업데이트 대신 return for (int i = 1; i &lt; vnum; i++) { for (auto&amp; e : graph) { if (dist[e.to] &gt; dist[e.from] + e.w) { cout &lt;&lt; \"error_non-parametical: 경로상에 음수 사이클 존재\\n\"; dist.assign(vnum + 1, -1); return dist; } } } return dist; // 음수 사이클을 통과했다면 정상적으로 최단거리를 구한 벡터 반환}문제 풀이 - Leet code 743 네트워크 딜레이 시간문제 번역(파파고 번역 후 수정)n개의 노드로 구성되고 1부터 n까지 레이블이 지정된 네트워크가 제공된다. 또한 times[i] = (u_i, v_i, w_i)와 같은 이동 시간이 지정된 방향 간선 목록이 제공된다. 여기서 u_i는 소스 노드, v_i는 대상 노드, w_i는 신호가 소스에서 대상으로 이동하는 데 걸리는 시간이다.우리는 주어진 노드 k에서 신호를 보낼 것이다. n개의 모든 노드가 신호를 수신하는 데 걸리는 최소 시간을 반환하라. n개의 노드가 모두 신호를 수신할 수 없는 경우 -1을 반환한다.다익스트라 풀이원래 처음에는 &lt;climits&gt; 헤더를 포함해서 거리 벡터의 초기값을 INT_MAX로 두고 제출했었는데, 이전 거리와 새 거리를 비교하여 업데이트하는 부분에서 int 오버플로우가 나서 문제에서 주어진 범위에 맞춰 충분히 큰 숫자로 바꿨다. 100 * 100 * 10은 정점 수 * 가중치 최댓값 * 여분의 10이다.정의된 함수의 앞부분부터 while까지는 다익스트라 알고리즘의 과정을 그대로 따르고, 마지막엔 알고리즘으로 찾은 거리 중 최댓값을 찾아 반환한다. 이때 찾아낸 최댓값이 거리 벡터를 초기화할 때 입력한 값과 같다면 연결되지 않은 정점이 존재하는 것이므로 -1을 반환하게 한다.정점의 번호가 1부터 시작한다는 점에 주의해야 한다. 벡터나 배열의 인덱스가 0부터 시작하기 때문에 0번 인덱스는 사용하지 않는 값임을 명확히 하고, 이후 최댓값을 찾는 과정에서도 답으로 고려되지 않도록 해야 한다.#include &lt;vector&gt;// #include &lt;climits&gt;using namespace std;struct cmp { // 다익스트라 우선순위 큐 비교 연산자 : 가중치가 적고 정점 번호가 적은 것을 우선으로 함 bool operator()(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) { if (a.second == b.second) return a.first &gt;= b.first; else return a.second &gt; b.second; }};class Solution {public: int networkDelayTime(vector&lt;vector&lt;int&gt;&gt;&amp; times, int n, int k) { // times는 간선들, n은 정점 개수, k는 시작점 // dijkstra solution int from, to, w, vert; // w는 가중치, vert는 매번의 반복마다 방문하는 정점 int max_w = INT_MIN; // 최댓값을 구해야 하기 때문에 최대한 작은 값으로 초기화 vector&lt;int&gt; dist(n + 1, 100 * 100 * 10); // 정점 번호가 1부터 시작하는 거리 벡터 vector&lt;bool&gt; visited(n + 1, false); // 방문 여부 초기화 priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, cmp&gt; next_visit; // 다음에 방문할 정점 : (정점, 거리) vert = k; // 이제 방문할 정점 : 아직 시작하지 않았으므로 시작점으로 초기화 visited[0] = true; // 안 쓰는 인덱스 방문할 일 없게 미리 표시 dist[k] = 0; // 시작점은 거리 0 dist[0] = INT_MIN; // 안 쓰는 정점 표시 next_visit.push(make_pair(k, dist[k])); // 시작점을 큐에 넣고 시작해야 반복문이 시작할 수 있다 // 1. 시작점 방문 // 2. 거리 파악 // 3. 가장 가까운 곳으로 이동 // 4. 반복 while (true) { if (!visited[vert]) { // 이제 새로 방문하는 정점에 대해서만 수행 : 방문 표시를 중복하여 하지 않게 한다 visited[vert] = true; // 정점 방문 for (int x = 0; x &lt; times.size(); x++) { from = times[x][0]; to = times[x][1]; w = times[x][2]; if (from != vert) // 지금 방문한 정점에서 출발하는 간선이 아니면 계산하지 않는다 continue; if (dist[vert] + w &lt; dist[to]) { // 거리를 업데이트할 필요가 있을 때에만 dist[to] = dist[vert] + w; // 거리 업데이트 next_visit.push(make_pair(to, dist[to])); // 다음 방문 정점 큐에 추가 } } } if (!next_visit.empty()) { // 비어있는데 꺼내면 오류 난다 // 모든 정점을 다 방문하고 나서도 큐가 빌 때까지 pop하기 때문에 오류 방지 필요 pair&lt;int, int&gt; next = next_visit.top(); // (정점, 거리) next_visit.pop(); // pop 안 하면 무한반복으로 프로그램이 끝나지 않는다 : 자주 이거 빼먹어서 메모함 vert = next.first; } else // 다음 방문 정점 큐가 비어있다면 종료 break; } for (auto&amp; i : dist) // 계산한 거리 중 최댓값 찾기 max_w = i &gt; max_w ? i : max_w; if (max_w == 100 * 100 * 10) // 찾은 최댓값이 처음에 설정한 초기값과 같다면 연결되지 않거나 경로가 없는 정점이 있음 return -1; return max_w; }}; 다익스트라 제출 결과벨만-포드 풀이거리 벡터의 초기화 값은 위의 다익스트라 풀이에서 설명한 대로 주어진 범위에 맞춰 충분히 큰 값으로 정했다. 다익스트라 풀이와 달리 함수의 앞부분에서 정의해둬야 할 값은 거리 벡터 이외에는 딱히 없다. 내가 느끼기엔 다익스트라로 쓰는 것보다 쉬웠다.정점이 1번부터 시작해 n번까지 있으므로 (정점 수 - 1)만큼 반복하려면 1부터 n 미만까지 반복하는 반복문을 쓰면 된다. 그리고 내부에는 모든 정점에 대해 반복하는 반복문을 쓴다. 안쪽 반복문에서 각 간선과 해당 간선이 거치는 정점들에 대해 거리를 업데이트한다. 이렇게 한 번의 순회가 끝나면 음수 사이클을 찾기 위해 아래에서 동일한 과정을 한 번 더 하는데, 이 문제는 음수 가중치가 주어지지 않으므로 정답을 맞히기만 하는 데에는 딱히 필요 없는 과정이긴 하다. 음수 사이클 확인 과정을 빼고 제출하면 실행 시간이 절반 정도로 줄어든다.#include &lt;vector&gt;// #include &lt;climits&gt;using namespace std;class Solution {public: int networkDelayTime(vector&lt;vector&lt;int&gt;&gt;&amp; times, int n, int k) { // times는 간선들, n은 정점 개수, k는 시작점 // bellman solution int from, to, w; // w는 가중치, vert는 매번의 반복마다 방문하는 정점 int max_w = INT_MIN; // 최댓값을 구해야 하기 때문에 최대한 작은 값으로 초기화 vector&lt;int&gt; dist(n + 1, 100 * 100 * 10); // 정점 번호가 1부터 시작하는 거리 벡터 dist[k] = 0; // 시작점은 거리 0 dist[0] = INT_MIN; // 안 쓰는 정점 표시 // 최단거리 구하기 for (int i = 1; i &lt; n; i++) { // (정점 수 - 1)만큼 반복 for (int x = 0; x &lt; times.size(); x++) { // 모든 간선에 대해 수행 from = times[x][0]; to = times[x][1]; w = times[x][2]; // 항상 최선의 값으로 업데이트한다 dist[to] = dist[to] &gt; dist[from] + w ? dist[from] + w : dist[to]; } } // 음수 사이클 확인 : 없어도 정답 통과 가능 for (int i = 1; i &lt; n; i++) { for (int x = 0; x &lt; times.size(); x++) { from = times[x][0]; to = times[x][1]; w = times[x][2]; // 같은 과정을 수행해서 업데이트가 생기면 음수 사이클 존재 if (dist[to] &gt; dist[from] + w) return -1; } } for (auto&amp; i : dist) // 계산한 거리 중 최댓값 찾기 max_w = i &gt; max_w ? i : max_w; if (max_w == 100 * 100 * 10) // 찾은 거리 중 초기값이 있다면 경로가 없는 정점이 있음 return -1; return max_w; }}; 벨만-포드 제출 결과 1 : 음수 사이클 확인 포함 벨만-포드 제출 결과 2 : 음수 사이클 확인 미포함참고 자료[1] [알고리즘] 벨만-포드 알고리즘 (Bellman-Ford Algorithm)" }, { "title": "[하천 쓰레기 프로젝트] 프로젝트 마무리", "url": "/satinbower-legacy/posts/it-dst-project-end/", "categories": "IT, Data Structure", "tags": "지식, IT, 자료구조, 과제, 프로젝트", "date": "2022-12-03 23:20:00 +0900", "snippet": "목차 이전 글 보기 초안과 달라진 점 구현된 프로젝트 구성 사용한 데이터 결과 및 효과 부족한 점이전 글 보기[하천 쓰레기 프로젝트] 프로젝트 개요[하천 쓰레기 프로젝트] 프로젝트 구현 계획초안과 달라진 점 누적 민원 클래스를 따로 두지 않고 시스템 클래스에 멤버 변수로 포함했다. 기존 계획에는 없었던 드론을 이용한 쓰레기 경로 탐색 기능이 추가되었다.구현된 프로젝트 구성깃허브에서 보기 : dapin1490/waste-complain-system 민원 클래스 민원 id, 민원 사진 파일명, 신고 날짜, 사진 좌표, 포함된 쓰레기의 종류 등을 변수로 가진다. 클래스에 포함된 각종 변수를 반환하는 getter와 쓰레기의 종류 수를 업데이트하는 setter가 있다. 민원의 내용을 사용자가 알아볼 수 있게 출력하는 메소드를 갖는다. 민원 처리 시스템 클래스 민원이 새로 추가될 때 자동으로 id를 부여하기 위해 마지막으로 사용된 id의 다음 id를 멤버 변수로 저장한다. 민원 처리 구역을 구분하기 위해 담당 구역의 좌표 기준점을 멤버 변수로 갖는다. 모든 민원이 저장된 벡터, 각 쓰레기 종류별 누적 민원 벡터, 그리고 조회 기능을 위한 정렬 기준별 멀티맵 멤버 변수 그 외에 시뮬레이터를 좀 더 원활하게 실행하기 위한 변수를 갖는다. 업무 시작, 데이터 로드, 업무 진행 상황 저장, 민원 접수 등의 기능을 구현한 멤버 메소드가 있다. 정렬 기준별 민원 조회를 위한 멤버 메소드 민원 처리를 위해 드론의 쓰레기 수거 경로를 구하는 메소드와 민원 데이터를 처리하는 메소드가 있다. 드론의 경로 탐색을 위한 간선과 그래프 클래스 드론은 공중을 날아 이동하므로 경로에 제한이 없다는 전제 하에, 모든 정점(민원)을 서로 연결하고 각 점 사이의 거리를 가중치로 갖는 그래프를 초기 그래프로 만들었다. 프림 알고리즘을 이용해 최소 신장 트리를 구성하고, DFS 알고리즘으로 방문 순서를 정한다. 모든 정점을 방문해야 하기 때문에 그래프 내의 모든 정점을 최소한의 비용으로 연결하는 최소 신장 트리를 찾아내는 것이 적절하다고 판단했다. 다익스트라는 시작점과 도착점의 방문만을 보장할 뿐 경로상에 거치는 정점이 그래프의 모든 점이 아니므로 사용하지 않았다. 코드로 보기전체 코드가 1000줄이 넘기 때문에 선언 부분만 올린다. 깃허브에 다 있다.class complain { // 민원 클래스private: unsigned id; // 민원을 구분하기 위한 id string pic_name; // 사진 이름(필요시 절대/상대 파일 경로 포함, 사진 크기를 비롯해 사진 파일 자체에 대한 각종 정보는 원본 파일의 정보에 포함된다고 본다) time_t rawtime; // 민원 신고 날짜(time_t) tm comp_date; // 민원 신고 날짜(tm) errno_t is_valid_date; // 민원 신고 날짜가 오류 없이 저장돼있는지 : 비주얼 스튜디오에서 지원하는 오류 코드다 pair&lt;double, double&gt; coordinates; // 사진 좌표 int waste_cnt; // 포함된 쓰레기의 종류 수public: int wastes[5]; // 멤버 변수지만 어차피 getter를 써도 포인터로 전달되어 원본 수정이 가능하니 public 변수로 사용 // 나중에 const를 쓰면 함수에서 사용하는 값을 바꿀 수 없다는 것을 배웠지만 이미 프로젝트를 상당부분 만들어둔 상태였다public: // 기본 생성자 포함 3종류 complain() { pic_name = \"None\"; } complain(unsigned id, string pn, int cdate, double x, double y, int wcnt, int* ws); complain(unsigned id, string pn, int cdate, double x, double y, int wcnt, string ws); unsigned get_id() { return id; } // 민원 id 반환 string get_name() { return pic_name; } // 사진 이름 반환 time_t get_date() { return rawtime; } // 민원 신고 날짜 반환 pair&lt;double, double&gt; get_codi() { return coordinates; } // 사진 좌표 반환(pair) int get_wcnt() { return waste_cnt; } // 포함 쓰레기 종류 수 반환 void rename(string new_name) { pic_name = new_name; } // 사진 이름 변경 void update_wcnt(int num) { waste_cnt += num; } // 포함 쓰레기 종류 수 변경 // 민원 정보 출력 void print();};// 민원 삭제 처리를 할 때 벡터의 remove_if에서 사용하는데, 클래스 내부 함수로 선언하면 오류가 나서 전역 함수로 선언bool is_wcnt_zero(complain c) { if (c.get_wcnt() == 0) return true; return false;}class compl_system { // 하천 쓰레기 민원 처리 시스템private: unsigned latest_id; // 구역의 시작점을 id 0으로 하기 위해 1부터 시작 pair&lt;int, int&gt; area_code; // 지역 코드(위도, 경도 정수 부분) unsigned thresh; // 민원 처리 최소 단위 : 누적된 민원의 수가 이 수보다 클 때 처리. 기본값은 20 vector&lt;vector&lt;complain&gt;&gt; accumed_compls_list; // 쓰레기 분류별 누적 민원 배열 unsigned file_checkpoint; // 전체 민원 파일 어디까지 읽었는지 표시 vector&lt;complain&gt; all_compls; // 전체 민원 벡터 multimap&lt;string, complain&gt; map_comp; // 사진 이름 기준 전체 민원 멀티맵 multimap&lt;double, complain&gt; map_latitude; // 위도 기준 전체 민원 멀티맵 multimap&lt;double, complain&gt; map_longitude; // 경도 기준 전체 민원 멀티맵 multimap&lt;time_t, complain, greater&lt;time_t&gt;&gt; map_cdate_front; // 민원 접수 날짜 기준(최근순) 전체 민원 멀티맵 multimap&lt;time_t, complain&gt; map_cdate_back; // 민원 접수 날짜 기준(오래된순) 전체 민원 멀티맵 // 맵 내림차순(greater) 참고 : https://0xd00d00.github.io/2021/08/22/map_value_reverse.html // 두 민원이 서로 같은지 확인 : 민원 id 확인. 원래는 사진 이름과 민원 날짜 등 민원의 정보를 비교했지만 번거롭고 오류 가능성이 높아서 바꿈 bool is_same(complain&amp; a, complain&amp; b); // 정상 실행 확인 // 특정 분류의 쓰레기 민원이 충분히 많아 처리해도 될만한지 확인 bool is_enough(int waste_code); // 사진 이름순 모든 민원 조회 void view_all(multimap&lt;string, complain&gt;&amp; mc); // 위도, 경도순 모든 민원 조회 void view_all(multimap&lt;double, complain&gt; ml, int code); // 민원 날짜 오름차순 조회 void view_all(multimap&lt;time_t, complain, greater&lt;time_t&gt;&gt; mcf); // 민원 날짜 내림차순 조회 void view_all(multimap&lt;time_t, complain&gt; mcb); // 누적 민원 처리 void clear_compls(int waste_code); // 누적 민원 물리적 처리(드론 경로 탐색 및 생성) void call_drone(vector&lt;complain&gt;&amp; c_list);public: // 기본 생성자 포함 2종류 compl_system(); compl_system(int x, int y); pair&lt;int, int&gt; get_acode() { return area_code; } // 지역 코드 반환 void set_thresh(int n) { thresh = n; } // 누적 민원 처리 기준값 변경 : 구현 부족으로 실제 사용되지는 않음 // 정상 실행 확인 // 시스템 시작 : 사용자에게 지역 코드를 입력받고 기존 데이터 유무 확인, 새 로그 생성 등 void system_on(); // 일부 정상 실행 확인 // 민원 접수 void receive_compl(); // 자동 민원 접수 : 민원 csv 파일 사용하기 위해 만듦 void auto_receive_compl(int cnt = 0); // 기본 실행 확인 // 정렬 기준(sort_by)에 따른 전체 민원 조회(출력하게 할 것이므로 반환값 없음) void view_all(); /*// 우선순위 최하위. 구현하지 않을 가능성 높음 // 미확인 // 검색 기준(search_by)에 따른 특정 민원 검색 void search_compl() { // 가능한 검색 기준 : 사진 이름(오타 불허), 위도, 경도, 접수 날짜 // 벡터 정렬 후 순회 return; } */ // 정상 실행 확인 // 특정 분류의 쓰레기 관련 민원 일괄 처리 : 처리 후 전체 민원 벡터나 다른 맵 등에서 NULL을 제거하는 과정이 필요함 void clear_compls(); // 정상 실행 확인 // 파일에 기록된 데이터를 통한 이전 업무 기록 로드. 매번 새 시스템을 생성할 수는 없으니까. void load_save(); // 정상 실행 확인 // 업무 진행 상황을 파일로 기록. 업무를 종료하거나 중간 저장이 필요할 때 실행. void save_task(); // 미구현 // 승인 대기 목록을 확인하고 관할 구역에 속하는 민원을 추가 접수함 void check_waiting();};사용한 데이터프로젝트를 위해 공유된 전체 수강생 59명의 데이터(csv) 중, csv 파일을 얻을 수 없었던 2개와 파일을 병합하는 과정에서 오류가 발생했던 5개를 제외한 52개의 데이터를 사용했다.먼저 각각의 csv 파일을 판다스(파이썬)를 이용해 하나의 파일로 합치고, 지정된 column 이외의 데이터 / NaN / 불필요한 공백 등을 제거한 후 데이터타입을 지정하여 1차 전처리를 했다. 1차 전처리 파일의 통계를 확인해보니, 위도가 입력되어 있어야 할 열에 경도가 입력되어 있는 등 몇 가지 이상치가 있는 것이 발견되어 이상치를 제거한 2차 전처리 파일을 만들었다.2차 전처리 파일은 에브리타임과 카카오톡 오픈채팅을 통해 다른 수강생들에게도 공유하였다(2022년 12월 4일 오전 12시 25분 기준 11명). [이미지 1] 이상치 처리 데이터 정보 [이미지 2] 이상치 처리 데이터 통계 2차 전처리 파일을 이용해 본 프로젝트에 필요한 형식으로 조작하였다. 사용하지 않는 사진 크기 데이터를 제거하고, 날짜마다 다르게 들어오는 민원을 가정하기 위해 실제 사진이 찍혔을 것으로 예상되는 기간인 2022년 9월 1일부터 2022년 9월 30일까지 랜덤한 날짜를 부여했다. 먼저 만들어 둔 민원 처리 프로그램의 형식에 맞게 각 데이터가 갖고 있는 쓰레기의 종류 수도 추가하였다. 이후 민원의 입력에 바로 사용할 수 있게 column의 순서를 바꾸고 날짜순으로 정렬하여 마무리했다. [이미지 3] 프로젝트용 데이터 정보 [이미지 4] 프로젝트용 데이터 통계 데이터 전처리에 사용한 코드와 원본 데이터 모두 깃허브에서 확인할 수 있다.결과 및 효과결과 및 효과를 서술하기에 앞서, 본 프로젝트에서 의미하는 결과 및 효과에 대해 정의한다. 본 프로젝트의 결과 및 효과는 본 프로젝트를 이용함으로써 얻을 수 있는 이득을 말하는 것으로 크게 유형 효과와 무형 효과로 나뉘며, 유형 효과는 설득력 있는 수치적 근거를 들어 계산할 수 있는 이득을 의미하고 무형 효과는 수치로 계산할 수 없는 이득을 의미한다. 유형 효과 드론의 경로를 먼저 입력한 후 자동으로 운행하게 함으로써 드론 조종 인력의 인건비를 절감할 수 있다. 무형 효과 하천 쓰레기에 대한 민원 처리 과정 대부분을 프로그램이 자동으로 수행하게 함으로써 민원 처리 인력이 다른 업무에 더 집중할 수 있게 한다. 부족한 점 검색 기능 미구현 승인 대기 목록에 저장하는 기능은 구현했지만 시간 문제로 승인 대기 목록을 다시 불러오는 기능은 구현하지 않았다. 누적된 쓰레기 수가 지정치를 넘어서면 자동으로 쓰레기 처리를 권장하는 기능을 구현하고 싶었지만 시간이 부족했다. 누적 민원 처리 기준값을 변경하는 함수는 만들어 뒀지만 사용할 데를 안 만들었다." }, { "title": "[자료구조] 그래프와 다익스트라", "url": "/satinbower-legacy/posts/it-graph-dijkstra/", "categories": "IT, Algorithm", "tags": "지식, IT, 과제, 자료구조, 그래프, 다익스트라, dijkstra, 알고리즘", "date": "2022-11-26 11:15:00 +0900", "snippet": "할 일[과제]이번 숙제는 다음 내용을 포함합니다.1. 그래프 표현 방법(코드 중심)으로 설명합니다. (O)2. 다익스트라 알고리즘을 설명하고, 코드를 구현합니다. (O)3. (옵션) 백준 알고리즘 다음 문제를 풀어봅니다. (X)- 1753 최단경로 : 시간초과- 1238 파티- 1504 특정 최단 경로- 1177 최소비용 구하기4. (옵션) BFS 관련 문제를 풀어 봅니다. (X)[메모]다익스트라 알고리즘은 이 알고리즘을 수행하는 그래프가 연결 그래프일 것을 전제하나?: 그럴 것 같긴 한데. 기본적으로 한 정점에서 다른 모든 정점으로 가는 경로가 있음을 전제하고 있다. 그래프가 연결되지 않아 경로가 없는 경우를 고려하지 않는다.추가) 연결되지 않은 경우는 거리를 무한으로 냅두면 된다.목차 그래프 구현하기 다익스트라그래프 구현하기그래프에 대한 이론적인 설명은 여기에서 볼 수 있다. 이 글에서는 가중치 그래프를 중점으로 다룬다.가중치 그래프는 정점과 간선, 가중치로 구성된다. 이 구성 요소는 그래프를 코드로 구현할 때에도 거의 같다. 각각의 정점이 어떠한 정보를 가져야 한다면 정점을 중심으로 구조체를 구상하면 되고, 정점이 특별한 정보를 갖지 않는다면 간선을 중심으로 구조체를 만드는 방법도 있다. 지난 글인 [자료구조] BFS와 DFS에서는 각 정점이 특정 station으로부터의 거리 값을 갖도록 했기 때문에 정점을 중심으로 구조체를 만들었다. 이번에는 정점이 아무런 정보도 갖지 않는다는 전제로 간선을 중심으로 그래프를 구현하고자 한다.가장 기본 단위가 될 간선 구조체부터 생각해 보자. 무방향 그래프와 방향 그래프의 간선 구조체를 따로 만들기보다는, 기본 단위인 만큼 두 그래프에 모두 사용할 수 있도록 방향이 있는 간선을 만드는 게 좋을 것 같다. 방향 그래프에는 그대로 사용할 수 있고, 무방향 그래프를 만들 때는 서로 반대 방향의 간선 2개를 한번에 추가하면 된다. 따라서 이 구조체가 가져야 할 정보는 시작점과 종점, 가중치이다.시작점과 종점, 다시 말해 각 정점은 간단하게 양수인 정수형의 ID로 구분한다고 하자. 가중치는 지금까지 정수로 사용해오긴 했지만, 때에 따라 실수를 사용하고 싶을 수도 있을 것이다. 혹은 사용자가 정의한 새로운 자료형을 사용할 수도 있다. 이럴 때 필요한 것이 템플릿이다(템플릿에 대해 새로 배웠기 때문에 같이 활용할 목적일 뿐이다). 정리하자면 방향이 있는 간선 구조체를 만들고, 간선의 시작점과 종점은 unsigned int로, 가중치는 템플릿으로 만들 것이다.아래는 간선 구조체 코드이다.template &lt;typename T&gt;struct Edge { T w; // 가중치 unsigned from; // 시작점 unsigned to; // 종점};다음은 저 간선을 이용한 그래프를 만들어야 한다. 그래프는 간선의 모임으로 만들어지며, 몇 가지 연산이 필요하다. 지금은 아주 기본적인 연산만 만들 것이다. 방향이 있는 간선과 방향이 없는 간선을 추가하는 연산이다. 위에서 만든 간선 구조체에 템플릿이 사용되었기 때문에 그래프 클래스도 템플릿을 사용해야 한다.간선 구조체가 방향이 있기 때문에 그래프에 방향이 있는 간선을 추가하는 연산은 1개의 간선 구조체를 추가하면 되고, 방향이 없는 간선을 추가할 때는 서로 반대 방향의 간선 2개를 추가하면 된다.그래프 클래스 코드는 아래에 있다. 교수님의 코드를 참고하여 작성했다.코드를 보기에 앞서 유의할 점은 이 그래프 클래스는 정점의 수가 제한되어 있다는 것이다. 처음부터 정점의 총 개수를 알고 그리는 그래프이다. TGraph::print()에서 정점마다 연결된 다른 정점을 출력하는 반복문을 실행하기 위해 정점의 개수를 알고 있어야 한다. 그리고 모르는 정점이 추가되지 않도록 하기 위해 간선을 추가하는 연산에서 정점의 ID를 확인한다.사실 이 그래프 클래스는 이후에 다익스트라 알고리즘에 사용하는 것이 목적이기 때문에 그래프를 구성하는 모든 정점이 최소 하나 이상의 간선으로 연결되어 있을 것을 전제한다. 그런 의미에서도 정점의 수를 제한하는 것으로 보인다. 다익스트라 알고리즘을 사용하지 않고 그래프라는 개념 자체를 구현하고자 한다면 정점의 수가 아니라 정점의 ID 최댓값을 저장하면 된다.enum class _error : int { shut_down, ValueErrorInt, ValueErrorChar, UnknownError };// C++ 에러 메시지 참고 : https://learn.microsoft.com/ko-kr/cpp/error-messages/compiler-errors-1/c-cpp-build-errors?view=msvc-170void error(_error code, string message=\"\") { if (!message.empty()) cout &lt;&lt; \"error: \" &lt;&lt; message &lt;&lt; \"\\n\"; switch (code) { case _error::shut_down: cout &lt;&lt; \"프로그램 비정상 종료\\n\"; break; case _error::ValueErrorInt: // 잘못된 입력 - int cout &lt;&lt; \"ValueErrorInt: int 값이 입력되어야 합니다.\\n\"; break; case _error::ValueErrorChar: // 잘못된 입력 - char cout &lt;&lt; \"ValueErrorChar: char 값이 입력되어야 합니다.\\n\"; break; default: cout &lt;&lt; \"UnknownError: 알 수 없는 오류\\n\"; } exit(1); // 프로그램 비정상 종료}template &lt;typename T&gt;class TGraph {private: unsigned v; // 정점 수 vector&lt;Edge&lt;T&gt;&gt; edges; // 그래프가 갖는 간선들public: // 생성자 TGraph() { this-&gt;v = 0; } TGraph(unsigned v) { this-&gt;v = v; } // 함수 정의에 쓰인 const : 이 함수 안에서 쓰는 값들을 변경할 수 없다 unsigned size() const { return v; } // 그래프가 갖는 정점의 수를 반환 auto&amp; edges_from() const { return this-&gt;edges; } // 그래프가 갖는 간선들을 반환 // 특정 정점에 연결된 간선들만 반환 auto edges_from(unsigned i) const { // 여기에 &amp; 쓰면 결과가 제대로 반환이 안 됨. 근데 이유는 모름.. vector&lt;Edge&lt;T&gt;&gt; edge_from_i; for (auto&amp; e : edges) { if (e.from == i) edge_from_i.push_back(e); } /*for (int idx = 0; idx &lt; this-&gt;edges.size(); idx++) { if (this-&gt;edges[idx].from == i) edge_from_i.push_back(edges[idx]); }*/ return edge_from_i; } void add(Edge&lt;T&gt;&amp;&amp; e) { // 방향 간선 추가 if (e.from &gt; 0 &amp;&amp; e.from &lt;= this-&gt;v &amp;&amp; e.to &gt; 0 &amp;&amp; e.to &lt;= this-&gt;v) this-&gt;edges.push_back(e); else error(_error::shut_down, \"정점 범위 초과\"); return; } void add_undir(Edge&lt;T&gt;&amp;&amp; e) { // 무방향 간선 추가 if (e.from &gt; 0 &amp;&amp; e.from &lt;= this-&gt;v &amp;&amp; e.to &gt; 0 &amp;&amp; e.to &lt;= this-&gt;v) { this-&gt;edges.push_back(e); this-&gt;edges.push_back(Edge&lt;T&gt;{e.w, e.to, e.from}); } else error(_error::shut_down, \"정점 범위 초과\"); return; } void print() { // 그래프 출력 for (int i = 1; i &lt;= v; i++) { cout &lt;&lt; \"# \" &lt;&lt; i &lt;&lt; \" : \"; vector&lt;Edge&lt;T&gt;&gt; edge = this-&gt;TGraph::edges_from(i); for (auto&amp; e : edge) cout &lt;&lt; \"(\" &lt;&lt; e.to &lt;&lt; \", \" &lt;&lt; e.w &lt;&lt; \") \"; cout &lt;&lt; \"\\n\"; } return; }};다익스트라다익스트라 알고리즘은 주어진 연결 그래프에서 최단경로를 찾는 것이 목적인 알고리즘이다. 하나의 시작점을 기준으로 하며, 그 점으로부터 다른 모든 점까지 도달하는 비용의 최솟값을 구한다. 시작점에서 가장 가까운 곳부터 시작해 정점을 하나씩 방문하며 알아낸 비용의 최솟값을 이용해 또다른 정점으로의 최소 비용을 알아내는 방식이다. 모든 경로에는 사이클이 없어야 한다지만 자동으로 사이클이 생기지 않는 경로를 찾게 되니 굳이 검사할 필요는 없다.다시 한 번 자세히 알고리즘 수행 과정을 보자.필요한 것은 시작점과 시작점으로부터의 거리를 저장할 선형 자료구조(배열, 벡터 등 종류 상관 없음)이다. 시작점을 방문하여 시작한다. 시작점에서 나머지 모든 정점까지의 거리를 계산하되, 간선이 직접 연결된 경우에만 거리를 계산하고, 간선이 직접 연결되지 않은 정점은 거리를 무한으로 간주한다. 계산된 거리 중(무한 포함)에서, 그리고 아직 방문하지 않은 정점 중에서 가장 가까운 곳으로 이동한다. 해당 정점에서 다시 거리를 계산해야 한다. 지금 방문한 정점에서 갈 수 있는 모든 정점에 대해, 앞서 1번에서 계산했던 값과, 지금 방문한 정점을 거쳐 그곳으로 가는 거리를 비교해 더 작은 쪽으로 업데이트한다. 업데이트된 거리 중에서, 그리고 아직 방문하지 않은 정점 중에서 가장 가까운 곳으로 이동한다. 이후 모든 정점을 방문할 때까지 3번과 4번을 반복한다. 일반화 : n번째 방문한 정점에서 갈 수 있는 다른 모든 정점에 대해, n-1번째 방문한 정점에서 계산한 거리와 현재 정점에서 해당 정점으로 가는 거리를 비교하여 더 작은 쪽을 적용한다. 시작점에서 시작할 때는(n=1) n-1번째 정점이 없으므로 모든 거리를 무한으로 간주한다.나는 세 가지 다익스트라 함수를 만들었다. 첫 번째는 시작점으로부터 목적지까지 최소 비용만을 계산하고, 두 번째는 첫 번째의 결과에 더해 해당 경로로 가기 위해 직전에 방문해야 할 정점을 같이 구하고, 세 번째는 두 번째에서 구한 정보들을 이용해 시작점부터 모든 정점으로의 완전한 경로를 구한다. 함수의 이름은 각각 dijkstra, dijkstra_path, dijkstra_fullpath이다. 전체 코드는 깃허브에서 볼 수 있다.그러나 내가 쓴 다익스트라 코드는 한 가지 과정에서 상당히 비효율적으로 동작한다. 다음에 방문할 정점을 고르기 위해서는 거리가 가장 짧으면서 아직 방문하지 않은 정점을 찾아야 하는데, 이 과정을 매번 우선순위 큐에 모든 간선을 넣었다 빼면서 수행하고 있다. 아래 있는 예제는 간단하기 때문에 이런 코드로도 금방 답이 나오지만 데이터의 양이 조금만 커져도 내 코드는 결과를 내기까지 상당히 오랜 시간이 걸릴 것이다. 사실 이 문제는 힙을 좀 더 섬세하게 다루면 금방 해결된다. 이번엔 내가 시간이 부족하고, 이해도 부족해서 그러지 못했을 뿐이다. 요점은 이 코드에는 결함이 있음을 감안하고 봐달라는 말이다.결함이 있긴 하지만, 남이 쓴 코드를 이해하는 좋은 방법 중 하나는 예시를 보는 것이다. 그래서 예시 그래프도 준비했다.22.12.04 수정다익스트라 함수에 사용된 우선순위 큐의 사용 방법을 약간 바꿨다. 여전히 백준 문제는 통과되지 않는 것을 봐선 어딘가 더 효율적으로 쓸 수 있는 방법이 있는 모양이지만 지금 내가 이해한 선에서 쓸 수 있는 만큼 썼다. [이미지 1] 다익스트라 예시 그래프위 그래프를 이용하여 세 가지 다익스트라 함수를 실행한 결과는 이 링크에서 볼 수 있다.코드의 길이가 길어 여기에 모든 코드를 올리지는 않고, 내가 구현한 다익스트라 함수의 모든 기능을 포함하는 dijkstra_fullpath 함수만 올리겠다.struct cmp { // 다익스트라 우선순위 큐 비교 연산자 : 가중치가 적고 정점 번호가 적은 것을 우선으로 함 bool operator()(pair&lt;unsigned, unsigned&gt; a, pair&lt;unsigned, unsigned&gt; b) { if (a.second == b.second) return a.first &gt;= b.first; else return a.second &gt; b.second; }};// 응용 : 다익스트라 경로 탐색 - 모든 경로 표시vector&lt;pair&lt;unsigned, list&lt;unsigned&gt;&gt;&gt; dijkstra_fullpath(unsigned s) { // s는 시작점 vector&lt;pair&lt;unsigned, unsigned&gt;&gt; d(v + 1, make_pair(numeric_limits&lt;unsigned&gt;::max(), s)); // 저장용 거리 벡터. 정점 번호가 1부터 시작함. (최소 비용 거리, 직전 경로 정점) vector&lt;bool&gt; visited(v + 1, false); // 방문 여부 초기화 priority_queue&lt;pair&lt;unsigned, unsigned&gt;, vector&lt;pair&lt;unsigned, unsigned&gt;&gt;, cmp&gt; next_visit; // 다음에 방문할 정점 : (정점, 거리) vector&lt;pair&lt;unsigned, list&lt;unsigned&gt;&gt;&gt; full_path(v + 1); // 모든 경로 표시 벡터 : (거리, 경로) unsigned vert = s; // 이제 방문할 정점 : 아직 시작하지 않았으므로 시작점으로 초기화 visited[0] = true; // 안 쓰는 인덱스 방문할 일 없게 미리 표시 d[s].first = 0; // 시작점은 거리 0 next_visit.push(make_pair(s, d[s].first)); while (!next_visit.empty()) { // 다음 방문 정점 큐가 비어있지 않을 동안 if (!visited[vert]) { visited[vert] = true; // 정점 방문 vector&lt;Edge&lt;T&gt;&gt; v_edge = edges_from(vert); // 정점에 연결된 간선 가져오기 for (auto&amp; e : v_edge) { if (d[vert].first + e.w &lt; d[e.to].first) { // 거리를 업데이트할 필요가 있을 때에만 d[e.to].first = d[vert].first + e.w; // 거리 업데이트 d[e.to].second = vert; // 직전 방문 정점 업데이트 next_visit.push(make_pair(e.to, d[e.to].first)); } } } if (!next_visit.empty()) { pair&lt;unsigned, unsigned&gt; next = next_visit.top(); // (정점, 거리) next_visit.pop(); vert = next.first; } } // 위에서 알아낸 최소 비용 거리와 직전 방문 정점을 이용해 모든 경로 찾기 // 도착점인 i로부터 시작점인 s까지 거슬러 올라가는 방식으로 탐색 for (unsigned i = 1; i &lt;= v; i++) { unsigned dest = d[i].second; // 시작점 s에서 정점 i를 찾아가는 경로상에서, i를 방문하기 직전의 정점 full_path[i].first = d[i].first; // s에서 i로 가는 최소 비용 full_path[i].second.push_front(i); // 도착점 i 먼저 리스트에 추가 while (dest != s) { // 시작점 s에 도달하면 종료 full_path[i].second.push_front(dest); // 지금 방문하는 점을 경로 맨 앞에 추가 dest = d[dest].second; // 시작점에서 지금 방문한 점으로 오기까지, 직전 방문 정점을 다음 방문지로 지정 } if (i != s) // 위의 반복문은 시작점 s를 다음 방문지로 지정하면 종료되기 때문에 경로에 추가되지 않으므로, 현재 도착점이 시작점과 다르다면 경로에 추가해야 함 full_path[i].second.push_front(s); } return full_path;}" }, { "title": "튜빙밴드와 자가체중을 이용한 홈트운동", "url": "/satinbower-legacy/posts/knowledge-home-training/", "categories": "기타 지식", "tags": "지식, 근골격계", "date": "2022-11-14 20:44:00 +0900", "snippet": "강의 정보11월 대학 비교과 프로그램 온라인 건강교육의 내용을 정리한 것이다. 첨부된 이미지 자료의 출처는 모두 이 강의이다.튜빙밴드구매처 추천 : http://melkinsports.com/category/%ED%8A%9C%EB%B9%99%EB%B0%B4%EB%93%9C/246/운동 프로그램 예시 초보자 기본적으로 일주일에 한 부위를 두 번 정도 반복하는 것이 가장 좋다. 초보자 중에 욕심을 내서 매일 모든 운동을 하려고 시도하는 사람이 있는데, 힘들어서 얼마 못 간다. 운동 후에는 쉴 시간이 필요하다. 점증부하의 원리에 의해 세트를 거듭할수록 강도는 강해져야 한다. 처음엔 가볍게 많이, 뒤로 갈수록 무겁고 적게. 여자는 이렇게 운동한다고 근육 튀어나오고 그럴 일 없고, 근력과 근육의 탄성이 좋아진다. 그리고 맵시가 좋아진다. 지방이 빠지면서 몸매가 예뻐진다. [이미지 1] 초보자 운동 프로그램 - 이중분할 중급 이상 [이미지 2] 중급자 이상 운동 프로그램 - 3중분할, 더블3중분할 부위별 운동척추 단계별 신전운동요즘 인간들의 일상은 모두 굴곡된 자세로 이루어진다. 그래서 목부터 요추까지 다 눌려있다. 그게 계속되면 디스크가 (눌리는 방향에 따라) 안쪽이나 바깥쪽으로 쏠리고, 터지기도 한다. 디스크가 바깥쪽으로 터지는 게 젊은 사람들이 많이 걸리는 추간판 탈출증이고, 바깥쪽이 좁아지는 것은 나이든 사람에게 많이 생기는 척추관협착증이다.신전 운동은 아프지 않을 만큼만 해야 한다. 약간의 미미한 통증이 있을 수는 있는데, 저리거나 아프다면 멈춰야 한다. 통증이 없는 범위 내에서 움직여야 한다. 척추 신전운동 과정 이미지 1. 이미지처럼 엎드린다 2. 다른 곳은 움직이지 말고 고개만 들어올린다. 위 동작까지 했을 때 허리에 무리가 없고 다리가 저리지 않다면 다음으로 넘어간다. 3. 위와 같이 다리도 올린다. 여기까지 한 후 1번 자세로 돌아가 다음 동작을 한다. 4. 팔을 쭉 펴고, 고개를 올리고, 다리를 든다. 4번의 자세에서 좌우로 몸을 트는 것까지 해도 된다. 잠자리에서 일어났을 때 이런 운동을 자주 해줘야 허리를 다치지 않고 건강하게 유지할 수 있다.추가로, 아래의 운동도 하면 좋다. 부록. 크런치 자세 복근 운동에 좋다. 추간판 탈출증이 일어나지 않고 복근을 강화시켜준다.장요근, 대퇴직근 스트레칭많이 앉아있거나 좌식 생활을 오래 하면 장요근이 타이트해진다. 장요근은 대요근, 장골근, 소요근을 합쳐 이르는 말인데 이 근육들이 당겨지면 척추전만이 되고 요통의 원인이 된다. 이 근육들을 이완시켜야 한다. 장요근, 대퇴직근 스트레칭 과정 [참고] 장요근 이미지 1. 이미지와 같이 앉는다. 2. 팔을 들어올린 후 상체를 앞으로 전진시킨다. 이때 가능하다면 뒤쪽으로 놓은 다리를 올려도 좋다. 3. 앞으로 놓은 다리 쪽으로 몸을 기울여 회전시킨다. 중심 잡기가 힘들어 넘어질 수 있으니 벽에 손을 짚는다.대흉근, 소흉근 스트레칭골프 치는 사람들이 이런 스트레칭을 많이 한다. 대흉근, 소흉근 스트레칭 과정 [참고] 대흉근 이미지 1. 준비 자세 2. 한쪽 손으로 목 뒤를 잡는다. 3. 목을 잡은 쪽 팔을 들어올린다. 4. 다시 팔을 내린다. 3번과 4번을 반복하여 몸을 회전시킨다. 목 신전운동 첫 번째 목 신전운동 과정 1. 첫 번째 자세 2. 두 번째 자세 편의상 순서를 두었지만 두 자세 중 어느 쪽을 먼저 해도 상관 없다. 고개와 팔을 반대로 움직이면서 두 동작을 반복하면 된다. 날개뼈와 경추에 좋으니 수시로 해야 한다. 두 번째 목 신전운동 과정 1. 수건을 꼬아 목에 감고 양끝을 손으로 잡는다. 2. 팔을 앞으로 밀어내면서 이미지와 같이 고개를 들어올린다. 2번 동작을 한 후 고개를 내릴 때는 팔을 밀어내듯이 하지 않는다. 이후 두 동작을 반복한다. 이 운동을 하면 목이 부드러워진다.척추 신전운동부터 목 신전운동까지, 오래 자거나 앉아있는 사람들은 꼭 하길 바란다고 교수님이 설명하셨다.가슴운동(튜빙 프레스)튜빙 밴드는 5가지 색깔로 구분되어 있으니 각자 수준에 맞는 강도의 밴드를 사용하면 되고, 두 개 이상의 밴드를 조합하여 사용해도 된다. 도어 앵커를 이용해 밴드를 문에 걸고 사용할 수 있다. 참고. 강의자료 이미지벤치프레스를 할 때 팔을 어깨와 나란히 올리지 않으며 상완과 전완이 수직하게 한다. 누울 때는 허리를 약간 들되 너무 들지 않는다. 바를 내릴 때는 가슴 정중앙에 오도록 한다. 튜빙 프레스 과정 이미지 1. 양손을 앞으로 뻗어 모은다. 2. 양손을 뒤쪽으로 움직여 팔을 벌린다. 위 두 자세를 반복하면 된다. 양손의 밴드가 옆에서 보면 일치하도록 똑같이 움직여야 한다. 이 운동 자세에서 중요한 점은 허리가 둥글게 뒤로 빠져있으면 안 되고, 무릎은 1번의 이미지와 같은 각도를 유지해야 한다는 것이다. 그 상태로 코어에 힘을 주고 몸을 고정한 상태로 팔을 움직여야 한다.자가체중 가슴운동(Push up)주의사항 : 손목이 꺾일 수 있으니 푸시바를 사용하면 좋다. Push up 강의자료 이미지등운동(튜빙 풀다운)참고 : 튜빙밴드를 이용한 다양한 등운동 튜빙 풀다운 과정 1. 튜빙 밴드를 문 위쪽에 걸고 바닥에 앉아 양 다리로 몸을 지지하고 팔을 뻗어 밴드를 잡는다. 오른쪽 그림은 참고 이미지이다. 2. 튜빙 밴드를 아래로 당긴다. 위 두 동작을 반복하되, 팔을 제외한 상반신과 하체가 움직이지 않아야 한다.자가체중(가슴+어깨+삼두) Bench Dips 참고. 강의자료 이미지주의 : 몸이 벤치에서 멀어지면 전면삼각근이 찢어질 수 있으니 벤치에 딱 붙어서 해야 한다.아주 좋은 운동이다. 어깨, 주관절 재활할 때 많이 하는 운동이다. 다리를 의자에 올려서 체중이 더 실리게 할 수 있다.튜빙 이두운동 참고. 이두근 그림 튜빙컬 다음 두 동작을 반복하면 된다. 벽과 가까워 가동범위가 약간 짧다. 1. 문 아래에 튜빙밴드를 걸고, 이미지와 같이 문에서 약간 떨어져 서서 손바닥을 위쪽으로 하고 팔을 수직에 가깝게 굽혀 밴드를 잡는다. 2. 몸의 다른 부분은 움직이지 않고 전완을 들어올린다. 튜빙 얼터네이트 컬 다음 두 동작을 반복하면 된다. 한 팔로 밴드의 양끝을 잡고 운동하는 동작으로, 매번 반복할 때마다 팔을 바꿔도 좋고, 일정 횟수마다 팔을 바꿔도 좋다. 1. 문 아래에 튜빙밴드를 걸고, 문에서 떨어져 서서 손바닥을 위쪽으로 하고 적당한 높이로 밴드를 잡는다. 2. 몸을 움직이지 않고 팔을 들어올린다. 튜빙 삼두운동 참고. 삼두근 그림 튜빙 원핸드 푸시다운(+튜빙 푸시다운) 아래 두 동작을 반복하면 된다. 튜빙 푸시다운은 양손으로 밴드의 양끝을 각각 잡고 튜빙 원핸드 푸시다운과 같은 동작을 하면 되기 때문에 편의상 원핸드 방식만 보자. 주의 : 팔을 올릴 때 상완이 따라가면 안 된다. 1. 문 위에 튜빙밴드를 걸고 바닥에 무릎을 꿇고 상체를 약간 기울여 앉는다. 손바닥이 아래를 향하게 한 손으로 밴드의 양끝을 잡고, 다른 팔을 상완 위에 올려 지지한다. 2. 몸의 다른 부분은 움직이지 않고 팔을 아래로 내린다. 튜빙 어깨운동어깨운동을 하면 어깨 힘이 세지고 라인이 좋아진다. 참고. 삼각근 그림 튜빙 숄더 프레스 아래 두 동작을 반복하면 된다. 1. 문 아래에 튜빙밴드를 걸고 문을 등지고 선다. 양손에 밴드를 잡고 손이 위를 향하게 하여 팔을 양쪽으로 벌린다(어깨는 수직보다 약간 아래). 2. 몸의 다른 부분은 움직이지 않고 팔을 위로 뻗어올리며 모아준다. 튜빙 프론트 레이즈 아래 두 동작을 반복한다. 1. 문 아래에 튜빙밴드를 걸고 손바닥이 아래로 향하게 하여 양손으로 밴드를 잡고 선다. 2. 한 팔씩 번갈아가며 위로 들어올린다. 팔을 쭉 뻗은 상태로 약간만 구부려서 힘을 주고 올리면 된다. 튜빙 레터럴 레이즈 1. 문 아래에 튜빙밴드를 걸고 손바닥이 아래로 향하게 하여 양손으로 밴드를 잡고 선다. 2. 팔꿈치를 구부려 팔을 양 옆으로 벌리면서 들어올린다. 2번 동작을 덤벨로 하는 것을 정면에서 보면 위와 같다. 팔꿈치를 굽히고, 덤벨은 몸 안쪽으로 약간 기울어진다. 팔은 최대 귀 높이까지만 올린다. 대퇴근력 강화 운동 참고. 대퇴근 이미지 튜빙 스쿼트 1. 문 아래에 튜빙밴드를 걸고 문을 등지고 서서 양손에 밴드를 잡은 상태로 양 팔을 위로 뻗는다. 2. 팔을 양옆으로 벌려 내리면서 엉덩이를 내려 앉는다. 무릎의 상태에 따라 앉는 높이를 조절한다. 불가리안 스플릿 스쿼트(★ 교수가 제일 선호하는 운동!) 이 운동은 한쪽 대퇴사둔근에 체중이 모두 실리기 때문에 기본 스쿼트보다 효과가 좋고, 대둔근에도 좋다. 의자와의 거리가 멀수록 대둔근에 자극이 많이 가고, 가까울수록 대퇴사둔근에 자극이 많이 간다. 바퀴가 있는 의자를 사용하여 응용할 수 있다. 하체가 너무 얇거나 빈약한 사람, 오래 앉아있는 사람에게 추천한다. 1. 작은 의자를 뒤에 놓고 한손을 벽에 짚고, 벽에 짚은 손 반대 방향 발을 뒤로 뻗어 의자에 얹는다. 2. 벽에 짚지 않은 손을 위로 들고 무릎을 구부려 내려가고 올라오는 것을 반복한다. Back muscle 운동요통 완화, 개선, 치료 목적으로 하는 운동이다. 크로스 신전운동 1. 엄지를 위로 향하게 하여 바닥에 엎드린다. 2. 서로 다른 방향의 팔과 다리를 함께 들어올린다. 양쪽을 번갈아가며 한다. 슈퍼맨 운동 1. 엄지를 위로 향하게 하여 바닥에 엎드린다. 2. 사지를 함께 들어올린다. 이때 천천히 네 단계로 나누어 올리고 내리면 더 효과적이다. 버드독 운동 요통 환자들이 많이 하는 운동이다. 중심을 잡아야 하기 때문에 고유수용성 감각 기능도 좋아진다. 1. 손바닥과 무릎을 바닥에 대고 기어가는 듯한 자세를 한다. 2. 엉덩이와 어깨에 힘을 주고 허리가 틀어지지 않게 서로 반대 방향의 팔과 다리를 올려 쭉쭉 뻗어준다. 양쪽을 번갈아가며 반복한다. 코어 운동플랭크 자세는 오래 한다고 좋은 게 아니다. 10초 버티고 10초 쉬는 것만 반복해도 된다. 사이드 플랭크, 사이드+프론 플랭크 1. 팔꿈치를 바닥에 대고 상완과 발끝을 세워 엎드린다. 2. 엉덩이를 들어올린다. 3. 한쪽 팔을 밖으로 꺼내 몸을 옆으로 세운다. 다리는 자연스럽게 옆으로 눕힌다. 이 다음 동작에 따라 사이드 플랭크와 사이드+프론 플랭크가 구분된다. 4-1은 사이드 플랭크, 4-2는 사이드+프론 플랭크이다. 4-1. 꺼낸 팔을 다시 몸 안쪽으로 집어넣으며 세웠던 몸을 내린다. 다리는 그대로 고정하고 팔을 꺼내고 넣는 동작을 반복한다. 4-2. 꺼낸 팔을 다시 몸 안쪽으로 집어넣으며 세웠던 몸을 내리고 다리도 원래대로 돌린다. 다리의 움직임과 함께 팔을 꺼내고 넣는 동작을 반복한다. 이 동작이 힘들면 무릎을 바닥에 대고 한다. 참고. 순환식 코어운동순환식 코어운동 이미지에서 5번 동작은 코어를 테스트할 때에도 한다. 팔을 뻗은 상태로 흔들림이 없어야 하며, 코어가 약한 사람은 팔을 뻗는 순간 허리가 돌아가거나 자세가 무너진다. 참고. 코어 강화 운동, 플랭크 응용 동작위의 코어 강화 운동 동작 중, 서로 다른 방향의 팔과 다리를 들어올리는 동작(초록색 옷)이 제일 힘들다.마무리 요즘 인간들은 굴곡된 자세로 오래 앉아있으니 운동 안 하면 반드시 근골격계 질환이 생긴다. [이미지 1]의 심폐체력운동은 HIIT 운동으로 단시간에 큰 효과를 볼 수 있음이 과학적으로 입증된 운동이다. 근력 운동은 부위별로 로테이션을 한다. 일주일에 한 부위를 두 번씩 하도록 한다. 학생들이 건강을 잘 유지하고 강화시켜서 삶의 질을 높이기 바란다." }, { "title": "근골격계에 대한 이해와 인체 움직임의 원리", "url": "/satinbower-legacy/posts/knowledge-bone-and-muscle/", "categories": "기타 지식", "tags": "지식, 근골격계", "date": "2022-11-13 21:01:00 +0900", "snippet": "강의 정보11월 대학 비교과 프로그램 온라인 건강교육의 내용을 정리한 것이다. 첨부된 이미지 자료의 출처는 모두 이 강의이다.근골격계에 대한 이해와 인체 움직임의 원리* 뼈의 기본 단위와 그 조직에 대한 설명은 이해를 못해서 안 썼음.근골격계의 기능 몸의 지지 및 보호 인체의 움직임 미네랄의 항상성 유지(칼슘, 인) 혈구 생성(조혈 기능) 중성지방 저장(에너지원)골수뼈의 중심부 공간에 가득 차 있는 결체질의 물질. 적색골수와 황색골수가 있는데, 적색골수는 적혈구와 백혈구를 만들고, 황색골수는 중성지방의 저장을 맡는다. 골수 검사는 몸에서 혈구 생성에 문제가 생겼을 때, 골반 뼈와 같은 큰 뼈에서 적색골수를 뽑아내 골수의 기능과 비정상적인 병변을 확인하는 것이다.백혈병 : 골수에서 비정상적인 세포들이 과도하게 증식해서 정상적인 혈구 생성이 억제되는 병빈혈(백혈구 감소증) : 골수 내 조혈모세포가 고갈되어 골수 기능의 부전이 야기되는 병뼈 조직을 이루는 세포 뼈조상세포 → 뼈모세포 → 뼈세포 → 뼈파괴세포(파골세포) 뼈모세포 : 뼈 사이 바탕질을 이루는 유기질을 합성 뼈세포 : 완전히 발육된 뼈의 주세포 뼈파괴세포 : 무기질과 유기질 성분을 분해하고 제거하여 뼈의 흡수를 촉진뼈모세포와 뼈파괴세포의 균형 뼈모세포 &gt; 뼈파괴세포 : 골극 발생. 골극이란 기계적 스트레스나 염증성 자극에 의해 골의 변연부에 생성하는 골성 융기. 뼈모세포가 뼈파괴세포보다 더 활성화되어 정상적인 뼈보다 더 많은 유기물질이 침착되어 생김. 뼈파괴세포 &gt; 뼈모세포 : 뼈의 강도가 약해져 골절이 일어나기 쉬운 상태인 골다공증 발생. 뼈파괴세포가 뼈모세포보다 활성화되어 뼈의 양이 감소하고 질적인 변화가 일어나 뼈의 강도가 약해진다. 가장 널리 사용되는 골다공증 치료제는 뼈파괴세포의 기능을 떨어뜨리고 수를 줄여 뼈의 파괴를 막는다.뼈 스캔골격계 질환에 대한 예민도와 해상력이 좋은 핵의학 영상 검사. 뼈의 신생 형성이 활발한 부위에 섭취되는 방사성 의약품을 주사하여 일정 시간이 지난 후에 이 약품이 전신의 골격에 섭취되는 것을 특수한 장비를 이용하여 영상화한다.뼈의 신생 형성이 활발한 부위(암의 뼈 전이, 골절, 인대/힘줄 손상으로 뼈가 자극되는 부위, 대사성 질환에 의해 뼈의 무기질 대사가 변화하는 곳)에서 높은 섭취 형태를 보인다.뼈를 형성하는 뼈모세포의 활동을 영상화해서 뼈의 병변을 발견하는데, 단순 방사선 촬영보다 예민하다. 3~5% 정도의 무기질량 변화만 있어도 병변을 관찰할 수 있기 때문에 병변의 조기 관찰에 용이하다.골격계를 이루는 뼈골격계를 이루는 뼈는 중추골격, 사지골격, 이음골격으로 이루어진다. 중추골격(80개) : 두개골(8), 안면골(14), 설골(1), 이소골(6), 척추(26), 흉골(1), 갈비뼈(24) 두개골(skull) : 머리의 골격으로, 인체에서 가장 복잡한 골격구조. 뇌, 특수감각기와 구강, 비강을 지지하며 머리뼈(Cranium)와 얼굴뼈(Facial bone)로 이루어진다. 머리뼈 : 전두골(이마뼈), 후두골(뒤통수뼈), 두정골(마루뼈), 측두골(관자뼈), 접형골(나비뼈), 사골(벌집뼈) 얼굴뼈 : 비골(코뼈), 상악골(위턱뼈), 하악골(아래턱뼈), 관골(광대뼈), 누골(눈물뼈), 구개골(입천장뼈), 아래코선반(2개), 사골(보습뼈) 척추(33개) : 경추(7), 흉추(12), 요추(5), 천추(5 in 1), 미추(3~4 in 1). 각 뼈는 척추 원판에 의해 분리된다. 목이 아무리 길든 짧든 포유류의 경추는 7개로 일정하다. [이미지 1] Vertebral Column 척추관 [이미지 2] 아이와 어른의 척추관 흉추와 천추 굴곡은 1차 굽이라고 하여 태아기에 형성되어 성인까지 유지되고, 경추와 요추의 굴곡은 2차 굽이라고 하여 각각 아기가 목을 가눌 때, 걷기 시작할 때 형성된다. 비정상적 척추굽이 : 척추측만증, 척추후만증, 척추전만증 척추측만증 : 척추가 옆으로 휘는 것. 가장 흔하며 여성에서 조금 더 빈번하다. 보통 하나 이상의 척추뼈의 양쪽 판이 불균등하게 성장함에 따라 발생하고 천식이나 기흉 등에서 흔히 관찰된다. 척추후만증 : 등뼈의 커브가 지나치게 많이 굽은 경우. 곱사등, 곱추라고 부르며 골다공증 환자에서 흔히 발생한다. 척추전만증 : 허리뼈의 커브가 지나치게 많이 굽은 경우. 임신한 여성에게 일시적으로 발생할 수 있고, 병리적인 원인에 의해서도 발생할 수 있다. 척수 : 척추 내에 위치하는 중추신경의 일부로 뇌와 연결되어 있다. 아래로 갈수록 가늘어지며 31쌍의 감각 및 운동 신경을 포함하고 있다. 보통 윗부분은 호흡과 팔의 움직임을 조절하고, 중하부는 몸통과 다리 움직임, 성기능과 관계가 있다. 척추 추간판(척추 사이 원반) : 척추뼈 사이에 존재하며 척추관 전체 길이의 25% 정도를 차지한다. 원반의 중앙부에는 젤라틴 상태의 수액이 있고 주변부는 섬유성 연골로 되어 있다. 강한 관절을 형성하고, 척추의 다양한 움직임을 가능하게 하며 수직으로 가해지는 충격을 흡수한다. 만약 원반의 수액이나 섬유의 일부가 탈출하면 이를 추간판 탈출증, 척추 디스크라고 한다. 요추에서 척추 디스크가 발생하면 신경이 압박되어 허리 통증, 하지 마비, 부종 등이 발생한다. 또한 운동 신경이 마비되면 근력이 저하되고 드물게는 배변 장애가 나타나기도 한다. 사지골격 [이미지 3] 사지골격 - 상체 [이미지 4] 사지골격 - 하체 골반 [이미지 5] 골반의 구조 [이미지 6] 여자(좌)와 남자(우)의 골반 비교 발목뼈, 족근골 관절을 지지하는 인대가 외부 충격에 의해서 늘어나거나 일부 찢어지는 것을 염좌라고 말하며, 근육이 충격에 의해 늘어나거나 일부 찢어지는 것도 염좌라고 말하기도 하나 인대 염좌는 sprain, 근육 염좌는 strain이라고 구분하기도 한다. 인대나 근육의 전체가 끊어지는 경우는 파열이라고 한다. [이미지 7] 발목뼈관절뼈와 뼈 사이를 연결해주면서 직선운동, 각운동, 염전운동 등이 가능하게 하여 몸의 활동을 가능하게 한다. 관절 중 특히 윤활관절은 마찰력이 적어 비교적 자유로운 범위의 운동이 가능하다.관절은 섬유 관절, 연골 관절, 윤활 관절로 분류한다. 섬유 관절 : 관절강이 거의 없어 움직임이 제한된 결합으로, 두 뼈가 봉합되거나 인대로 결합되어 있다. 크게 두개골, 경골과 비골, 치아와 잇몸 사이 관절이 이에 속한다. 연골 관절 : 관절이 연골로 이루어져 있어 약간의 움직임이 가능한 관절이다. 늑골에서는 간혹 관절의 염증이 가슴 통증의 원인이 되기도 한다. 빗장뼈와 늑골 사이, 성장판, 치골 결합, 척추 사이 원반의 결합이 이에 속한다. 윤활 관절 : 관절의 구조가 상대적으로 복잡하지만 관절의 가동 범위가 넓다. 인대 : 뼈 사이를 잇는 섬유성 구조 힘줄 : 뼈와 근육을 연결 관절주머니 : 활막을 둘러싼 주머니를 말하며 마찰을 감소시킨다. 활막 : 활액을 분비하여 뼈와 뼈 사이의 마찰을 줄인다. 연골 : 뼈의 끝에 존재하며 무게를 지탱할 수 있게 하고 마찰을 감소시킨다. 근육수축과 이완을 통해 움직임을 일으키는 기관으로서 근육 섬유라고 불리는 매우 긴 세포들의 다발로 구성되어 있고, 각 근육 섬유는 가느다란 실 같은 근육 원섬유들로 가득 들어 있다. 근육 원섬유는 액틴과 미오신이라는 단백질이 서로 일부분(필라멘트)이 겹쳐서 맞물려 있어 근육이 움직일 때 두 필라멘트들이 서로를 타고 엇갈려 움직인다. 근육이 수축할 때는 서로를 당겨 짧아지고, 이완할 때는 서로를 밀어낸다.운동 단위 : 골격근을 구성하는 근섬유에는 운동 신경이 분포되어 있는데 한 가닥의 운동 신경의 말단은 많은 가지로 나뉘어져 있으며, 많은 경우는 100가닥 이상의 근섬유에 분포되어 근섬유들을 지배한다. 한 가닥의 운동 신경에 지배되는 신경과 근섬유와의 그룹을 운동 단위라고 한다.근수축의 역학 긴장(Tones) 골격근이 중추 신경으로부터 나오는 흥분 충동을 받아 약한 수축 상태를 지속하고 있는 것. 자세 유지에 기여 강직(Rigor) 병적 상태에서 활동 전압이 발생하지 않아도 강축을 일으키는 것. 비가역적인 강축 현상, 근육 실질 파괴 수반 열강직 : 40~60℃에서 단백질 응고 수분 강직 : 삼투압으로 인해 물이 근육 내 침투 사후 강직 : ATP 결핍으로 인해 미오신과 액틴의 강직 복합체 형성. 심장 → 목 → 팔 → 다리 순서로 진행. 근육의 마비, 위축과 비대 마비 : 운동 신경이 손상되어 근육의 수의적 수축이 일어나지 않는 상태 위축 : 마비된 근육이 시간 경과에 따라 부피가 점차 줄어드는 것, 비사용 위축 비대 : 근육이 과도하게 운동하여 근육의 부피와 수축력이 증가" }, { "title": "[자료구조] BFS와 DFS", "url": "/satinbower-legacy/posts/it-bfs-and-dfs/", "categories": "IT, Algorithm", "tags": "지식, IT, 과제, BFS, DFS, 탐색, 그래프, 자료구조, 알고리즘", "date": "2022-11-07 00:22:00 +0900", "snippet": "할 일이번 숙제는 다음 내용을 포함합니다.1. 그래프 예시를 직접 만듭니다. (O)2. BFS와 DFS 알고리즘을 바탕으로 그래프 탐색 과정을 그립니다. (O)3. 본인이 편하게 사용할 수 있는 BFS와 DFS 코드를 작성합니다. (O)4. (옵션) BFS 관련 문제를 풀어 봅니다. (X)DFS 관련 문제는 금일 시간 관계 상 다루지 못하였기 때문에 다음 주에 다룹니다. 평가(총 6점)3점: 독자 입장에서 평가 대상 수강생의 포트폴리오를 읽고, BFS 과정을 쉽게 이해할 수 있는지3점: 독자 입장에서 평가 대상 수강생의 포트폴리오를 읽고, DFS 과정을 쉽게 이해할 수 있는지보너스 점수 항목:첫째. BFS와 DFS의 차이점을 알 수 있는지둘째. BFS 관련 문제 풀이를 통해 알고리즘을 적용해 보았는지목차 그래프 BFS 알고리즘과 코드 DFS 알고리즘과 코드 - 미완성 BFS와 DFS의 시각적 비교그래프 그래프(graph) G=(V, E)는 유한한 개수의 정점(vertex) 또는 노드(node)들의 집합인 V와 연결선(edge) 또는 에지라고 불리는 정점들의 쌍들의 집합인 E로 이루어진다.[1]쾨니히스베르크 다리 문제(위키백과)를 들어본 적이 있다면 금방 이해할 수 있을 것이다. 프로그래밍에서 말하는 그래프는 엑셀에 그리는 것과 같은 그래프가 아니고, 선으로 연결된 점들의 집합이다.그래프는 크게 방향이 있는 것과 방향이 없는 것으로 나눌 수 있다. 보통 그래프라고 하면 방향이 없는 그래프를 의미하며 방향이 있는 그래프는 방향 그래프(directed graph) 또는 다이그래프(digraph)라고 따로 지칭한다. 이때 간선은 아크(arc)라고 말한다.[1] 이 글에서도 그래프라고 하면 기본적으로 방향이 없는 그래프를 지칭한다. 덧붙여, 트리도 그래프의 일종이다. 자세한 것은 참고 자료 1번의 책을 공부하자.그래프의 예시는 아래와 같다. 이후에 BFS와 DFS를 설명할 때에도 사용할 그래프이니 잘 봐두자.\t\t[이미지 1] 그래프 예시BFS 알고리즘과 코드BFS는 Breadth First Search의 약자로 너비 우선 탐색이라고 한다. 특정한 시작점에서 출발하여, 그 점에서 가장 가까운 점부터 차례대로 방문한다. 시작점을 중심으로 동심원을 그려나간다고 생각하면 이해하기 좋다. 매번 정점을 방문할 때마다 다음에 방문할 정점을 저장해두고 저장한 순서대로 방문하기 때문에, 이 알고리즘을 수행할 때는 큐를 사용하는 것이 적절하다. 그리고 비선형 구조를 탐색하는 것이기 때문에 한 번 탐색한 곳을 다시 탐색하지 않는 것이 중요하다. 이를 위해 방문한 정점의 배열을 따로 만들어 사용한다.이 알고리즘을 정리하면 다음과 같다.시작점을 큐에 넣고, 방문했음을 표시한다.이후의 과정을 큐가 비어있을 때까지 반복한다: 큐에서 요소를 하나 pop하고 방문했음을 표시한다. 방금 pop한 것에 대하여 방문하지 않은 정점만 큐에 push한다.[이미지 1]을 예시로 BFS 탐색을 수행해보자. 시작점은 1이고 거리가 같은 정점이 여러 개 있을 때는 숫자가 작은 것부터 방문한다고 가정한다. 탐색을 시작하기 전, 방문해야 할 정점을 저장할 빈 큐와 모든 정점의 방문 여부가 false로 표기된 방문 정점 리스트를 준비한다. 이 리스트는 배열을 써도 좋고, 벡터를 써도 좋다. 큐의 내용 : (비어있음) 방문 정점 리스트 : { 0, 0, 0, 0, 0, 0, 0, 0, 0 } // 편의상 true/false 대신 1/0으로 표기하며, 인덱스는 1부터 시작한다. 탐색을 시작한다. 가장 먼저 시작점인 1을 큐에 넣고 방문했음을 표시한다. 큐의 내용 : { 1 } 방문 정점 리스트 : { 0, 0, 0, 0, 0, 0, 0, 0, 0 } 큐에 저장된 것을 하나 꺼낸다. 2번에서 1을 큐에 넣었으므로 1이 나온다. 1과 인접한 정점들을 큐에 차례대로 넣는다. 여기서는 2와 3을 넣으면 된다. 큐의 내용 : { 2, 3 } 방문 정점 리스트 : { 1, 0, 0, 0, 0, 0, 0, 0, 0 } 큐에 저장된 것을 하나 꺼내고(2가 나온다), 아직 방문하지 않은 정점이므로 해당 정점을 방문한 것으로 표시한다. 큐의 내용 : { 3 } 방문 정점 리스트 : { 1, 1, 0, 0, 0, 0, 0, 0, 0 } 2와 인접한 정점들 중 방문하지 않은 것들을 큐에 차례대로 넣는다. 4, 5가 큐에 들어간다. 큐의 내용 : { 4, 5 } 방문 정점 리스트 : { 1, 1, 0, 0, 0, 0, 0, 0, 0 } 위의 과정을 더이상 방문할 정점이 없을 때까지 수행한다.[이미지 1]의 그래프를 위와 같은 과정으로 탐색하면 방문하는 노드의 순서는 { 1, 2, 3, 4, 5, 6, 7, 8, 9 }이다. 그림으로 그리면 아래와 같다. 노란색, 초록색, 파란색, 보라색 영역 내에 있는 정점을 순서대로 방문한다.\t\t[이미지 2] BFS 예시코드로 구현해보자. 위에 서술된 알고리즘과는 약간 다른 부분이 보일 수 있는데, BFS 알고리즘을 이용해 시작점(station)을 기준으로 시작점과 각 정점 간의 거리를 구하는 코드이다. 인접한 정점 간의 거리는 모두 1로 전제한다. 또한 cout을 이용한 출력 대신 별도의 텍스트파일에 결과를 쓰도록 했다. cout으로 실행하고 싶다면 output_file을 모두 cout으로 바꿔쓰면 된다. 전체 코드는 깃허브에서 볼 수 있으며, 교수님의 코드를 참고하여 내 방식대로 작성한 것이다. 전체 코드의 길이가 길어 아래 코드는 일부 생략하고 작성했다.struct Node { int to_station = INFINITY; // 가장 가까운 station까지의 거리 vector&lt;int&gt; adj; // 인접 노드 vector&lt;int&gt; d; // 각 인접 노드까지의 거리};class Graph {private: int vertices; // 점 수 vector&lt;Node&gt; graph; // 각 노드의 키값은 벡터의 인덱스로 대체 vector&lt;bool&gt; visited; // 방문 여부 void print_route(); // BFS로 탐색 후 탐색 결과를 출력함public: Graph(int vts); // 생성자 void BFS(int start_key); void BFS(vector&lt;int&gt; starts); // station이 여러 개일 경우 사용, 코드는 생략};void Graph::BFS(int start_key) { // 루트(시작점)에서 시작 queue&lt;int&gt; que; graph[start_key].to_station = 0; // 시작점은 station이므로 station까지의 거리가 0 visited[start_key] = true; // 방문 표시 후 que.push(start_key); // 큐에 push output_file &lt;&lt; \"----------\\nStation : \" &lt;&lt; start_key &lt;&lt; \"\\nSearch by BFS\\n\\n\"; while (!que.empty()) { // 큐가 비어있을 때까지 start_key = que.front(); // 큐에서 하나 pop que.pop(); int len = graph[start_key].adj.size(); for (int i = 0; i &lt; len; i++) { // 방금 pop한 노드의 인접한 노드에 대해 방문하지 않은 것에 한해 큐에 push int current = graph[start_key].adj[i]; if (!visited[current]) { visited[current] = true; que.push(current); graph[current].to_station = graph[start_key].to_station + 1; // 지금 방문한 곳은 station으로부터 현재의 기준점보다 1만큼 더 떨어져 있음 } } } // 탐색을 끝낸 후 방문 여부 표시를 모두 지움 visited.assign(vertices, false); // 탐색 결과 출력 this-&gt;print_route(); output_file &lt;&lt; \"----------\\n\";}DFS 알고리즘과 코드DFS는 Depth First Search의 약자로 깊이 우선 탐색이라고 한다. 특정한 시작점에서 출발하여, 그 점에서 갈 수 있는 가장 깊은 점부터 차례대로 방문한다. 미로에서 출구를 찾을 때의 풀이 과정을 생각하면 된다. 보통 사람은 동시에 여러 통로를 볼 수 없기 때문에, 하나의 통로를 쭉 따라가 그것의 끝이 막혔는지 확인하고, 막혔다면 되돌아와 다른 갈림길로 들어가 같은 과정을 반복하는 방식으로 미로를 탐색한다. 이것이 DFS의 방식이다. 더이상 갈 곳이 없을 때까지 나아간 후, 되돌아 나오면서 등장하는 갈림길에서 다시 가장 깊은 곳으로 들어가는 것을 반복하여 탐색한다. DFS는 나아간 길을 되돌아올 수 있어야 하기 때문에 재귀나 스택을 사용하는 게 적절하다. BFS와 마찬가지로 한 번 방문한 곳을 다시 방문하지 않는 것이 중요하다.이 알고리즘을 정리하면 다음과 같다. 재귀로 구현하는 방법도 있으나, 이 글에서는 스택을 사용하는 방식으로 구현하였다.시작점을 스택에 넣는다.이후의 과정을 스택이 비어있을 때까지 반복한다: 스택에서 요소를 하나 pop한다. 방금 pop한 정점이 아직 방문하지 않은 정점일 경우에만 아래 과정을 수행한다: 현재 정점을 방문한 것으로 표시한다. 현재 정점의 인접한 정점을 모두 스택에 push한다.[이미지 1]을 예시로 DFS 탐색을 수행해보자. 시작점은 1이고 거리가 같은 정점이 여러 개 있을 때는 숫자가 작은 것부터 스택에 넣는다. 그러므로 실제 방문 순서는 숫자가 큰 것부터 방문하게 된다. 스택 push 순서를 바꾸면 작은 것부터 방문하도록 할 수 있다. 탐색을 시작하기 전, 방문해야 할 정점을 저장할 빈 스택과 모든 정점의 방문 여부가 false로 표기된 방문 정점 리스트를 준비한다. 이 리스트는 배열을 써도 좋고, 벡터를 써도 좋다. 스택의 내용 : (비어있음) 방문 정점 리스트 : { 0, 0, 0, 0, 0, 0, 0, 0, 0 } // 편의상 true/false 대신 1/0으로 표기하며, 인덱스는 1부터 시작한다. 탐색을 시작한다. 가장 먼저 시작점인 1을 스택에 넣는다. 스택의 내용 : { 1 } 방문 정점 리스트 : { 0, 0, 0, 0, 0, 0, 0, 0, 0 } 스택에 저장된 것을 하나 꺼낸다. 2번에서 1을 넣었으므로 1이 나온다. 1은 아직 방문하지 않은 정점이므로 방문한 것으로 표시하고, 1과 인접한 정점들을 스택에 차례대로 넣는다. 여기서는 2와 3을 넣으면 된다. 스택의 내용 : { 3, 2 } 방문 정점 리스트 : { 1, 0, 0, 0, 0, 0, 0, 0, 0 } 스택에 저장된 것을 하나 꺼내고(3이 나온다), 아직 방문하지 않은 정점이므로 해당 정점을 방문한 것으로 표시한다. 이후 3과 인접한 정점들을 스택에 넣는다. 1, 2, 6이 스택에 들어간다. 만약 이미 방문한 정점이 스택에서 나왔다면 아무것도 하지 않고 넘어간다. 스택의 내용 : { 6, 2, 1, 2 } 방문 정점 리스트 : { 1, 0, 1, 0, 0, 0, 0, 0, 0 } 위의 과정을 더이상 방문할 정점이 없을 때까지 수행한다.[이미지 1]의 그래프를 위와 같은 과정으로 탐색하면 방문하는 노드의 순서는 { 1, 3, 6, 9, 8, 5, 2, 4, 7 }이다. 그림으로 그리면 아래와 같다. 노란색, 초록색, 파란색, 보라색 영역 내에 있는 정점을 순서대로 방문한다.\t\t[이미지 3] DFS 예시코드로 구현해보자. BFS와 마찬가지로 시작점을 기준으로 각 정점까지의 거리를 구하는 코드를 작성하려고 했으나, DFS 탐색은 할 수 있지만 거리는 적절하게 구하지 못하는 결과가 나왔다. DFS 코드는 참고 자료 [2]를 참고하여 작성했다. 출력 방식과 전체 코드 링크는 BFS와 같다.struct Node { int to_station = INFINITY; // 가장 가까운 station까지의 거리 vector&lt;int&gt; adj; // 인접 노드 vector&lt;int&gt; d; // 각 인접 노드까지의 거리};class Graph {private: int vertices; // 정점 수 vector&lt;Node&gt; graph; // 각 노드의 키값은 벡터의 인덱스로 대체 vector&lt;bool&gt; visited; // 방문 여부 void print_route();public: Graph(int vts); // 생성자 // 반복으로 구현한 DFS void DFS_by_iteration(int start_key); void DFS_by_iteration(vector&lt;int&gt; starts); // 시작점이 여러 개일 경우, 코드는 생략 // 재귀로 구현한 DFS, 코드는 생략 void DFS_by_recursion(int start_key, bool is_start = true); void DFS_by_recursion(vector&lt;int&gt; starts, bool is_start = true); // 시작점이 여러 개일 경우};void Graph::DFS_by_iteration(int start_key) { // 루트(시작점)에서 시작 stack&lt;pair&lt;int, int&gt;&gt; s; // first는 방문해야 할 노드, second는 직전에 방문한 노드 s.emplace(start_key, start_key); graph[start_key].to_station = -1; // 시작점은 station이므로 station까지의 거리가 0인데, 절차상 while 안에서 한번 방문하고 +1을 해야 하기 때문에 -1로 초기화 output_file &lt;&lt; \"----------\\nStation : \" &lt;&lt; start_key &lt;&lt; \"\\nSearch by DFS(iteration)\\n\\n\"; while (!s.empty()) { pair&lt;int, int&gt; curr = s.top(); // 스택에서 pop s.pop(); if (!visited[curr.first]) { // pop한 정점이 아직 방문하지 않은 것일 때 visited[curr.first] = true; // 방문 표시 graph[curr.first].to_station = graph[curr.second].to_station + 1; // 거리 합산 output_file &lt;&lt; \"visit : \" &lt;&lt; curr.first &lt;&lt; \"\\n\"; // 방문한 노드를 출력 for (vector&lt;int&gt;::iterator i = graph[curr.first].adj.begin(); i != graph[curr.first].adj.end(); i++) { s.emplace(*i, curr.first); // 인접 노드를 전부 스택에 추가 } } } // 탐색을 끝낸 후 방문 여부 표시를 모두 지움 visited.assign(vertices, false); // 탐색 결과 출력 this-&gt;print_route(); output_file &lt;&lt; \"----------\\n\";}BFS와 DFS의 시각적 비교지금까지 하나의 그래프를 BFS와 DFS로 탐색하며 두 알고리즘의 개념을 익혔다. 그렇지만 아무래도 두 개념은 헷갈리기가 쉽다. 그래서 위에서 사용한 두 알고리즘의 탐색 순서를 색깔로 표현한 이미지를 같이 붙여보았다. 왼쪽이 BFS, 오른쪽이 DFS이다. 그림의 가로 세로 방향보다는, 노란색으로 칠해진 시작점을 기준으로 어떻게 나아가는지를 보면 좋다. 시작점으로부터 짧게 겹겹이 나아가는 것이 BFS, 길고 깊게 나아가는 것이 DFS이다. 두 이미지 모두 탐색은 노란색 → 초록색 → 파란색 → 보라색 순서로 진행한다. [이미지 2] BFS 예시 [이미지 3] DFS 예시 참고 자료[1] 『4차 산업혁명 시대의 이산수학』, 김대수 지음, 생능출판[2] DFS / BFS 예제 구현해보기 - python, https://nareunhagae.tistory.com/17[3] C++ 파일 읽기/쓰기(C++ File Read/Write Example), https://jdm.kr/blog/170[4] C++에서 현재 시간 및 날짜 가져오기, https://www.techiedelight.com/ko/get-current-time-and-date-in-cpp/[5] C++ - localtime_s 사용 예, https://jacking75.github.io/C++_localtime_s/[6] #pragma once 가 모든 문제를 해결해주진 않는다, https://teus.me/819[7] [C언어][헤더 파일 중복 방지] #pragma once, #ifndef, https://blog.naver.com/PostView.naver?isHttpsRedirect=true&amp;blogId=white_cap&amp;logNo=221002699804[8] [C, C++] #include &lt;헤더파일&gt;과 #include “헤더파일”의 차이, https://shjz.tistory.com/97" }, { "title": "22.10.29 단위 테스트 배우기", "url": "/satinbower-legacy/posts/daily-221029/", "categories": "내가 해냄", "tags": "내가 해냄, 단위 테스트, TDD", "date": "2022-10-29 22:53:00 +0900", "snippet": "오늘 한 일 정보검색 필기 이어서 복습하기 프로젝트 구상 구체화한 내용 블로그에 올리기 프로젝트 구현 시작하기 기본적인 클래스만 만들어두고 단위 테스트 배워서 생성자 테스트하기단위 테스트 배우기이번에 쓸 코드들은 한두줄도 아니고 이런저런 이름이며 함수가 내가 지금껏 다루던 양에 비해 많아서 중간중간 테스트를 해가며 만들기로 했다. 안그래도 전에 트위터에서 사람들이 TDD, 테스트 주도 개발 얘기를 많이 해서 나도 한번 배워보자 하고 단위 테스트라는 걸 찾아봤다.테스트 프로젝트를 만드는 거나 그걸 사용하는 방법에 대한 설명은 아래 참고 링크로 대체하고, 리뷰만 해보자. 내가 지금까지 코드 쓰고 main에다 출력문 넣어서 사람 눈으로 확인했던 걸 자동으로 확인해준다! 내가 어떤 입력을 넣었을 때 의도한 출력이 잘 나오는지, 원하는 기능이 정상적으로 작동하는지를 프로젝트 전체를 굳이 실행하지 않고도 확인할 수 있었다. 좋더라..빌드는 어차피 다 해야 하지만 매번 main을 수정하지 않아도 되고, 단위별로 성공 여부가 보이고, 원본 코드의 수정과 따로 진행할 수 있다는 게 장점이지? 나도 이제 막 시작한 거라 TDD가 대체 뭔지, 뭐가 좋은지 어떻게 하는건지는 모르겠지만 단위 테스트는 성공해서 기분이 좋습니다.오늘은 생성자와 기본적인 getter 함수를 테스트했다. 생성자로 객체를 생성해보고, 생성된 객체로 getter 함수를 호출해서 결과가 맞게 나오는지 확인하는 방식으로 했고, 사실 이 정도는 마음속으로 당연히 되겠지~ 하고 실행한 거라 내가 테스트 유닛을 다루는 기본적인 방법을 익혔다는 데에 가장 큰 의미가 있다. 다음에는 생성자로 생성된 객체가 제대로 만들어졌는지 자체를 확인할 수 있는 함수가 있는지 찾아봐야겠다.참고 Visual Studio에서 C/C++에 대한 단위 테스트 작성 Visual Studio에서 Microsoft Unit Testing Framework for C++ 사용 Microsoft.VisualStudio.TestTools.CppUnitTestFramework API 참조 C++ 배열의 값이 전부 같은지 확인하는 방법 (std::equal) C++ 유닛 (단위) 테스트 쉽게 써보기" }, { "title": "[하천 쓰레기 프로젝트] 프로젝트 구현 계획", "url": "/satinbower-legacy/posts/it-dst-project-plan/", "categories": "IT, Data Structure", "tags": "지식, IT, 자료구조, 과제, 프로젝트", "date": "2022-10-29 12:38:00 +0900", "snippet": "주제참고 : [하천 쓰레기 프로젝트] 프로젝트 개요하천 쓰레기 민원 조회 시스템 만들기주 사용 대상 : 민원 접수 및 처리 담당 공무원주요 기능 지역별 민원 관리 민원 신고 민원 조회/검색 민원 처리 파일 형태로 데이터 저장 밎 재사용(보안 문제까지는 아직 내가 해결할 수 있는 부분이 아님)필요 사항 개별 민원 노드 누적 민원 노드 민원 처리 시스템 클래스class complain // 개별 민원 노드private: string pic_name // 사진 이름(필요시 절대/상대 파일 경로 포함, 사진 크기를 비롯해 사진 파일 자체에 대한 각종 정보는 원본 파일의 정보에 포함된다고 본다) int comp_date // 민원 신고 날짜 pair&lt;double, double&gt; coordinates // 사진 좌표public: int wastes[5] // 멤버 변수지만 어차피 getter를 써도 포인터로 전달되어 원본 수정이 가능하니 public 변수로 사용 생성자 string get_name pair&lt;double, double&gt; get_codi void rename(string) // 사진 이름 변경이 클래스는 기록과 조회 목적이 크기 때문에 getter는 필요하지만 setter는 그다지 필요하지 않음.class accumed_compls // 누적 민원 노드private: int waste_code // 쓰레기 분류 번호 vector&lt;complain&gt; compls // 쓰레기 분류 번호에 따른 해당 쓰레기 관련 민원 벡터public: 생성자 int get_num // 쓰레기 분류 번호 반환 int get_compls_size // 민원 노드 벡터 길이(누적 민원 수) 반환 void add_compl // 민원 추가 void clear_compls // 민원 처리(누적 민원 벡터를 clear하며, 개별 민원 중 2종류 이상의 쓰레기가 포함된 민원의 경우 쓰레기 포함 표기를 수정한 후 clear해야 한다.)class compl_system // 민원 처리 시스템 클래스private: int area_code // 지역 코드(행정동/법정동 등등) accumed_compls compls_list[5] // 쓰레기 분류별 누적 민원 배열 vector&lt;complain&gt; // 전체 민원 벡터 multimap&lt;string, complain&gt; comp_map // 사진 이름 기준 전체 민원 멀티맵 multimap&lt;double, complain&gt; longitude_map // 경도 기준 전체 민원 멀티맵 multimap&lt;double, complain&gt; latitude_map // 위도 기준 전체 민원 멀티맵 multimap&lt;int, complain&gt; latitude_map // 민원 접수 날짜 기준 전체 민원 멀티맵public: 생성자 void receive_compl // 민원 접수 void view_all(sort_by) // 정렬 기준(sort_by)에 따른 전체 민원 조회(출력하게 할 것이므로 반환값 없음) void search_compl(search_by) // 검색 기준(search_by)에 따른 특정 민원 검색 bool is_enough(waste_code) // 특정 분류의 쓰레기 민원이 충분히 많아 처리해도 될만한지 확인 void clear_compls(waste_code) // 특정 분류의 쓰레기 관련 민원 일괄 처리 void load_save // 파일에 기록된 데이터를 통한 이전 업무 기록 로드. 매번 새 시스템을 생성할 수는 없으니까. void save_task // 업무 진행 상황을 파일로 기록. 업무를 종료하거나 중간 저장이 필요할 때 실행.민원을 처리함에 있어서 사진의 크기가 중요할까? 사진 크기 기준 정렬을 사용할지, 조회와 검색이 가능하게 할지 고민을 조금 했는데, 필요 없다고 결론내렸다. 특정 민원을 찾을 때 민원이 접수된 날짜나 위치를 검색해서 찾지 사진의 크기를 검색해서 찾을 이유는 어지간히 예외적인 상황이 아닌 이상 없을 거라고 본다.시간복잡도가 비교적 낮은 검색 기능 구현을 위해 메모리를 다소 낭비하는 방식을 택했다. 전체 민원 벡터를 하나 두긴 하지만 이것만으로 매번 정렬하고 검색하는 것은 아무리 이진 탐색을 한다 해도 별로 좋은 방법이 아닌 것 같아서 멀티맵을 사용했다. 전체 민원 벡터는 전체 민원을 조회하고자 할 때에 사용하고, 멀티맵은 검색 결과를 조회할 때 사용한다.원래 준비된 데이터에는 날짜에 대한 정보가 없지만, 민원 처리 시스템을 만들고 있으니 민원 접수 날짜도 필요할 거라고 생각해 추가했다. 실제로 프로그램을 실행할 때는 임의의 날짜를 사용할 생각이다. 가능한 한 원본 사진이 찍힌 날짜 이후의 날짜를 입력하도록 하고 싶지만 그것은 힘들 것 같다. 이 프로젝트는 말은 시스템이라고 하지만 시뮬레이터에 더 가깝다.프로그램을 종료해도 민원을 처리한 기록은 남아야 하니까(컴퓨터는 꺼놓고 퇴근해야 하니까) 프로그램의 진행 상황을 파일로 저장하는 기능도 구현하고 싶다. 사실 데이터베이스를 쓰면 훨씬 깔끔하고 나도 편하게 할 수 있을 것 같지만, 그걸 쓰기 시작하면 내가 구상한 모든 자료구조가 필요가 없다.. 어차피 다양한 곳에 널린 쓰레기를 효율적으로 치우자! 라는 주제는 발에 채일 만큼 많을 거라고 예상했고, 실제로도 그랬다. 나까지 같은 소리를 하면서 뭔가 나만의 다른 점을 어필하기엔 딱히 다익스트라에 욕심도 없고, 그보다는 어떤 하나의 시스템을 직접 구상해보는 게 내 흥미를 더 끌어서 이런 프로젝트로 정했다. 데이터베이스를 쓸 수 없다는 점은 감수해야죠 뭐 어쩌겠습니까..추가로 필요한 것시스템이 생성된 지역구 목록지역 코드를 이용해 각 지역의 시스템을 분리하도록 구상했다. 그리고 출퇴근도 전제했으니, 프로그램이 시작될 때 지역 코드를 입력하면 해당 코드로 생성된 기록이 있는지 파악하여 이전의 기록을 로드하거나, 없다면 새로 만들도록 하고 싶다. 이 목록은 저장소 내에 지역 코드로 생성된 로그 파일이 있는지 검사하기만 하는 것으로 대체될 수 있다.민원 처리 시스템 업무 기록내 프로젝트의 주요 사용 대상은 공무원이다. 공무원은 출퇴근을 한다. 퇴근할 때는 컴퓨터를 끄고 가야 한다. 고로 프로그램이 실행 중 저장되고 변경된 데이터는 컴퓨터가 종료되어도 남을 수 있도록 어딘가에 기록되어야 한다. 세이브 파일을 만든다는 말이다.단위 테스트, TDD 배우기참고 Visual Studio에서 C/C++에 대한 단위 테스트 작성 Visual Studio에서 Microsoft Unit Testing Framework for C++ 사용 Microsoft.VisualStudio.TestTools.CppUnitTestFramework API 참조 C++ 배열의 값이 전부 같은지 확인하는 방법 (std::equal) C++ 유닛 (단위) 테스트 쉽게 써보기" }, { "title": "정보 검색 중간고사", "url": "/satinbower-legacy/posts/it-info-retrieve-mid/", "categories": "IT, 기타", "tags": "지식, IT, 정보 검색, 필기", "date": "2022-10-16 20:39:00 +0900", "snippet": "유의사항 시험 전에 강의자료 훑으면서 편하게 작성한 거라 보기 좋은 정리는 아님. 복습을 위한 자료지 예습이나 학습을 위한 자료는 전혀 아님. 6주차 수업에 결석해서 강의자료 번역했음. 6주차 내용은 내 필기 아님.2주이번 학기 공부 대상 : 텍스트 검색유닉스 명령어 grep : 원하는 것을 찾을 수 있긴 한데 정보 검색용으로 있는 명령어는 아님 특정 단어가 존재하거나, 존재하지 않는 파일 검색 가능 대규모 파일 처리 느림 없는 단어 찾기 어려움 : 전수조사 필요 “~와 가까운 ~” 같은 상세조건 불가 적절한 결과순 랭킹 불가 * : 모든 파일 중에서 찾기 | : 이 기호 앞에 있는 명령을 먼저 수행하고, 그 결과에 대해 다음 명령을 수행 -v : NOTterm-doc matrix : term과 doc의 관계를 나타낸 행렬 행에는 모든 term 나열, 열에는 모든 doc 나열, 각 term과 doc에 대해 해당 doc에 term 등장 여부 표시 문서가 많을수록 행렬이 커짐 비트 단위 연산으로 간단히 결과 도출 가능정보 검색의 기본적인 전제 : 문서의 집합은 고정되어 있다(비현실적이지만 설명 편의상 전제함)정밀도와 재현율 : 통합본 13페이지, 2주차 13페이지정밀도 : 검색 결과 중 제대로 검색한 것재현율 : 원래 원했던 결과 중 찾아낸 것F-measure : 가중치(α)를 준 정밀도(P)와 재현율(R)의 조화평균. 식은 1/(α * 1/P + (1 - α) * 1/R), 보통 가중치는 0.5로 주고 이를 정리하면 2PR/(P+R)이 됨.inverted index : 각 단어마다 그것이 등장하는 문서만 표시한 인덱스. 단어를 헤드노드로 하는 연결 리스트로 만든다. 정렬된 게 쓰기 좋다. 토큰화 과정 : 모든 문서를 검사해 (단어, 등장 문서) 투플을 만들고, 단어를 기준으로 정렬하고, 중복된 단어에 대해 투플을 통합한다. 문서당 빈도를 표시할 수도 있다. 결과는 사전과 포스팅 리스트로 나누어진다.사전은 상대적으로 크기가 작으므로 보통 메인 메모리에 저장하고 포스팅은 디스크에 저장한다. 포스팅 리스트는 연결 리스트로 만든다.비교해야 할 두 단어의 포스팅 리스트 길이가 각각 x, y라고 할 때, AND 연산의 시간 복잡도는 O(x + y)이다. 이때 리스트는 정렬되어 있어야 한다.여러 단어에 대해 논리 연산을 해야 할 경우 연산 순서를 바꾸면 연산 시간을 줄일 수도 있다. 포스팅 리스트(doc-freq) 길이가 짧은 것부터 먼저 연산하면 된다. OR 연산의 결과의 길이는 최대 두 포스팅 리스트의 합과 으므로 AND 연산과 섞여있다면 최댓값으로 가정하고 순서를 정한다.위의 inverted index가 불가능한 기능 : 구 검색, “가까운” 단어 검색, 검색할 정보의 zone 지정하기“가까운” 단어 검색 : 포스팅 리스트에 있는 각 문서별로 등장 페이지 리스트를 따로 붙이면 계산 가능검색 결과 정렬에는 term-freq를 활용할 수 있으나 신뢰도는 보장할 수 없음 → boolean 모델에서 원칙적으로 결과 랭킹은 불가하지만 가능은 함텍스트 검색은 범위(부등호) 검색 불가능군집과 분류 : 통합본 46페이지, 2주차 46페이지군집 : 선묶음 후기준, 총 묶음 개수를 미리 알 수 없음분류 : 선기준 후묶음, 묶음 개수가 한정됨3주문서 토큰화 이전에 할 일 : 문서 종류 파악, 언어 파악(코드 변환이 필요할 수 있음) → 기계가 하거나, 사람이 하거나한 문서가 여러 언어로 쓰인 경우, 한 문서가 여러 파일/언어로 구성된 경우 있을 수 있음토큰화토큰화 : 문서를 단어 단위로 나누는 것, 정규화 이후 진행함, 불용어 사용. 기본적으로는 공백 단위로 나누고 문장부호 삭제하는데, 고유명사에 문장부호가 들어가는 등의 경우는 어떤 방식을 쓰든 문서와 질의어를 똑같이 전처리하면 된다.어려운 점 : 하이픈의 용도가 다양해서 처리 방법을 하나로 정할 수 없음, 하이픈이 들어간 구는 더 어려움문제점 : 날짜, IP주소, 이메일 등 기호/공백이 있지만 분리하면 안되는 토큰 → 무시하기엔 너무 유용하고 토큰 넣기엔 너무 많은데 → 사전을 늘리기로 결정토큰화 언어 식별 : 숫자로 된 코드만 보고 한글인지 영어인지 맞혀야 함. 영어에 없는 조합이면 한국어고, 한국어에 없는 조합이면 영어라고 판단하는 방식으로 식별함.불용어불용어 : 빈번하게 나오지만 별로 중요하지 않은 말, 기능어(반대 : 내용어).전체 텍스트의 약 30% 차지, 사전 크기는 별로 줄지 않지만 포스팅 리스트는 많이 줄일 수 있다.문장이 너무 짧은 경우 불용어가 문장의 대부분을 차지해 문장의 내용이 상당히 소실되는 문제가 있어 불용어가 줄어들고 있으나, 요즘은 압축 기술이 좋아 포스팅 리스트 저장 비용이 감소했고, 질의어를 잘 최적화하면 된다(기능어에 가중치 적게 주기).정규화정규화 : 다르게 표기하지만 실상은 다 같은 단어를 하나의 단어로 통합하는 것. 기호를 없애는 것도 방법.Thesaurus : 유의어/반의어 사전. 동의어나 동음이의어를 다룰 수 있으며 이 사전이 없으면 수작업을 해야 함.정규화를 할 경우 질의어도 똑같이 정규화해서 검색해야 한다. 단어를 하나의 클래스로 통합해 인덱스를 합치는 방법이 있고 하나의 클래스에 속하는 단어마다 모두 통합된 똑같은 인덱스를 주는 방법이 있고 → 메모리를 손해보지만 질의어를 정규화할 필요가 없어 검색이 빨라짐 각 단어별 인덱스는 따로 만들고 질의어를 확장하는 방법 → 오래걸림Stemming재현율(recall) 높이기 위해 단어에서 접사 떼고 어근만 남기기정확할 필요 없고 적당히 자르면 됨. sess → ss 등 규칙 있음.질의어도 똑같이 처리해야 함Lemmatization형태소 분석. 엄격하게 실제 단어만 남기고 어근/조사/접사 다 떼기 스테밍과 레마티제이션 비교 : 후자가 더 좋아보이지만 실상 별 차이 없다고 함스킵 포인터인덱싱할 때 만듦. 검색하기 위한 비교 횟수 감소 기능.스킵 포인트가 많으면 스킵 기회도 많지만 스킵 거리가 짧고 메모리 더 필요스킵 포인트가 적으면 스킵 기회는 적지만 스킵 거리가 긺.구 검색 biword index : 모든 조합의 두 단어 구(인접한 것만) 인덱스 만들기 사전이 매우 커지지만 두 단어 구 즉시 검색 가능 긴 구 질의 - 여러 개의 두 단어 구로 나눠 검색, 검색이 되긴 되지만 꼭 모든 단어가 질의처럼 붙어서 나온다는 보장이 없어 위양성(false positive) 존재 표준적인 해결책이 아님 positional index 등장 위치 인덱스 : 단어에 달린 포스팅 리스트의 각 포스트마다 해당 단어가 어디서 등장하는지 인덱스 기록. 사전은 그대로이고 인덱스 사이즈 커짐. 두 단어 구 검색 - 두 단어 동시 등장 문서 찾기, 동시 등장 문서 중 인접한 위치 찾기 구가 얼마나 길든 검색 가능, 단어 간 거리 지정 검색 가능 ← biword는 불가능 혼합 방식 : 자주 검색되는 특정 구에 대해 biword 인덱스 만들기 사람들이 검색한 기록인 로그 데이터(자산이 되기 때문에 함부로 버리면 안됨)를 이용해 자주 검색되는 구를 알아내 biword 인덱스 생성4주사전을 저장하는 자료구조 - 주로 두 가지 방법 : 해시테이블과 트리해시 테이블해시 함수에 문자열을 입력으로 주면 함수 계산을 해서 나오는 값을 인덱스로 삼아 데이터를 저장, 해시 함수를 잘 만들어야 효율적으로 저장할 수 있다.탐색 속도가 아주 빠르지만 해시 함수에 따라 저장 공간이 중복되는 단어(충돌)가 생길 수 있다 → 충돌한 자리에 연결 리스트 생성장점 : 서치가 O(1)단점 : 비슷한 단어 찾기 어려움(해시 값이 전혀 다름), 와일드카드 불가, 사전이 점점 커지면서 해시테이블의 크기를 바꾸면 해시함수도 바뀌고 사전 전체를 다시 해싱해야 한다트리 - 이진 트리장점 : 비슷한 단어 찾을 수 있음, 와일드카드 가능단점 : 서치 느림 O(logn), 효율적이려면 균형 트리 만들어야 함(루트를 잘 골라야 하고 정렬된 데이터 넣으면 skewed), 트리를 수정하다 보면 균형 깨질 수 있음(→ 재정렬 필요) → 재정렬 피하기 위해 B트리 사용트리 - B트리자식 노드의 수가 a~b개 사이를 유지하는 트리와일드카드 쿼리lexicon : 사전B트리를 쓰면 와일드카드 질의를 다루기 쉽다결과는 검색된 단어들을 전부 검색(문서 검색이 목적이니까) 와일드카드가 앞에 나오면? *mon 거꾸로 된 B트리(단어를 거꾸로 쓴 것)가 하나 더 필요하다 역B트리로 nom* 검색 중간에 와일드카드가 들어간 경우 pro*cent 반으로 나눠서 따로 검색하고 결과 합치기, 그 결과로 나온 단어로 다시 문서 검색 문제 : 검색 결과 합치는 연산이 너무 오래 걸림 → permuterm index로 시간이 덜 걸리는 대신 메모리를 더 씀permuterm index단어에 $를 붙이고 회전시킴, 이 회전을 permute라고 함.변형된 단어를 모두 사전에 저장하고 원본 단어를 가리키는 포인터를 둠.기본 와일드카드 검색은 질의어 끝에 $를 붙이고 단어를 회전시켜 *이 마지막에 나오게 만듦.와일드카드가 여러 개 있으면 $를 붙인 상태에서 우선 그 와일드카드 중 하나가 단어 맨 뒤로 가게 만들어 앞에서부터 와일드카드 단위로 잘라서 검색단점 : 사전이 많이 커진다. 영어로 실험 결과 사전이 10배 정도 커지지만 AND 연산보다는 감수할만 하다고 함.k-gram보통 n그램이라고 많이 씀. k개의 연속된 시퀀스(글자, 단어 등)를 말함. $로 단어의 시작과 끝을 표시.1-gram : unigram, 2-gram : bigram, 3-gram : trigram, n-gram : ngram. 주로 2그램, 3그램 씀.k-gram index모든 k그램을 사전에 저장각 k그램은 해당 k그램을 포함하는 단어를 전부 가리킴, 사전순 정렬3그램이 2그램보다 단어 종류가 많지만(메모리 손해) 효율도 더 좋음permuterm 인덱스보다 메모리는 효율적(중복이 많아서 사전이 덜 큼), 속도는 비교하기 어려움문제 : 와일드카드 검색어에 따라 올바르지 않은 결과가 섞일 수 있다 → 검색 후 필터링하면 됨철자 고쳐주기 단어 고쳐주기 단어만 고려하기(문맥 X) 문맥 고려해서 고쳐주기(시간이 좀 더 오래 걸림) 문서 고쳐주기이미지 → 텍스트 변환한 문서의 오타 고치기. 문자 인식 오타와 타자 오타는 양상이 다름.멋대로 고쳐서 검색하지 말고 사용자에게 제안하기사용자의 검색어와 비슷한 단어 찾기 : 만약 고친 단어 후보 중 동점이 나와서 결정이 안 되면 단어 사용 횟수/검색 빈도 고려. 어떻게 가장 비슷한 단어를 정하나? → 편집 거리, k그램 오버랩전제 : 정확한 단어의 사전이 있다 → 사전에서 질의어와 비슷하게 생긴 단어를 찾음편집 거리단어를 고치려면 몇 번이나 편집해야 하는지기본적으로 삽입과 삭제만을 고려하고, ‘대체’도 포함할지는 상황에 따라 다름.가로로는 올바른 단어를 쓰고, 세로로는 잘못 쓴 단어를 써서 각 글자를 연결해 격자를 만든다. 격자의 왼쪽 위에서부터 오른쪽 아래로 가는 최단경로가 편집 거리. 아래로 가는 방향은 글자 삭제를 의미하고 오른쪽으로 가는 방향은 글자 삽입을 의미함. 서로 겹치는 글자가 만나는 격자에는 대각선을 그어 카운트하지 않고 넘어가게 한다.편집 거리가 특정 값보다 작은 것만 대체 단어로 제안하도록 하면 제안할 대상을 줄일 수 있다.k그램 오버랩질의어를 이용해 k그램 검색을 하여 질의어가 갖는 k그램을 마찬가지로 갖는 단어들을 찾되, 질의어는 틀린 단어이기 때문에 그대로 검색하면 안된다. threshold를 정해서 이 값을 넘기는 것을 후보로 포함한다.k그램 오버랩으로 골라낸 단어만 가지고 편집 거리 계산문제 : 단어가 너무 길어서 k그램이 많이 겹쳤을 뿐인 사례. 정규화는 어떻게 할 수 있는지.k그램 오버랩 : 두 집합이 얼마나 겹치는지 계산. 교집합 크기 / 합집합 크기. 각 집합의 요소는 해당 단어의 k그램.문맥 고려 단어 고치기모든 단어가 틀렸다고 전제하고 교정 후보 찾아 조합하기 → 그 조합 중 가장 많이 나온 것으로 제안(말뭉치에 단어 3그램 미리 준비)이 방법은 정말 오래걸리니까 수상할 정도로 검색 결과가 적을 때만 사용5주인덱스 만들기하드웨어 기초메인 메모리 접근 시간 &lt; 하드 접근 시간디스크 탐색 시간 : 헤드가 원하는 트랙과 섹터로 이동하는 시간IO는 블록 단위로. 컴퓨터마다 다르지만 보통 한 블록은 8~64kb압축하지 않은 데이터 읽는 시간 &gt; 압축한 데이터 읽고 압축 푸는 시간 → 요즘은 이게 더 빠름Fault tolerance : 기계적인 결함이 발생해도 시스템을 계속 사용할 수 있는 시스템(예: CPU가 여러 개 있어서 하나가 죽어도 계속 작동함)비싼 컴퓨터 하나 쓰는 것보다 싼 컴퓨터 여러 대 묶어서 쓰는 게 저렴하고 낫다.로이터 RCV1로이터의 1년치 뉴스기사로 만든 말뭉치, 다양한 토픽 존재함.스케일에 상관 없이 먹히는 인덱스 구축 알고리즘을 적용하는 예시로 사용.토큰 당 평균 바이트 수는 4.5, term당 평균 바이트 수는 7.5인데 이 차이는 불용어 유무 때문에 생김. 보통 불용어는 짧고 많기 때문에 이것이 빠진 term의 평균 길이가 길어짐.인덱스 만들기정렬 기반 인덱스는 scalable한가? → 그닥scalable 인덱스 세 가지 : BSBI, SPIMI, distributed 인덱싱정렬 기반 인덱스문서로부터 단어와 등장 문서의 쌍 생성모든 쌍을 정렬하고 포스팅 리스트 구축 ← 단어를 ID로 바꿔서 정렬하면 문자열 비교보다 쉽지만 각 단어의 ID를 저장한 테이블이 따로 필요하다. 단어와 문서의 ID는 int라고 가정.이 방법은 스케일이 커지면 메인메모리 용량 문제로 사용 불가메인메모리를 사용하지 않는다면 시간이 너무 오래 걸려서 사용 불가BSBI블록 단위 정렬 후 인덱스 통합 블록 단위 인덱스 정렬 같은 단어끼리 등장 문서 합치기 토너먼트식으로 다른 블록과 인덱스 합치기전체 정렬과 다른 점 : 각 블록들을 합칠수록 블록의 크기는 커지지만 어차피 합칠 때는 블록 전체가 메모리에 있을 필요가 없으니 scalable한 방법이 맞다.모든 블록을 한 번에 조금씩 잘라서 합치는 방법도 있다 : 토너먼트식 병합보다 빠르지만 각 블록이 모두 파일이기 때문에 한번에 다수의 파일을 열어두어야 하는데, 한번에 열어둘 수 있는 파일의 수가 제한적이기 때문에 한계 있음.문제 : 단어에 ID를 부여하면 메인메모리에 사전과 테이블이 동시에 올라가야 하는데 이건 용량이 너무 커지고, ID를 부여하지 않으면 인덱싱이 오래걸림SPIMI정렬하지 말고 해싱하자. 블록 단위로 만들고 합치자.합칠 때는 사전만 정렬함 → 위에서부터 투포인터 탐색하면서 겹치는 것 찾아 합쳐야 하기 때문distributed 인덱싱웹 스케일의 인덱싱은 컴퓨터 한 대로는 부족하다.각각의 컴퓨터는 문제가 발생할 가능성이 있다.고로 몇 대의 컴퓨터에 인덱스를 나눠 저장한다.예 : 구글 데이터 센터MapReduce : 분산 컴퓨팅의 일반적인 아키텍처분산되는 각 작업들(스플릿)은 한번에 빠르게 처리할 수 있는 크기로.파서와 인버터파서 : 스플릿들(분류되지 않은 단어와 등장 문서 쌍)을 읽고 세그먼트 파일(알파벳 순으로 여러 개의 파티션으로 나눈 세그먼트)에 분류한다. 각 파서마다 세그먼트 파일이 한묶음씩 나온다. 파서의 수는 스플릿의 수와 같고, 물리적 컴퓨터의 수와는 다를 수 있다.인버터 : 파서마다 나온 세그먼트 파일들 중 특정 세그먼트만을 모두 읽고 합펴 인버티드 인덱스를 만든다. 인버터의 수는 세그먼트의 수와 같다.마스터가 위의 작업을 모두 감독하고 배치한다.한 대의 컴퓨터에서 파서와 인버터가 동시에 돌아갈 수 있다. 파서와 인버터는 프로그램이다.term 파티션 인덱싱 : 단어를 기준으로 파티션을 나누었기 때문에 사람들이 특정 단어를 많이 검색하면 특정 파티션을 맡은 컴퓨터에 부담이 몰린다.doc 파티션 인덱싱 : 모든 컴퓨터가 단어는 전부 갖고 있지만 포스팅 리스트를 나눠 가진다. 어떤 단어를 검색하면 모든 컴퓨터가 해당 단어를 검색하고 합쳐야 하지만 각자 가진 인덱스가 적기 때문에 빠르다.다이나믹 인덱싱가장 간단한 접근 : 하나의 큰 메인 인덱스와 새 문서에 대한 정보를 저장하는 작은 임시 인덱스를 가지며 주기적으로 통합한다. 없어진 문서에 대한 정보는 따로 갖고 있다가 검색 결과에서 제외한다.문제 : 메인 인덱스가 너무 커서 메인 인덱스와 서브 인덱스를 통합하는 동안 서치 엔진 사용이 불편해지는데, 통합을 자주 한다.로가리즘 병합 보조 인덱스가 생긴다. 일정 이상 커지면 메모리에 쓴다. 또 보조 인덱스가 디스크에 입력된다. 같은 크기의 보조 인덱스를 합친다. 반복한다.요약 : 인덱스 2048특징 : 병합을 단계적으로 하기 때문에 효율적이다. 질의어를 처리할 때 모든 인덱스 파티션을 확인해야 하므로 질의 처리 속도는 좀 떨어진다.로가리즘을 계속 하면 인덱스 파티션이 점점 많아져서 쿼리 처리가 느려지니까 주기적으로 통합해야 한다.6주인덱스 압축무손실 압축 : 모든 정보가 보존됨손실 압축 : 일부 정보가 버려짐. 버려진 정보는 별로 중요하지 않음. 대신 압축률이 좋음.몇 가지 전처리 단계는 손실 압축으로 보일 수 있다단어 수 추정하기종종 언어는 특정 크기의 사전을 갖는다고 본다.대규모 컬렉션의 어휘는 훨씬 크다 : 인명, 지명, 학술용어 포함. 이들은 인버티드 인덱스에 들어가야 한다.힙의 법칙모음 크기의 함수로 어휘 크기를 추정한다.M은 어휘 사이즈, T는 컬렉션에 있는 토큰 수로 정해지는 컬렉션 사이즈, 보통 30 ≤ k ≤ 100, b는 0.5쯤. k는 컬렉션 자체와 그것의 전처리 과정에 영향을 받는다. 케이스 폴딩(모든 문자를 소문자로 바꾸는 정규화)과 스테밍은 k를 줄이고 숫자와 오타를 사전에 포함하는 것은 k를 증가시킨다.공식은 M = kTb로그를 취하면 M과 T는 선형 관계이다.log M = b log T + log k가정 : 사전은 충분히 크고, 계속 커진다(최대 단어 수 제한 없음).고로 효율적인 정보 검색 시스템을 위해 사전 압축은 반드시 필요하다.zipf의 법칙보통 자연어에는 아주 흔한 소수의 단어가 있고, 아주 다양한 희소 단어가 있다.단어의 등장 빈도를 컬렉션의 랭크 함수로 나타낼 수 있다.fi = c/i, log fi = log c - log ifi는 i번째로 흔한 단어의 빈도이고 c는 정규화 상수다.인덱스 압축 사전의 크기를 고려한다. 메인메모리에 둘 수 있을 만큼 작게 만들어야 한다. 포스팅을 위한 공간. 디스크 공간을 줄일수록 디스크에서 읽어들이는 시간이 줄어든다. 큰 서치 엔진은 포스팅의 중요한 부분을 메인 메모리에 둔다. 각 포스팅은 docID라고 가정한다. 빈도와 등장 위치는 고려하지 않는다. 사전 압축 포스팅 압축 허프만 코드사전을 압축하는 이유 빠른 질의 처리를 위해 사전을 메모리에 보관(또는 사전의 상당 부분 이상) 빠른 시작 시간을 위해 다른 응용 프로그램과 메모리를 공유하려면(특히 엔터프라이즈 검색 엔진)사전을 위한 자료구조너비가 고정된 배열단어 당 20바이트, 문서 빈도와 포스팅 리스트에 각각 4바이트. RCV1 기준 40만 단어 * term 당 28바이트 = 11.2MBterm에 20바이트를 할당했는데, 실제 term 당 평균 바이트는 7.5이므로 용량 낭비가 있고, 일부 너무 긴 단어는 잘릴 수 있음.스트링 압축사전을 하나의 긴 문자열로 저장다음 단어로의 포인터는 현재 단어의 끝을 나타낸다.주소 공간 : 40만 단어 * term 당 8바이트 = 3.2MB포인터는 log2 3.2M = 22bits = 3바이트사전을 문자열로 저장했을 때 공간문서 등장 빈도에 4바이트, 포스팅 리스트 포인터에 4바이트,term 포인터에 3바이트, term에 8바이트 → term 당 평균 11바이트가 됨. 아까는 20바이트였음.40만 단어 * 단어 당 19바이트 = 7.6MB너비가 고정된 배열이 11.2MB였던 것에 비해 32% 절약블록 저장단어들을 사이즈가 k인 블록에 문자열로 저장단어 포인터는 블록 당 첫 단어에만 할당단어의 길이를 저장해야 하기 때문에 각 단어의 시작부분에 추가 바이트 필요k 단어 블록 당 2k-3 바이트 절약k가 4일 때, 4 단어 블록 당 5바이트 절약k가 4일 때 40만 단어 / 4 * 5 = 0.5MB, 사전 사이즈는 7.1MB로 감소. 고정 너비 배열에 비해 37% 절약k가 클수록 사전은 더 압축되지만 서치가 느려짐. 각 블록의 첫 단어에서부터 선형 탐색을 해야 하기 때문.front coding정렬된 단어들은 보통 동일한 prefix를 갖는다. 그러니 이들의 차이나는 부분만 저장한다.예)8 automata 8 automate 9 automatic 10 automation8 automat* a 1◊e 2◊ic 3◊ion*은 한 어근의 끝, * 뒤에 나오는 숫자는 어근 뒤에 붙는 추가 글자의 수블록 저장과 프론트 코딩을 병행하면 5.9MB 됨.포스팅 리스트 압축포스팅 파일이 사전보다 훨씬 크다.이 예제의 포스팅은 빈도와 위치 정보를 제외하고 단순히 docID이다.포스팅 파일의 공간 요구 사항은 250MB이다.우리의 목표는 각 포스팅을 docID 당 20비트 미만으로 압축하여 저장하는 것이다.키 아이디어 절대적인 docID 대신, 우리는 포스팅 파일에서 두 개의 인접한 docID의 차이를 사용합니다. 자주 나오는 포스팅들이 서로 가까이 붙어 있다는 게 우리의 관측이다. 따라서 차이 또는 간격은 더 적은 공간으로 나타낼 수 있습니다.포스팅 리스트에 각 문서의 ID를 그대로 적는 대신 앞 문서와의 ID 차를 적는다.희망 사항 : 대부분의 차이는 20비트보다 훨씬 적은 것으로 표현될 수 있으면 좋겠다.the와 같은 단어는 거의 모든 문서마다 나온다. → 포스팅 당 20비트는 너무 낭비다. 1비트만 있어도 된다.어떤 단어는 백만 문서에 한 번 나온다. 이건 20비트로 나타내야 한다.결론 : 가변 바이트 인코딩 필요가변 바이트 인코딩목표 모든 갭을 필요한 만큼 적은 비트로 인코딩합니다. 가변 바이트 인코딩은 작은 숫자에 짧은 바이트 코드를 사용함으로써 이 목표를 달성한다. 간격 G를 저장하기 위해 1바이트로 시작하고 연속 비트 c로 사용할 수 있도록 1비트를 할당한다. G ≤ 127일 경우, 7개의 사용 가능한 비트로 인코딩하고 c = 1로 설정한다. 그렇지 않으면 G의 하위 7비트를 인코딩한 다음 추가 바이트를 사용하여 동일한 알고리즘을 사용하여 상위 비트를 인코딩한다. 마지막 바이트의 연속 비트를 1(c = 1)로 설정합니다. 다른 바이트의 연속 비트가 0(c = 0)으로 설정됩니다.다른 가변 길이 코드바이트 대신 다른 정렬 단위를 사용할 수도 있습니다. : 32비트(word), 16비트, 4비트(nibbles)가변 바이트 코드는 작은 공백이 많은 경우 공간을 낭비한다. 그런 경우에는 nibbles(4비트)가 더 낫다.인덱스 압축 요점이제 매우 공간 효율적인 부울 검색을 위한 인덱스를 만들 수 있습니다. 컬렉션의 전체 텍스트 크기 중 13%만 RCV1 컬렉션의 경우 960MB, VB 인코딩 포스팅의 경우 116MB 하지만, 우리는 위치 정보를 무시했습니다. 따라서 실제로 사용되는 인덱스의 경우 공간 절약이 더 적습니다. 하지만 기술은 실질적으로 동일합니다. 허프만 코드 1950년대에 David Huffman에 의해 개발되었다. 문자 또는 단어의 빈도 분포 사용 가변길이코드 더 빈번한 기호에는 더 짧은 코드가 할당됩니다. prefix 속성을 가지고 있습니다. 어떤 코드도 다른 코드의 접두사가 아니다. 임의의 비트 스트림은 주어진 허프만 코드로 고유하게 디코딩할 수 있다. 전송 오류는 거의 항상 자동으로 걸러집니다. 허프만 코드 인코딩 말뭉치에서 문자(또는 단어) 빈도를 수집합니다. 빈도 분포에 따라 이진 트리인 허프만 트리를 만듭니다. 트리에서 허프만 코드 테이블을 얻을 수 있습니다. ← 왼쪽 서브트리로 가면 0, 오른쪽 서브트리로 가면 1을 부여하고 루트에서 각 글자인 리프까지 가는 경로를 각 글자의 코드로 정함. 표를 사용하여 각 문자(또는 단어)를 허프만 코드로 인코딩합니다.허프만 코드 디코딩 인코딩에 사용된 것과 동일한 Huffman 트리를 사용합니다. 허프만 트리의 루트에서 리프에 닿을 때까지 아래로 가로지른다. 각 문자(또는 단어)는 리프에서 해독된다. 전송 오류는 코드를 따라 해독했을 때 매치되는 글자가 없기 때문에 거의 항상 자동으로 걸러집니다.7주1주-6주까지 배운 불린 모델의 문제점 : 검색 결과가 너무 많은 경우가 있고, 검색 결과의 랭킹이 없음검색 결과에 점수 매기기의 기본보통 0-1 사이 실수로 점수를 매김쿼리-문서 매칭 스코어문서에 질의어가 자주 나올수록 높은 점수 부여불린 모델에서 점수를 매기는 방법자카드 계수교집합 / 합집합0과 1 사이의 값을 가짐. 완전히 포개질 때만 1.문제 : 문서 내에서의 단어 등장 빈도(해당 문서 내에서 아주 중요한 단어)와 문서들에 등장하는 빈도(어디에나 나와서 별로 안 중요한 단어)를 반영하지 못함파라미터와 존 인덱스문서 본문 이외 추가 정보 반영. 저자, 제목, 출판 일자 등.parametric index : 특정 범위로 제한된 값만 들어가는 인덱스. 예를 들어 출판 연도라면 2022 이하의 숫자만 가능.기본적인 존 인덱스는 한 단어에 대해 abstract 인덱스 따로, 제목 인덱스 따로, 작가 인덱스 따로 만들지만 인코디드 존 인덱스는 저걸 모두 합침. 단어 → 2.저자.제목 → 3.저자 → 4.제목 이런 식으로. 이렇게 하면 사이즈가 줄어드는 대신 검색 시간이 늘어남.가중치 존 스코어링gi는 가중치, Si는 점수한 질의어에 대한 한 문서의 점수는 가중치와 점수의 곱의 합모든 가중치의 합은 보통 1이 되게 맞춤가중치는 제목, 저자, 본문 등 존에 부여함.좀 더 객관적인 가중치를 만들기 위해 기계학습을 사용할 수 있음한 질의어와 한 문서가 관계가 있는지 없는지 사람이 먼저 판별해 표시하고 이 표시에 맞추어 학습시킴. 오차는 정답과 예측값의 차의 제곱을 사용. 오차의 총합을 줄이는 방향으로 학습.벡터 공간 모델term-doc 매트릭스의 각 줄을 벡터라고 보면 됨. 등장 여부 대신 등장 빈도 표시.bag of words 모델벡터는 단어의 등장 순서를 반영할 수 없다.불린 모델에 비하면 일 보 후퇴한 부분이지만 rank를 사용하기 위해 감수한다.단어 등장 빈도 tftft,d는 문서 d에서 단어 t가 등장한 횟수를 의미한다. 그러나 그냥 사용하지는 않고 log tf를 사용한다.문서 등장 빈도 df불용어나 흔히 쓰이는 단어보다 드물게 등장하는 단어가 가치가 높다.그러니 너무 흔한 단어는 양수 가중치를 주되 다른 가치있는 단어보다는 낮게 주고 싶다.df는 항상 모든 문서의 수보다 같거나 작고, 단어의 정보량을 파악하는 척도이다.역 문서 등장 빈도 idft는 단어이고 N은 모든 문서의 수idft = log N/dft로그 tf 가중치만약 tf가 0보다 크다면 1 + log tf, 그렇지 않다면 0으로 한다.tf-idf 가중치tf와 idf가 모두 0보다 클 때 가중치 w는 로그 tf 가중치와 idf의 곱이다.한 문서에 대해 모든 단어의 tf-idf 가중치를 나열한 것이 벡터가 된다.벡터 거리벡터 거리가 가까울수록 관계 있는 문서라고 판단벡터 거리는 각도로 정한다. 코사인이 0도부터 90도 사이에서 단조감소하기때문에 코사인 값을 사용한다. 1에 가까울수록 각도가 작고, 두 벡터가 유사하다.두 벡터의 각도 차에 대한 코사인 값은 두 벡터의 내적과 두 벡터의 크기의 곱을 나눈 값과 같다.벡터 내적은 같은 자리의 성분을 서로 곱하고 모든 값을 더하면 된다.코사인 유사도코사인 유사도는 문서와 문서 사이의 유사도 검사 가능. 1에 가까울수록 두 문서가 유사하다고 볼 수 있다.문제 : 단어의 순서를 고려하지 못함 → 같은 단어 구성 다른 의미 고려 불가" }, { "title": "[하천 쓰레기 프로젝트] 프로젝트 개요", "url": "/satinbower-legacy/posts/it-data-structure-training-project/", "categories": "IT, Data Structure", "tags": "지식, IT, 자료구조, 과제, 프로젝트", "date": "2022-10-15 14:13:00 +0900", "snippet": "목차 프로젝트 공지 데이터 설명 문제 정의프로젝트 공지이 프로젝트는 2022년 2학기 자료구조실습 중간고사 대체 발표 및 기말고사 프로젝트를 위해 진행합니다. 문의사항이 있다면 교수님(yangjunahn@sungshin.ac.kr)께 문의하시기 바랍니다.프로젝트 주제하천 쓰레기 처리하기프로젝트 내용 하천 부유 쓰레기 사진 데이터를 직접 구성하고, 수강생 친구들과 공유하여 본인의 데이터 베이스를 구축합니다. 구축한 데이터 베이스를 바탕으로 원하는 문제를 정의하고, 자료구 조를 이용해 문제를 해결합니다.프로젝트 목표 수강생들은 직접 데이터를 제작하고, 나만의 데이터를 확보합니다. 다른 사람이 작성한 다양한 데이터를 사용해 봅니다. 문제를 정의하고, 접근해 봅니다. 자료 구조 알고리즘을 실제 문제에 활용해 봅니다.주의사항수강생 본인의 안전을 해치는 행위나 어떠한 형태의 불법적인 요소도 발생해서는 안됩니다.중간고사 대체 발표 발표 자료는 최대 3페이지의 PDF 발표 내용은 다음 두 가지 데이터 소개 : 예시, 정리 방법, 업로드 방법 등 문제 소개 : 문제 대상, 접근 방법 등 평가 요소 : 데이터의 양과 질, 문제의 질 등기말고사 프로젝트 발표 발표 자료는 최대 3페이지의 PDF 발표 내용은 다음 두 가지 데이터 : 다른 학우들의 데이터를 어떻게 사용하였는지 문제 : 문제를 소개하고 해결 방법 설명 평가 요소 : 본인 데이터가 많이 쓰였는지, 많은 데이터를 활용했는지, 문제의 질과 풀이가 창의적이고 적절했는지 등데이터 설명사진과 csv 파일 등의 프로젝트용 데이터는 다음의 깃허브 레포지토리에서 확인 가능하다.dapin1490/water-waste-pictures 모든 사진은 하천에서 발견되는 다양한 쓰레기를 찍은 것이다. 위에 링크된 레포지토리의 water-waste-picture 폴더에서 확인할 수 있으며 총 121장이다. 각 사진에 대한 정보(사진 크기, 쓰레기 종류 등)는 data.csv 파일에 저장되어 있다. data.csv 파일에는 사진의 파일명, 가로 세로 크기(pixel), 위도 및 경도 좌표(GRS80 Degree), 정해진 쓰레기 분류(일반, 플라스틱, 캔, 유리, 종이) 중 각 사진에 포함된 분류의 유무 표기가 작성되어 있다. 사진 크기는 300*400부터 4032*3024까지 다양하다(원본 사진은 4032*3024 크기이고, 다른 크기는 모두 직접 축소한 것이다). 예시 사진 보기 220910-1-산새공원.jpg 사진 번호 1, 크기 600*800, 좌표 (37.47, 126.79), 일반 쓰레기와 플라스틱 포함 220910-17-산새공원.jpg 사진 번호 17, 크기 1200*900, 좌표 (37.47, 126.79), 플라스틱 포함 220913-11-한울빛-일반.jpg 사진 번호 29, 크기 300*400, 좌표 (37.47, 126.8), 일반 쓰레기 포함 220919-10-성북천-종이.jpg 사진 번호 57, 크기 400*300, 좌표 (37.59, 127.02), 종이 포함 220919-66-성북천-스티로폼.jpg 사진 번호 105, 크기 4032*3024, 좌표 (37.59, 127.02), 플라스틱 포함문제 정의문제에 대해 한 생각 : 하천에 쓰레기가 있으면 치워야 한다. → 누가 치우나? 시민이 치울 수는 없고 공무원들이 치울 것이다. → 공무원은 쓰레기가 있다는 것을 어떻게 아나? 민원을 받는다. → 내가 할 수 있는 것은 무엇인가? 민원 처리 시뮬레이터를 만들자.요약 : 하천 쓰레기 민원 조회 시스템 만들기주요 기능 민원 : 여기 쓰레기가 있어요 신고 조회 : 현재 쓰레기 신고가 가장 많은 지역 순으로 정렬, 또는 다른 정렬 민원 처리 : 누적 쓰레기 신고가 많은 분류의 쓰레기부터 순서대로 인력 파견하여, 한 분류의 민원 쓰레기를 모두 해결구현필요한 구현 수단 : 쓰레기 종류별 누적 민원 수와 해당 민원들을 저장할 수 있는 크기가 5인 어떠한 객체와, 각 민원들을 저장할 자료구조. 종류별 누적 민원 수와 데이터를 저장할 자료구조 : 누적 민원 수와 해당 민원을 저장할 수 있는 클래스를 만들고, 그 클래스를 이용해 크기가 5인 객체 배열 생성 장점 : 배열의 각 요소에 O(1)로 접근 가능. 값의 수정이 용이하다. 단점 : 민원을 처리하고자 할 때는 매번 최댓값을 찾아야 한다. 이 프로젝트의 경우 배열 크기가 5이므로 연산 시간은 짧지만 시간복잡도는 O(n)이기 때문에 확장성이 떨어진다. 각 민원을 저장할 자료구조 : 벡터, 맵, 우선순위 큐 등 벡터를 쓸 경우 : 삽입/수정/삭제가 쉽다는 것이 장점이지만 따로 정렬하지 않으면 어떤 민원을 조회하고자 할 때 O(n) 만큼 시간이 걸린다는 것이 단점. STL find_if() 함수를 사용할 수 있긴 하지만 다른 자료구조를 사용하면 더 나은 처리를 할 수 있지 않을까? 맵을 쓸 경우 : 삽입/수정/삭제는 벡터와 유사하게 쉽고 어떤 민원을 조회하고자 할 때는 올바른 키를 사용하면 O(1)이라는 게 장점이고, 올바른 키를 사용할 수 없을 경우 결국엔 O(n)으로 탐색해야 한다는 점 또한 벡터와 마찬가지인 단점이다. 키는 중복되지 않으면서 사용자가 검색할 수 있어야 하기 때문에 키를 선택하는 것이 중요하다. 우선순위 큐를 쓸 경우 : 삽입/삭제는 가능하지만 수정이 어렵다. 탐색은 O(logn)으로 가능하다는 것이 장점이지만 이 또한 키로 사용된 정보에 한해서만 그런 것이고 키가 아닌 정보를 이용해 탐색하고자 할 경우 선형 자료구조보다 복잡하게 탐색해야 한다는 것이 단점이다. 정리 : 삽입/수정/삭제의 용이함은 선형 자료구조에서는 비슷하게 쉽고, 비선형 자료구조에서는 수정이 힘들지만 삽입과 삭제는 크게 다르지 않다. 탐색은 키를 이용해 검색하는 것이 가장 효율적이고, 키가 아닌 값을 이용해 검색하고자 할 경우 별도의 조치가 필요하다. 키를 이용해 검색하는 것은 마찬가지로 키를 사용하는 자료구조에서는 대체로 O(logn) 이하로 효율적이고, 키를 사용하지 않은 자료구조에서는 O(n)이다. 정렬은 자료구조를 정한 후에 고민해도 늦지 않다. 어떻게든 구현할 방법은 있을 것이다. 어려운 점 조회의 다양성 보장 누적 신고 수 기준 외에도 지역명 가나다순, 최근 신고 순 등 다양한 정렬을 가능하게 하고 싶다. 노드 구현은 어렵지 않다. 그 노드를 사용한 적절한 자료구조의 구현이 전혀 생각나지 않는다. 검색 기능 구현 - 다양한 검색 조건 제공하기 키를 사용하든 사용하지 않든, 키가 아닌 값을 이용한 검색은 O(n)보다 효율적인 연산을 구현하기 어렵다. 키를 이용한 탐색을 효율적으로 만들 방법은 얼마든지 있으나, 그 이외의 모든 경우가 문제다. SQL 데이터베이스를 쓰고 싶지만 그건 자료구조라고 보기 힘들지 않나? SQL을 조잡하게나마 모방할 방법을 찾아보는 것이 나을 것이다. 정 안된다면 키 이외의 값을 이용한 검색은 제공하지 않는 것도 방법이다.구현 시안 누적 노드 클래스 - int 쓰레기 분류 번호 - int 누적 민원 수 - vector&lt;민원 노드&gt; 해당 민원 벡터 + 최소한 쓰레기 분류 번호 하나를 인자로 받는 생성자 + 누적 민원 수 변경 메소드 + 쓰레기 분류 번호 반환 메소드 + 누적 민원 수 반환 메소드 + 민원 벡터 반환 메소드 민원 노드 클래스 - string 사진 파일명 - pair&lt;int, int&gt; 사진 크기 - pair&lt;int, int&gt; 좌표 - int[5] 쓰레기 유무 표시 + 모든 멤버 변수를 입력받는 생성자 + 각 멤버 변수별 값을 반환하는 메소드들 + 쓰레기 유무 배열 변경 메소드 누적 민원 배열 : 크기가 5인 누적 노드 객체 배열. 각 쓰레기별 누적 민원 수와 그 민원을 관리한다. 민원 처리는 한번에 모두 처리하는 것을 전제로 하기 때문에 별도의 탐색 메소드는 갖추지 않았고, 민원을 해결할 때 민원 노드 벡터를 clear한다. 민원 노드 클래스의 몇 가지 정보를 키로 사용하는 맵들 : 파일명, 사진 크기, 좌표 등은 모두 중복 가능한 정보이므로 중복을 허용하는 멀티맵을 사용한다. 탐색 연산(민원 검색)에 사용한다. 모든 민원을 저장하는 하나의 민원 노드 벡터와 STL sort 함수에 전달할 몇 가지 compare 함수 : 각 요소별 민원 전체 정렬 조회를 위해 사용한다. 기본적인 정렬 우선순위는 좌표, 파일명, 사진 크기이며 compare 함수도 좌표 우선 정렬, 파일명 우선 정렬, 사진 크기 우선 정렬 함수로 세 가지 구현한다.메모리의 절약을 포기하고 조회 및 탐색의 효율을 우선으로 했다. 탐색은 정렬 후 이진 탐색으로 하면 STL sort 함수의 O(nlogn) + O(logn)이므로 O(nlogn)을 보장할 수 있고 삽입은 O(1), 삭제는 검색 후 삭제를 전제로 하므로 탐색과 같다. 같은 데이터를 다른 키로 저장하는 맵을 만듦으로써 조회의 편의성과 다양성을 보완했으나 삽입/삭제/수정을 모든 컨테이너에 동일하게 처리해야 한다는 번거로움이 있다." }, { "title": "[자료구조] 균형 이진 트리, AVL 트리", "url": "/satinbower-legacy/posts/it-avl-tree/", "categories": "IT, Data Structure", "tags": "지식, IT, 자료구조, 균형 이진 트리, AVL 트리, 과제", "date": "2022-10-02 22:03:00 +0900", "snippet": "과제아래 내용을 포함하는 포트폴리오를 작성하고, 웹페이지 주소를 제출합니다.1. Data structures augmentation 코딩- Rank 구현- AVL tree 구현2. AVL tree 정의 등 강의 내용 정리*Geeks for geeks 참조하세요.https://www.geeksforgeeks.org/avl-tree-set-1-insertion/https://www.geeksforgeeks.org/avl-tree-set-2-deletion/3. Leet code 문제 풀이https://leetcode.com/problems/balanced-binary-tree/목차 균형 이진 트리 AVL 트리 삽입과 삭제 회전 유형 LL 타입 RR 타입 RL 타입 LR 타입 관련 글[자료구조] 이진 탐색 트리 Rank균형 이진 트리* 이 글은 [자료구조] 이진 탐색 트리 Rank에서 이어지는 글이며, 독자가 이진 탐색 트리에 대해 알고 있음을 전제로 한다. 이진 탐색 트리의 개념에 대한 글은 여기에서 볼 수 있다.보통 이진 탐색 트리는 탐색 연산의 시간 복잡도를 O(logn)으로 간주하며, 그것이 최선이다. 그러나 모든 이진 탐색 트리가 최선을 보장하지는 못한다. 예를 들어 정렬된 배열이 순서대로 이진 탐색 트리에 입력되었다고 해보자. 최선을 보장하지 못하는 이진 탐색 트리는 첫 번째 요소를 루트로 하고 다음으로 입력되는 모든 값을 적절한 자리에 넣을 것이다. 결과적으로 그 트리의 모양은 배열과 다를 바 없게 된다. 그러므로 이 트리는 O(n)의 시간 복잡도를 갖는다.항상 그랬듯이 내가 문제점을 설명하는 건 다 해결하기 위해서다. 어떻게 할 수 있을까? 답은 이 본문의 소제목에 있다. 배열처럼 곧게 뻗은 트리를 구부려 트리처럼 만들어주면 된다. 그것이 균형 트리이고, 지금은 이진 트리에 대해서만 공부하고 있기 때문에 균형 이진 트리이다.내가 공부하는 교재[1]의 설명에 따르면 균형 트리를 만드는 방법은 아주 다양하고 복잡하다고 한다. 그렇기 때문에 책에서는 AVL 트리에 대해서만 설명하였고, 지금은 나도 그에 대해서만 공부할 것이다.AVL 트리 AVL 트리는 Adelson-Velskii와 Landis에 의해 제안된 트리로 각 노드에서 왼쪽 서브트리의 높이와 오른쪽 서브트리의 높이 차이가 1 이하인 이진 탐색 트리를 말한다.[1]AVL 트리의 정의는 간단하게 책에 써있는 것을 그대로 인용했다. AVL 트리는 저 균형을 유지하기 위해 트리의 균형이 깨지는 순간 노드를 재배치해 다시 균형 상태로 만든다. 그렇게 함으로써 O(logn)의 연산 시간을 보장한다. 탐색 연산은 이진 탐색 트리와 같고, 바꾸어야 할 것은 삽입과 삭제 연산이다.삽입과 삭제 연산을 설명하기에 앞서, 트리의 높이에 대해 정의해야 한다. AVL 트리에서 말하는 높이란, 어떤 노드에 대하여 그 노드에서 찾아갈 수 있는 가장 낮은 리프노드까지의 높이 차를 말한다. 리프노드는 자신이 리프노드이기 때문에 높이가 0이고, 리프노드의 부모 노드는 1, 그 위의 노드는 2가 되는 방식이다. 트리 전체의 레벨 수를 의미하는 높이와는 다르다. 그리고 AVL 트리의 양쪽 서브트리 높이 차이는 균형 인수라고 부른다.삽입과 삭제AVL 트리에 새 요소를 삽입할 때는 통상의 트리 삽입과 같은 연산을 수행한다. 이후 새 요소의 부모 노드의 높이를 업데이트하고 균형을 검사하는 것이다. 새 노드 위의 부모 노드의 균형 상태에 따라 수행할 회전 연산이 결정된다.삭제 연산도 삽입 연산과 마찬가지로 삭제를 한 후에 균형을 바로잡는다. 이때도 부모 노드의 높이를 업데이트하고 균형을 검사하며, 회전 연산의 유형 결정 방식은 삽입 연산과 동일하다.삽입 및 삭제의 과정은 참고자료 [2], [3]을 참고하여 서술했다.회전 연산AVL 트리에서 사용하는 회전 연산은 네 가지 유형이 있고, 특정 노드의 균형 인수가 ±2일 때 회전 연산을 수행한다. 아래 문단에 첨부된 모든 회전 유형 이미지의 출처는 참고자료 [1]이다.LL 타입왼쪽으로만 자식이 이어지는 형태로 균형이 깨졌을 때 사용한다. 예를 들어 6 → 5 → 2 순서로 노드가 삽입된 경우가 이에 해당하고, 이를 일반화하면 어떤 조상 노드의 왼쪽 서브트리의 왼쪽 서브트리에 자식이 추가된 상황이다. 해당 조상 노드가 그 왼쪽 서브트리의 오른쪽 자식이 되도록 바꾸어 해결할 수 있다. 그림으로 보면 아래와 같다. 일반적인 경우의 LL 회전프로그램으로 구현할 때는 다음과 같은 알고리즘으로 한다.rotate_LL(A) B ← A의 왼쪽 자식 B의 오른쪽 자식을 A의 왼쪽 자식으로 만든다. A를 B의 오른쪽 자식 노드로 만든다.RR 타입LL 타입과 반대로 오른쪽 서브트리가 오른쪽으로 길어지는 경우이다. 해결할 때에도 LL 타입과 반대 방향으로 회전하면 된다. 그림으로 보면 아래와 같다. 일반적인 경우의 왼쪽 회전프로그램으로 구현할 때는 다음과 같은 알고리즘으로 한다.rotate_RR(A) B ← A의 오른쪽 자식 B의 왼쪽 자식을 A의 오른쪽 자식으로 만든다. A를 B의 왼쪽 자식 노드로 만든다.RL 타입어떤 노드의 오른쪽 서브트리의 왼쪽 서브트리에 새 노드가 추가되어 균형이 깨지는 경우이다. 이 경우 LL 회전을 한 후 RR 회전을 하면 된다. 그림으로 보면 아래와 같다. 일반적인 RL 회전프로그램으로 구현할 때는 다음과 같은 알고리즘으로 한다.rotate_RL(A) B ← A의 오른쪽 자식 rotate_LL(B)가 반환하는 노드를 A의 오른쪽 자식으로 만든다. rotate_RR(A)LR 타입어떤 노드의 왼쪽 서브트리의 오른쪽 서브트리에 새 노드가 추가되어 균형이 깨지는 경우이다. RL 타입과 반대로 RR 회전을 한 후 LL 회전을 하면 된다. 일반적인 왼쪽-오른쪽 회전프로그램으로 구현할 때는 다음과 같은 알고리즘으로 한다.rotate_LR(A) B ← A의 왼쪽 자식 rotate_RR(B)가 반환하는 노드를 A의 왼쪽 자식으로 만든다. rotate_LL(A)----------------------------------------------혹시나 내가 글을 완성하지 못할 때를 대비해 써둡니다. 코로나 의심 증상이 있어서 검사도 받고 하루 쉬느라 글을 완성하지 못했습니다. 이상 변명 끝.추가 설명 : 확진됐음참고 자료[1] 『C++로 쉽게 풀어쓴 자료구조』, 천인국ㆍ최영규 지음, 생능 출판사[2] AVL Tree | Set 1 (Insertion), https://www.geeksforgeeks.org/avl-tree-set-1-insertion/[3] AVL Tree | Set 2 (Deletion), https://www.geeksforgeeks.org/avl-tree-set-2-deletion/" }, { "title": "22.09.30 a little cold", "url": "/satinbower-legacy/posts/daily-221001/", "categories": "내가 해냄", "tags": "내가 해냄, html, css", "date": "2022-10-01 13:27:00 +0900", "snippet": "텍스트에 밑줄 긋기html 태그로는 &lt;u&gt;를 사용할 수 있지만, 모질라의 MDN Plus 가이드에 따르면 HTML4에서 사용을 중단했다가 의미가 바뀌어 다시 돌아온 태그이기 때문에 단순 밑줄을 목적으로 이 태그를 사용해서는 안된다고 한다[1]. 대신 css의 text-decoration 속성을 사용한다. 나는 단순 밑줄만 필요해서 간단하게 text-decoration: underline;만 쓰고 말았지만 내가 참고한 블로그[2]에서는 다양한 밑줄을 표시하는 방법을 알려주고 있다. 자세한 건 참고 자료들을 보자. 이번에도 잘 배웠다!참고 자료[1] MDN Web Docs HTML 요소 참고서 - &lt;u&gt; https://developer.mozilla.org/ko/docs/Web/HTML/Element/u[2] [HTML/CSS] 글자 밑줄 긋기 (위치, 두께, 색깔, 모양 지정하기) text-decoration https://hianna.tistory.com/679[3] [Html] Font 속성/스타일 (굵기,기울기,밑줄,취소선)등등 https://coding-factory.tistory.com/177[4] a 태그 텍스트 밑줄 없애기 (text-decoration 사용법) https://rgy0409.tistory.com/4790[5] CSS 네이밍 규칙 https://uipac.com/451[6] 네이밍 컨벤션 BEM https://tech.elysia.land/네이밍-컨벤션-bem-b291ba7bff01" }, { "title": "[자료구조] 자료구조와 알고리즘", "url": "/satinbower-legacy/posts/it-cpp-ds-chap01/", "categories": "IT, Data Structure", "tags": "지식, IT, 자료구조, 알고리즘", "date": "2022-09-30 21:00:00 +0900", "snippet": "주교재『C++로 쉽게 풀어쓴 자료구조』, 천인국ㆍ최영규 지음, 생능 출판사공부 범위 : 챕터 1 자료구조와 알고리즘1.1 자료구조자료구조데이터를 효율적으로 사용하기 위해 정리하고 조직화하는 구조. 크게 두 가지로 나눌 수 있다. 정수, 실수, 문자와 같이 보통 프로그래밍 언어에서 기본적으로 제공하는 단순 자료구조와 여러 자료구조가 복합적으로 구성된 복합 자료구조가 있다. 이중에서 복합 자료구조는 다시 선형 구조와 비선형 구조로 나눌 수 있다.선형 자료구조자료들이 순서대로 나열되는 구조로 배열과 연결리스트, 큐, 덱 등이 있다. 데이터에 접근하는 방식은 순서 접근과 직접 접근 두 가지가 있다. 순서 접근 방법은 일정한 시작점을 기준으로 특정 방향으로 이동하여 원하는 자료를 찾고, 직접 접근 방법은 인덱스를 이용해 어떤 요소든 한번에 접근할 수 있다. 일부 선형 자료구조는 접근이 가능한 항목이 맨앞 또는 맨뒤로 제한된다.비선형 자료구조자료들이 선형 순서보다 복잡한 연결을 갖는다. 트리와 그래프가 이에 속한다. 두 자료구조 모두 나무의 뿌리에서 특정 가지를 찾아가는 경로를 생각하면 이해하기 쉽다. 단순한 직선이 아니라 갈림길이 존재한다는 점에서 탐색의 시간을 줄이거나 경로를 탐색하는 데에 이용되기도 한다.1.2 알고리즘프로그램과 알고리즘사전적으로 “어떤 문제의 해결을 위하여, 입력된 자료를 토대로 하여 원하는 출력을 유도하여 내는 규칙의 집합”을 의미한다[1]. 사용하는 프로그래밍 언어와 무관하게 문제를 해결하는 절차 그 자체를 정의한다.알고리즘이 알고리즘으로 사용되기 위해서는 다음의 5가지 조건이 필요하다.(1) 입력 : 0개 이상의 입력이 존재해야 한다.(2) 출력 : 1개 이상의 출력이 존재해야 한다.(3) 명백성 : 각 명령어의 의미가 명확해야 한다.(4) 유한성 : 한정된 수의 단계 후에 반드시 종료되어야 한다.(5) 유효성 : 각 명령어는 실행 가능한 연산이어야 한다.프로그램은 자료구조와 알고리즘의 조합으로 이루어진다. 책에서는 프로그램에 사용할 자료구조를 정하면 알고리즘이 정해진다고 설명했다.알고리즘 기술 방법알고리즘을 표현하는 방법은 4가지이다.(1) 자연어인간이 쓰는 말로 알고리즘을 서술한다. 쓰기는 편하지만 모호하지 않게 서술하도록 신경써야 한다.(2) 흐름도책의 설명에 따르면 명확하게 표현할 수 있지만 알고리즘이 복잡해지면 흐름도도 복잡해지는 단점이 있다고 한다.(3) 유사 코드(pseudo-code)자연어와 프로그래밍 언어의 중간 쯤 되는 서술 방식이다. 알고리즘의 표현에 흔히 사용한다고 한다. 특정 언어의 문법에 구애받지 않으면서도 프로그래밍 언어와 비슷하고, 실제 프로그래밍 언어로 서술할 때의 여러 가지 문제점을 가릴 수 있다. 문제점을 가린다고 해서 나쁜 건 아니고, 자잘한 프로그래밍 언어의 문법에 신경쓰지 않고 알고리즘만의 흐름에 집중할 수 있게 해준다. 대입 연산자와 등호의 의미가 실제 프로그래밍 언어가 다소 다르다는 점에 주의해야 한다.(4) 특정 프로그래밍 언어책의 설명으로는 알고리즘을 가장 정확히 표현할 수 있는 방법이라고 한다. 세 번째 방법과 달리 자잘한 문법에도 신경써야 하기 때문에 알고리즘 이해에는 방해가 될 수 있다.1.3 추상 자료형추상화복잡한 자료, 모듈, 시스템 등을 간략화하고 핵심적인 개념이나 기능을 간추려 낸다. 간단히 말해 복잡한 것을 단순하게 보이게 만드는 것을 말한다.추상 자료형자료형을 추상화한 것이다. 자료나 그 연산이 무엇인지는 정의하지만 그것을 어떻게 구현할지는 정의하지 않는다. 추상 자료형을 정의할 때는 데이터를 먼저 정의하고 나서 연산을 정의한다. 연산에는 연산의 이름, 매개변수, 수행하는 기능 등을 서술한다.추상 자료형을 프로그램으로 구현할 때는 사용자에게 인터페이스만을 공개한다. 이렇게 하면 나중에 프로그램의 내부적 구조나 구현 등이 바뀌어도 사용자는 변함없이 프로그램을 사용할 수 있다. 이런 식으로 내부 구현과 사용자를 분리하는 것이 추상화의 요점이다.1.4 알고리즘의 성능 분석효율적인 알고리즘은 실행 시간이 짧고 메모리를 적게 사용하는 알고리즘이다. 보통은 메모리보다 실행 시간을 우선한다.실행 시간 측정 방법알고리즘의 실행 시간을 알기 위해 알고리즘을 실제 프로그램으로 작성하여 직접 실행 시간을 측정하는 방법이 있다. 주로 clock() 함수를 이용한다고 한다. 측정은 편하지만 이 방법에는 문제가 좀 있다. (1) 알고리즘을 실제로 구현해야 하고, (2) 비교 대상이 되는 알고리즘을 모두 같은 컴퓨터에서 실행해야 하고, (3) 사용한 소프트웨어도 동일해야 하고(보통 컴파일 방식 언어가 인터프리터 방식 언어보다 실행 속도가 빠르다), (4) 실험해보지 않은 입력 데이터에 대해서는 동일한 실행 시간을 주장할 수 없다.문제가 생각보다 많지만 다행히도 하드웨어 기기를 사용하지 않고도 알고리즘의 실행 시간을 계산할 수 있는 다른 방법이 있다.알고리즘의 복잡도 분석 방법이 부분에 대해서는 다음 글을 참고하자.[자료구조] Big-O와 이진 탐색 트리 https://dapin1490.github.io/satinbower/posts/it-bin-search-tree/1.5 자료구조 표기법ADT - Class Diagram - C++ 구현이 책에서는 자료구조를 세 단계에 걸쳐 표현한다. 추상 자료형 ADT로 개념을 정의하고, UML 클래스 다이어그램으로 구조를 설계하고, C++ 클래스로 해당 자료구조를 구현한다. 이 책은 STL 라이브러리를 사용하기보다는 직접 클래스를 구성하고 각 자료구조를 구현하는 것에 더 중점을 두어 설명하고 있지만 나는 가능한 한 STL 라이브러리를 이용해 공부할 생각이다. 그러니 교재의 코드는 STL 라이브러리로 대체하지 못한 경우에 주로 쓰게 될 것이다.UML DiagramUML : Unified Modeling Language, 통합 모델링 언어의 약자책에서는 소프트웨어 개발에서 시스템의 구조와 상호작용, 컴포넌트 관계, 업무 흐름 등을 표현하는 통합된 객체지향개발 표준통합 모델링 언어라고 정의하고 있다. 너무 복잡하니 어떤 모델을 서술하는 일관된 표현 방식이라고 생각하자. 여기서는 클래스를 나타내는 데 사용한다. 기호와 화살표 등이 다 의미가 있긴 한데, 이에 대해서는 각자 책을 직접 보자.참고 자료[1] 네이버 국어사전 - 알고리즘 https://ko.dict.naver.com/#/entry/koko/b925552564c544f4bb5b3db6970b2e29" }, { "title": "22.09.30 cold and hot", "url": "/satinbower-legacy/posts/daily-220930/", "categories": "내가 해냄", "tags": "내가 해냄, html", "date": "2022-09-30 00:09:00 +0900", "snippet": "참고 문헌에 링크 걸기전부터 위키백과처럼 참고 문헌을 번호 달린 리스트로 넣고 본문에 삽입된 번호를 클릭하면 각주로 링크되는 걸 만들고 싶었는데, 오늘 위키백과 페이지 소스 보기로 배워왔다. 각주로 들어가는 참고 문헌 리스트는 마크다운이 아니라 html ordered list로 만들어서 각각의 &lt;li&gt; 요소마다 \"cite_note-n\" 같은 id를 줘서 본문에 삽입된 각주 번호에 그 id에 대한 &lt;a&gt; 링크를 걸면 돼. 예를 들면 아래처럼.**Data structures augmentation** : 데이터 구조가 효율적으로 구현될 수 있도록 기존 데이터 구조에 몇 가지 추가 정보를 추가하는 것을 의미한다&lt;a href=\"#cite_note-1\"&gt;[1]&lt;/a&gt;.## 참고 자료&lt;ol&gt; &lt;li id=\"cite_note-1\"&gt;&lt;a href=\"https://www.includehelp.com/data-structure-tutorial/augmenting-data-structure.aspx\" target=\"_blank\" title=\"\"&gt;Augmenting Data Structure&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;좋은 걸 배웠다! 전에 썼던 글들 다 이렇게 고쳐야겠어.아니 근데 생각보다 고칠 글이 없네.. 내가 글 중간중간에 주석 잘 안 넣거든요. 지금까지는 그게 안 되는 글만 썼으니까.." }, { "title": "[자료구조] 이진 탐색 트리 Rank", "url": "/satinbower-legacy/posts/it-bst-rank/", "categories": "IT, Data Structure", "tags": "지식, IT, 자료구조, 이진 탐색 트리, 과제", "date": "2022-09-29 23:55:00 +0900", "snippet": "과제아래 내용을 포함하는 포트폴리오를 작성하고, 웹페이지 주소를 제출합니다.1. Data structures augmentation 코딩- Rank 구현- AVL tree 구현2. AVL tree 정의 등 강의 내용 정리*Geeks for geeks 참조하세요.https://www.geeksforgeeks.org/avl-tree-set-1-insertion/https://www.geeksforgeeks.org/avl-tree-set-2-deletion/3. Leet code 문제 풀이https://leetcode.com/problems/balanced-binary-tree/목차 Data structures augmentation Rank 구현 원래 예시 코드에서 달라진 점 노드 클래스 탐색 메소드 삽입 메소드 삭제 메소드 Rank 메소드 다음 글[자료구조] 균형 이진 트리, AVL 트리Data structures augmentationData structures augmentation : 데이터 구조가 효율적으로 구현될 수 있도록 기존 데이터 구조에 몇 가지 추가 정보를 추가하는 것을 의미한다[1]. 지난 글에서는 트리에서 각 노드가 갖는 자손 노드의 수를 노드 클래스의 멤버 변수로 추가하여 특정 값보다 크거나 작은 값의 개수를 구하는 메소드를 구현했는데, 이것이 Data structures augmentation 자료구조 증강에 해당한다. 편의상 앞으로는 자료구조 증강이라 부르겠다.Rank 구현이진 탐색 트리는 모든 탐색을 루트에서부터 시작하고, 루트에서 수많은 가지로 뻗어나가는 형태이기 때문에 특정 범위의 값에 대한 연산이 곤란한 경우가 있다. 어떤 값보다 큰 요소의 개수, 작은 요소의 개수를 구하는 문제가 이런 문제이다. 이를 해결하기 위해 이진 탐색 트리의 각 노드에 자기 자신을 포함해 해당 노드가 갖는 자손 노드의 수를 멤버 변수로서 함께 저장할 수 있다. 코드는 지난번에 이미 보여주긴 했지만 이번엔 내가 그 코드를 구상한 과정을 설명해보겠다.전체 코드 깃허브에서 보기코드 실행 결과 보기원래 예시 코드에서 달라진 점원래 예시 코드 깃허브에서 보기코드 실행 결과 보기원래 예시 코드에는 노드 클래스에 멤버 변수만 있고 모든 메소드가 트리 클래스에 있었다. 노드 클래스의 멤버 변수가 public으로 선언되었기 때문에 getter나 setter도 없이 모든 변수에 직접 접근했었다. 내가 Rank를 구현하기 위해 코드를 바꾸기 시작하면서, 이 변수들에 직접 접근하는 건 실수의 여지가 많다고 생각해서 getter와 setter를 만들고 멤버 변수는 모두 private으로 바꿨다. 하는 김에 생성자도 추가했는데 이건 필요해서 했다기보다는 내가 허전해서 만들었다. 어쨌든 일단은 이게 첫 번째이다.두 번째는 재귀로 구현된 대부분 메소드를 반복문으로 바꿨다는 것이다. 루트에서 특정 노드까지 따라가면서 자손 노드의 수를 세도록 만들 계획이었는데, 재귀로 해서는 개수가 제대로 세어지지 않을 게 뻔했기 때문에 최대한 재귀를 없애야 했다. 그 결과 삭제 메소드와 중위순회 메소드를 제외한 모든 메소드를 반복으로 구현할 수 있었다. 삭제 메소드는 한번에 모든 과정을 반복으로 구현하려다가 포인터를 다루는 부분에서 오류가 났고, 그것을 내 힘으로 고치지 못하는 문제가 있었지만, 약간의 과정을 추가하여 해당 오류를 피하고 재귀를 유지하면서 구현할 수 있었다. 이에 대한 설명은 삭제 메소드를 설명할 때 하겠다. 덧붙여, 중위순회 메소드는 카운트 변수를 함께 출력한다는 점 이외에는 바꿀 것이 없었기 때문에 설명하지 않는다.노드 클래스가장 기본적으로 각 노드가 자신을 포함한 자손 노드의 수를 저장할 수 있어야 한다. 편의상 카운트 변수라고 부르자. 자기자신을 포함하기 때문에 리프노드라도 기본값은 1에서 시작한다. 이 값은 생성자에는 포함하지 않았고 멤버 변수 선언에서부터 초기화했다. 카운트 변수는 자주 증감연산을 할 수 있고, 보통은 1 단위로 증감하기 때문에 외부에서 불 때 구분하기 쉽도록 증감 메소드를 따로 만들었다.카운트 변수 이외에도 다양한 getter와 setter를 추가했고, 해당 노드가 리프노드인지 확인하는 메소드도 추가했다. 리프노드 확인 메소드는 삭제 연산에서 사용한다.class node {private: int data; node* left; node* right; int cnt = 1;public: node(int d, node* l, node* r) { data = d; left = l; right = r; } ~node() {} int getData() { return data; } node* getLeft() { return left; } node* getRight() { return right; } int getcnt() { return cnt; } void setLeft(node* le) { left = le; } void setRight(node* ri) { right = ri; } void upcnt() { cnt += 1; } void downcnt() { cnt -= 1; } void setData(int d) { data = d; } bool isLeaf() { return left == nullptr &amp;&amp; right == nullptr; }};탐색 메소드탐색을 재귀에서 반복으로 바꾸는 것은 쉽다. 재귀 호출이 있던 부분을 모두 서브트리로 이동하는 것으로 바꾸고, 탐색의 모든 과정을 while 반복문 안에 넣으면 된다. 탐색이 끝나면 결과를 바로 return한다. 특정 값을 찾는 탐색은 트리를 전혀 조작하지 않기 때문에 카운트 변수와는 상관이 없다. public 메소드와 private 메소드가 따로 구현된 것은 원래의 예시 코드를 그대로 따랐다.private: node* find_impl(node* current, int value) { // private 탐색 메소드 while (true) { if (current == nullptr) { // 현재 탐색하는 노드가 NULL인 경우 cout &lt;&lt; \"No matching value found for \" &lt;&lt; value &lt;&lt; \".\\n\"; return NULL; } if (current-&gt;getData() == value) { // 원하는 값 찾음 cout &lt;&lt; value &lt;&lt; \" has been found.\\n\"; return current; } else if (value &lt; current-&gt;getData()) { // 원하는 값이 더 작음 cout &lt;&lt; \"current is \" &lt;&lt; current-&gt;getData() &lt;&lt; \". pointer moved to left.\\n\"; current = current-&gt;getLeft(); // 왼쪽 서브트리로 이동 } else { // 위의 모든 선택문을 패스했다면 원하는 값이 더 큰 경우임 cout &lt;&lt; \"current is \" &lt;&lt; current-&gt;getData() &lt;&lt; \". pointer moved to right.\\n\"; current = current-&gt;getRight(); // 오른쪽 서브트리로 이동 } } }public: node* find(int value) { // 특정 값 탐색 메소드 return find_impl(root, value); // 따로 구현된 private 탐색 메소드 호출 }삽입 메소드탐색 메소드와 같은 방식으로 하나의 큰 while문 안에 코드를 모두 넣고, 서브트리로 이동하는 코드만 재귀에서 포인터 이동으로 바꾸었다. 주의해야 할 점은 트리를 조작하는 메소드이기 때문에 카운트 변수도 같이 다루어야 한다는 것이다. 삽입 연산이니 새 노드가 추가되는 자리에 따라 그 조상 노드는 모두 카운트 변수가 1씩 증가해야 한다.삽입 연산은 방향이 정해져 있어 되돌아가는 일이 없으니 루트부터 매번 노드를 이동해 반복을 시작할 때마다 카운트 변수를 먼저 1씩 증가시키고 삽입 연산을 수행하도록 했다. public으로 정의된 함수는 크게 바꾸지 않았다.private: void insert_impl(node* current, int value) { // private 삽입 메소드 while (true) { current-&gt;upcnt(); // 노드가 삽입되는 경로를 따라 카운트 증가 if (value &lt; current-&gt;getData()) { // 삽입할 값이 현재 탐색하는 노드보다 작음 if (current-&gt;getLeft() == nullptr) { // 왼쪽 서브트리 없음 current-&gt;setLeft(new node{ value, NULL, NULL }); // 바로 붙임 cout &lt;&lt; \"current is \" &lt;&lt; current-&gt;getData() &lt;&lt; \", \" &lt;&lt; value &lt;&lt; \" is inserted left\\n\"; return; } else { // 왼쪽 서브트리 있음 current = current-&gt;getLeft(); // 왼쪽 서브트리로 이동 } } else { // else: 삽입할 값이 현재 탐색하는 노드보다 크거나 같음 if (current-&gt;getRight() == nullptr) { // 오른쪽 서브트리 없음 current-&gt;setRight(new node{ value, NULL, NULL }); // 바로 붙임 cout &lt;&lt; \"current is \" &lt;&lt; current-&gt;getData() &lt;&lt; \", \" &lt;&lt; value &lt;&lt; \" is inserted right\\n\"; return; } else { // else: 오른쪽 서브트리 있음 current = current-&gt;getRight(); // 오른쪽 서브트리로 이동 } } } }public: void insert(int value) { // 삽입 메소드 if (root == nullptr) { // 루트가 비어있다면 root = new node{ value, nullptr, nullptr }; // 루트에 바로 넣음 cout &lt;&lt; value &lt;&lt; \" is inserted into root\\n\"; } else // else: 루트가 비어있지 않다면 insert_impl(root, value); // 따로 구현된 private 삽입 메소드 호출 }삭제 메소드삭제 메소드는 원래 private 메소드에서 모든 과정을 수행하고 public 메소드는 private 메소드를 호출하는 역할만 갖고 있었지만, 카운트 변수를 조작하는 과정을 추가하면서 원래 private 메소드가 수행하던 일부 과정을 public 메소드가 수행하게 되었다.우선 삭제의 과정을 간단히 정리해보자.(1) 삭제할 노드를 찾는다.    (1.1) 삭제할 노드가 없으면 NULL을 반환하고 종료.(2) 삭제할 노드가 서브트리를 얼마나 갖고 있는지 검사한다.    (2.1) 서브트리가 없다면 노드 삭제 후 오른쪽 서브트리를 반환하며 결과적으로 NULL이 반환된다.    (2.2) 한쪽 서브트리만 있다면 노드 삭제 후 해당 서브트리의 포인터를 반환한다.(3) 삭제할 노드에 양쪽 서브트리가 다 있다면 후계자를 찾아 삭제할 노드의 데이터를 후계자의 것으로 대체한다.(4) 후계자로 쓰인 노드를 삭제하기 위해 원래 삭제할 노드의 오른쪽 서브트리에서부터 다시 1번 과정을 시작한다. 이때 원래 삭제하려고 했던 노드와 후계자 노드가 모두 같은 값을 갖고 있는 상태이기 때문에 트리 내의 키가 중복되어 삭제할 노드를 잘못 찾는 문제를 방지하기 위해 오른쪽 서브트리에서 탐색을 시작한다.나는 위의 과정 중 노드가 가진 서브트리의 수를 검사하고 후계자를 선출해 대체하는 부분을 public 메소드로 옮기고, private 메소드에는 순수하게 목표한 노드를 찾아가 삭제하는 과정만 남겼다. 그리고 두 가지 메소드로 분리된 그 과정들의 사이에 카운트 변수를 업데이트하는 메소드를 새로 정의해 호출하였다. 카운트 변수를 업데이트하는 메소드는 탐색 메소드와 유사하지만, 목표한 노드가 반드시 있음을 전제로 하고 경로상의 모든 노드의 카운트 변수를 1씩 감소시켜야 한다는 차이가 있다. 목표한 노드가 반드시 있다는 것은 이 메소드를 호출하기 전 탐색 메소드를 통해 확인함으로써 보장한다.메소드의 개수만 해도 4개가 하나의 작업을 위해 쓰이고, 이중 내가 수정하거나 만든 것이 3개이기 때문에 이 부분 코드가 좀 길다. 후계자 노드를 찾는 메소드는 수정하지 않았으므로 아래 코드블록에 포함하지 않는다. 전체 코드는 여기에서 볼 수 있다.private: node* delete_impl(node* start, int value) { // private 특정 값 삭제 메소드 cout &lt;&lt; \"current node is \" &lt;&lt; (start ? to_string(start-&gt;getData()) : \"NULL\") &lt;&lt; \".\\n\"; if (!start) { // 현재 노드가 NULL cout &lt;&lt; \"No value matches \" &lt;&lt; value &lt;&lt; \".\\n\"; return NULL; // 삭제한 노드 없음, NULL 반환 } if (value &lt; start-&gt;getData()) // 삭제할 값이 현재 노드보다 작음 start-&gt;setLeft(delete_impl(start-&gt;getLeft(), value)); // 왼쪽 서브트리에 삭제 메소드 다시 호출 else if (value &gt; start-&gt;getData()) // else if: 삭제할 값이 현재 노드보다 큼 start-&gt;setRight(delete_impl(start-&gt;getRight(), value)); // 오른쪽 서브트리에 삭제 메소드 다시 호출 else { // else: 삭제할 값이 현재 노드와 같음 if (!start-&gt;getLeft()) { // 왼쪽 서브트리가 없음 cout &lt;&lt; \"there is no left subtree. bring the right subtree.\\n\"; auto tmp = start-&gt;getRight(); // 현재 노드의 오른쪽 서브트리를 가져옴 cout &lt;&lt; \"delete \" &lt;&lt; value &lt;&lt; \".\\n\"; delete start; // 현재 노드를 지움 return tmp; // 아까 가져온 오른쪽 서브트리 반환 } if (!start-&gt;getRight()) { // 오른쪽 서브트리가 없음 cout &lt;&lt; \"there is no right subtree. bring the left subtree.\\n\"; auto tmp = start-&gt;getLeft(); // 현재 노드의 왼쪽 서브트리 가져옴 cout &lt;&lt; \"delete \" &lt;&lt; value &lt;&lt; \".\\n\"; delete start; // 현재 노드를 지움 return tmp; // 아까 가져온 왼쪽 서브트리 반환 } } return start; } void recount(node* value) { // 노드 삭제를 위해 누적 노드 개수를 수정하는 메소드 node* current = root; // 루트에서 시작 while (true) { if (!current) { // 현재 탐색하는 노드가 NULL인 경우 cout &lt;&lt; \"error: No matching value found for \" &lt;&lt; value-&gt;getData() &lt;&lt; \".\\n\"; return; // 끝 } current-&gt;downcnt(); // 현재 노드의 카운트 감소 if (value-&gt;getData() &gt; current-&gt;getData()) { // 원하는 값이 더 큼 cout &lt;&lt; \"current is \" &lt;&lt; current-&gt;getData() &lt;&lt; \". pointer moved to right.\\n\"; current = current-&gt;getRight(); // 오른쪽 서브트리로 이동 continue; } if (value-&gt;getData() &lt; current-&gt;getData()) { // 원하는 값이 더 작음 cout &lt;&lt; \"current is \" &lt;&lt; current-&gt;getData() &lt;&lt; \". pointer moved to left.\\n\"; current = current-&gt;getLeft(); // 왼쪽 서브트리로 이동 continue; } /* 원하는 값 찾음: 후계자가 선정되어 값이 바뀌었거나 값이 같은 노드가 중복하여 존재하는 경우, 삭제할 노드를 헷갈리지 않기 위해 객체 자체를 비교함 */ if (current == value) { cout &lt;&lt; value-&gt;getData() &lt;&lt; \" has been found.\\n\"; return; } // 원래 삭제하려던 노드의 후계자가 대신 삭제되어야 하는 경우 // data는 같지만 노드 자체는 달라서 위의 선택문을 모두 통과하는 경우가 있음 // 그럴 때는 후계자 선정 규칙에 따라 오른쪽 서브트리로 이동 cout &lt;&lt; \"current is \" &lt;&lt; current-&gt;getData() &lt;&lt; \". pointer moved to right.\\n\"; current = current-&gt;getRight(); // 오른쪽 서브트리로 이동 continue; } }public: void deleteValue(int value) { // 특정 값 삭제 node* del_node = find(value); // 삭제할 노드 찾기 node* succ; if (del_node != NULL) { // 삭제할 노드가 있다면 if (del_node-&gt;getLeft() != NULL &amp;&amp; del_node-&gt;getRight() != NULL) { // 후계 필요 succ = successor(del_node); // 후계 선정 recount(succ); // 노드 삭제를 위해 누적 노드 개수를 수정하는 메소드 del_node-&gt;setData(succ-&gt;getData()); // 삭제할 노드의 데이터를 후계의 데이터로 대체 root-&gt;setRight(delete_impl(root-&gt;getRight(), succ-&gt;getData())); // 후계 노드 삭제 } else { // 후계 필요 없음 recount(del_node); // 노드 삭제를 위해 누적 노드 개수를 수정하는 메소드 root = delete_impl(root, value); // private 삭제 메소드 호출 } } else { // 삭제할 노드가 없음 cout &lt;&lt; \"delete error: No value matches \" &lt;&lt; value &lt;&lt; \".\\n\"; return; // 돌아감 } }Rank 메소드지금까지 여러 메소드들을 개조한 이유는 Rank 메소드를 구현하기 위해서였다. 다시 한 번 설명하자면 Rank 메소드는 트리에서 이진 탐색 트리에서 특정 값보다 크거나 작은 값의 개수를 세는 메소드를 말한다. 나는 key로 주어진 값보다 큰 것의 개수와 작은 것의 개수를 세는 메소드를 구현했다. 두 메소드는 서로 방향만 다를 뿐 과정은 동일하니 큰 값의 개수를 세는 메소드를 기준으로 설명하겠다. 코드블록에도 큰 값을 세는 메소드만 보여주겠지만 삭제 메소드에서와 마찬가지로 전체 코드는 여기에서 볼 수 있다.Rank를 구하는 과정은 다음과 같다. key 값보다 큰 것의 개수를 세는 과정을 기준으로 하며, 트리에 중복된 값이 저장되어 있을 수 있음을 전제로 한다. 중복을 불허한다면 과정은 더 단순해질 수 있다.(1) 우선 key와 같은 값을 가진 노드를 찾을 때까지 탐색을 시작한다.(2) key와 다른 값을 가진 노드가 나왔다면 다음을 수행한다.    (2.1) key보다 큰 값을 찾았다면 해당 노드를 개수에 포함하기 위해 +1을 하고, 오른쪽 서브트리가 있다면 오른쪽 자손의 수도 같이 더한다. 이후 왼쪽 서브트리로 이동한다.    (2.2) key보다 작은 값을 찾았다면 오른쪽 서브트리로 이동한다.(3) key와 같은 값을 찾았다면 오른쪽 서브트리로 이동한다.(4) NULL에 도달할 때까지 (2)의 과정을 반복한다.(5) NULL에 도달했다면 지금까지 센 개수를 반환한다.작은 값을 세는 메소드는 위의 과정에서 좌우를 바꾸면 된다.참고를 위해, 중복을 불허한 트리의 Rank 구현 과정도 보자.(1) 원하는 값을 찾을 때까지 내려가면서(2) 자기 자신보다 작거나 같으면 or 크거나 같으면 +1,(3) 해당 노드의 왼쪽 or 오른쪽 자손 노드의 개수도 더한다.(4) 원하는 노드를 찾으면 해당 노드의 자신을 포함한 자손 노드의 개수를 세고 끝낸다.아래 코드는 key보다 큰 값의 개수를 세는 메소드이다. 클래스 외부에서 사용할 수 있어야 하기 때문에 public으로 정의되었다.int countGreater(int key) { // 특정 값(key)보다 큰 요소의 개수 셈 int cnt = 0; node* current = root; while (true) { // 반복 탐색 cout &lt;&lt; \"current value is \" &lt;&lt; (current != NULL ? to_string(current-&gt;getData()) : \"NULL\") &lt;&lt; \"\\n\"; if (current == NULL) // 더 탐색할 노드가 없음 break; // 반복 종료 if (key == current-&gt;getData()) { // key와 같은 값 찾음 // 오른쪽에 더 큰 값이 남아있을 수 있으므로 오른쪽으로 이동 cout &lt;&lt; \"find key value. go right.\\n\"; current = current-&gt;getRight(); continue; } else if (key &lt; current-&gt;getData()) { // key보다 큰 값 찾음 cnt += 1; // 일단 현재 노드를 카운트에 추가 if (current-&gt;getRight() != NULL) // 오른쪽 서브트리가 있다면 cnt += current-&gt;getRight()-&gt;getcnt(); // 오른쪽 서브트리의 노드 수도 추가 // 왼쪽에 더 큰 값이 남아있을 수 있으므로 왼쪽으로 이동 cout &lt;&lt; \"current value \" &lt;&lt; current-&gt;getData() &lt;&lt; \" is greater than key value. add right count and go left\\n\"; current = current-&gt;getLeft(); continue; } else if (key &gt; current-&gt;getData()) { // key보다 작은 값 찾음 // 오른쪽에 더 큰 값이 남아있을 수 있으므로 오른쪽으로 이동 cout &lt;&lt; \"current value \" &lt;&lt; current-&gt;getData() &lt;&lt; \" is lesser than key value. Don't add count and go right\\n\"; current = current-&gt;getRight(); continue; } } return cnt; // 반복 종료 후 결과 반환}참고 자료[1] Augmenting Data Structure https://www.includehelp.com/data-structure-tutorial/augmenting-data-structure.aspx" }, { "title": "[자료구조] Big-O와 이진 탐색 트리", "url": "/satinbower-legacy/posts/it-bin-search-tree/", "categories": "IT, Data Structure", "tags": "지식, IT, 자료구조, 이진 탐색 트리, 시간복잡도, Big-O, 과제", "date": "2022-09-23 22:35:00 +0900", "snippet": "과제아래 내용을 포함하는 포트폴리오를 작성하고, 웹페이지 주소를 제출합니다.1. 스케줄링 문제에 접근하는 이진 탐색 트리 소개(필수) (-&gt; 응답시간 대기시간 등등 말하는 것 같음. \"좋은 스케줄링은 프로세서의 효율성을 높이고, 프로세스의 응답시간을 최소화하여 시스템의 작업 처리 능력을 향상시킨다.\")2. Big-O 소개(선택)3. 문제 풀이3.1. LeetCode 98, 99, 700, 701(필수)3.2. 백준 5639, 1539(선택)LeetCode (ex. https://leetcode.com/problems/validate-binary-search-tree/) 문제는 기본적인 BST 구성으로 천천히 코드를 만들어 보세요.접속해 보면 BST 구성을 위한 간단한 안내도 함께 있으니, 참조 코드들을 활용하지 않고 수강생 본인이 직접 알고리즘을 만들어 보면 많은 도움이 됩니다.(선택) 항목인 3.2. 문제는 원하는 학생만 풀어서 작성하면 됩니다.여러 페이지로 나누어 작성할 시, 다른 접속자들(친구들)이 보기 편하게 다른 페이지를 링크 시켜서 작성하세요.차례 Big-O와 여러 가지 예시 이진 탐색 트리(BST), BST의 효율적인 탐색 방법 문제 풀기 → 준비 중Big-O알고리즘의 성능 분석알고리즘의 성능 분석 방법에는 두 가지가 있다. 알고리즘의 실행 시간을 계산하는 시간 복잡도와 알고리즘이 사용하는 메모리를 분석하는 공간 복잡도이다. Big-O는 둘 중 시간 복잡도를 계산하며, 입력의 크기에 따라 알고리즘이 수행되는 최악의 경우를 상정한다.이때 최악의 경우를 상정한다고 해도 식은 가능한 타이트하게 잡는다. 예를 들자면 “어디 살아요?”라는 질문에 “지구에 살아요.”라고 대답하면 그것은 너무 광범위한 대답이지만 “ㅁㅁ시에 살아요.”라고 대답하는 것이 적절한 것처럼 시간 복잡도도 너무 넉넉하게 계산하지 않는다.Big-O의 종류전제 : 입력의 크기는 n이고, 시간 복잡도에서 사용되는 log의 밑은 2이다.O(1)어떤 입력이 들어와도 무조건 같은 횟수의 연산을 한다. 수행 시간 면에서만 본다면 최상의 알고리즘.O(logn)입력의 크기 n이 작을 때는 수행 시간의 상승폭이 크지만, n이 커질수록 수행 시간의 상승폭은 줄어든다. 컴퓨터 사이언스에서 log는 기본적으로 밑을 2로 갖는다고 한다(출처 : 교수님 설명).O(n)선형 증가. 입력의 모든 요소를 한번씩 확인해야 하는 경우가 이에 해당한다. 예를 들면 정렬되지 않은 배열에서 최댓값 찾기, 배열의 모든 요소의 합 구하기 등이 있다.시간 복잡도가 이정도만 나와도 준수한 알고리즘이다(출처 : 교수님 설명, 이하 ‘교수님’으로 표기).O(nlogn)n ⅹ logn이다. 여기까지도 괜찮은 알고리즘이다(교수님).O(n2)갈수록 상승폭이 커지기 때문에 안 좋은 알고리즘(교수님).O(2n)처음부터 발산하기 때문에 쓰면 안 된다(교수님).시간 복잡도 연산O() 안에 쓰인 식의 계수와 상수항은 전혀 의미가 없고, 무조건 최고차항의 비교만 의미있다. 무한대로 늘어나는 입력에 따른 시간 복잡도 계산 결과에서 가장 큰 영향을 미치는 것은 최고차항이기 때문.예제 O(1) + O(1) == O(1) ⇒ 참 O(3n2) == O(1/2n2) ⇒ 참여러 가지 예시힙 삽입 연산의 Big-O레벨(h) 3, 노드(n) 6개 있는 힙에 새 요소 추가하기최선의 경우 : 어떠한 교환 연산도 일어나지 않음 → O(1)최악의 경우 : 새 노드가 루트까지 교환됨 → O(h)노드의 개수 n은 (2h - 1)로 나타낼 수 있다. 고로 O(logn)이다. 자세한 이항 과정은 생략한다. 이 정도는 할 수 있잖아요.피보나치 수열의 big-o 재귀로 구현한다면 O(2n)이지만 이건 loose bound이고, 잘만 하면 이것보다는 낫다는 것을 증명한 사람이 있다. 그건 알아서 찾아보라. (교수님)예제 - 오븐 오븐 1개 예약받기 예약 → 오븐에 넣는 시간 t 결정 k 시간 예약 없으면 t ∊ R 다 구우면 Extraction계산의 편의를 위해 k = 2라고 가정하자. 현재 예약된 시간은 2, 6, 8, 12, 17, 19, 23현재 예약된 시간의 집합은 R, Big-O는 O(logn)으로 하고 싶다. 어떻게 할 수 있을까? 방법 unsorted array : O(n) sorted array : O(n) search : O(logn) compare : O(1) insert : 삽입하려면 전부 자리를 하나씩 움직여야 하므로 O(n) → 이게 문제 (linked) list search : O(n) → 삽입 연산은 간단하지만 이게 문제 heap 힙은 weekly invariant하기 때문에 삽입해도 되는지 검증하려면 모든 노드를 방문해야 한다. 고로 O(n) 제안정렬된 배열의 탐색과 비교 연산, 힙의 삽입 연산을 합치면 O(logn)이 될 수 있다. → 서브트리의 좌우 크기까지 정렬하는 이진 탐색 트리를 쓴다.탐색의 방향이 정해져 있고(탐색 O(h) == O(logn)), 삽입도 간단하니 모든 과정을 합해 O(logn) 가능? 문제이진 탐색 트리의 루트 노드는 어떻게 정하나? 잘못 정하면 리스트와 다를 게 없어진다. 높이를 최소화해야 한다. 해결양쪽 서브트리의 높이 차이를 1 이하로 유지한다. 이진 탐색 트리의 문제서치는 간단하다. 그런데 만약 특정 값보다 작거나 큰 값의 개수를 세고 싶다면? 이진 탐색 트리 문제 해결각 노드에 자기 자신을 포함한 자손 노드의 개수를 같이 저장한다.원하는 값을 찾을 때까지 내려가면서(1) 자기 자신보다 작거나 같으면 or 크거나 같으면 +1,(2) 해당 노드의 왼쪽 or 오른쪽 자손 노드의 개수도 더한다.원하는 노드를 찾으면 해당 노드의 개수를 세고 끝낸다. 이진 탐색 트리예습 구경하기 : [자료구조] 이진 탐색 트리이진 탐색 트리의 기본지난 글에서 힙에 대해 공부했다. 이진 탐색 트리는 힙과 달리 서브 트리의 좌우 정렬까지 고려하는 트리이다. 왼쪽의 값이 루트보다 크고, 오른쪽의 값이 루트보다 작다. 간단히 구글에 검색해봤는데, STL 라이브러리는 없고, 직접 구현해야 한다.이진 탐색 트리 설계 및 구현코드 출처 : 교수님개인적 편집 있음노드필요한 데이터를 담을 수 있어야 하고, 자신의 왼쪽과 오른쪽 서브트리를 가리켜야 한다. 일단 데이터는 간단하게 int로 하자.연산은 생성자, 데이터 설정, 좌우 서브트리 설정, 리프노드 여부 등.트리자료형은 노드가 다 알아서 한다. 트리 클래스는 루트 관리, 삽입, 삭제, 탐색 등을 한다.전체 구현 코드 보기* 웬만한 설명은 다 주석과 출력문에 있다. 코드를 읽기만 해서는 아무리 봐도 이해가 잘 안 돼서 출력문을 잔뜩 추가하고 트리 그림까지 그려봤다. 적어도 어떻게 일이 돌아가는지는 알게 되었다. 출력문 자세히 썼으니 궁금하면 복사해서 직접 디버깅해보자.코드가 길어 링크로 첨부한다.깃허브에서 보기코드 실행 결과 보기이진 탐색 트리의 효율적인 탐색이진 탐색 트리는 그것이 필요한 상황이라는 전제 하에, 특정 값에 대한 연산에는 효율적이다. 하지만 특정 범위에 대한 연산은 어떨까? 예를 들어 위의 예제 코드로 만들어진 트리에서 10보다 큰 값을 개수를 세고 싶다면 어떻게 해야 할까? 교수님은 맛있는 휘낭시에를 걸고 이 문제를 퀴즈로 내셨지만 아무도 시간 내에 맞히지 못했다.교수님이 직접 공개한 정답은 각 노드에 자기 자신을 포함한 자식 노드의 수를 따로 기록하는 것이었다. 교수님의 코드를 개조해서 직접 구현해보고자 했지만 삭제 연산을 제대로 구현하지 못해 실패했다. 우선은 예시 코드에 재귀로 사용된 각종 탐색 메소드부터 반복으로 바꾸고 나서 생각해봐야 할 것 같다. 미래의 제게 맡기겠습니다.글을 순서대로 정독했다면 알겠지만 위에서도 잠깐 언급이 된 내용이었다. 다시 한 번 보자. 각 노드에 자기 자신을 포함한 자손 노드의 개수를 같이 저장한다. 원하는 값을 찾을 때까지 내려가면서 (1) 자기 자신보다 작거나 같으면 or 크거나 같으면 +1, (2) 해당 노드의 왼쪽 or 오른쪽 자손 노드의 개수도 더한다. 원하는 노드를 찾으면 해당 노드의 개수를 세고 끝낸다.해야 할 일은 다음과 같다 노드 클래스에 카운트 변수 추가하고, 적절한 메소드 구현하기(카운트 반환, 카운트 증감) 트리 클래스의 삽입, 삭제 연산에서 카운트도 같이 조작할 수 있도록 메소드 수정하기 특정 값보다 크거나 작은 요소의 개수 세는 메소드 구현하기 → 만드는 사람 마음이니까 ‘크거나 같은’, ‘작거나 같은’ 요소의 수를 세어도 된다. 나는 등호를 포함하지 않았다.삽입 메소드 수정은 노드가 지나는 길 따라 카운트만 건드리고 가면 되니까 금방 했고 가장 어려웠던 건 삭제 메소드 수정이었다. 삭제해야 할 노드가 양쪽 서브트리를 모두 갖는 경우, 대신 삭제될 후계 노드를 선정해야 한다. 이 부분을 포함해 삭제 메소드 전체가 재귀로 구현되었고, 나는 이것을 반복 형태로 수정하지 못했다. 그렇기 때문에 삭제 메소드 내에서는 노드의 카운트를 올바르게 수정할 수가 없었다.재귀로 구현된 삭제 메소드를 반복으로 바꾸겠다고 한참을 내 마음대로 움직여주지 않는 포인터와 기싸움을 하다가 이건 내 수준에는 이해할 수 없는 문제라고 생각해(구글에 뭐라고 검색해야 하는지도 모름) 방법을 바꿨다. private로 정의된 삭제 메소드는 그대로 두고, public로 정의된 삭제 메소드를 건드렸다. 약간의 과정이 중복하여 수행되는 점을 감수하고 private 삭제 메소드를 호출하기 전에 몇 가지 과정을 추가했다. 추가라고 말은 했지만, 순서를 바꾼 것이기도 하다. 자세한 것은 아래 코드로 확인하자.코드가 너무 길어서 링크로 첨부한다.깃허브에서 보기코드 실행 결과 보기문제 풀기1. LeetCode 98, 99, 700, 701(필수)2. 백준 5639, 1539(선택)링크 준비중참고 자료 『C++로 쉽게 풀어쓴 자료구조』, 천인국ㆍ최영규 지음, 생능 출판사 『코딩 테스트를 위한 자료 구조와 알고리즘 with C++』, 존 캐리ㆍ셰리안 도시ㆍ파야스 라잔 지음, 황선규 옮김, 길벗 출판사 [자료구조] 이진탐색트리 (Binary Search Tree)" }, { "title": "[html/css] 22.09.20 Part 1", "url": "/satinbower-legacy/posts/it-220920-read-html/", "categories": "IT, HTML", "tags": "지식, IT, HTML", "date": "2022-09-20 16:47:00 +0900", "snippet": "책 정보읽은 책 : 코딩 자율학습 HTML + CSS + 자바스크립트읽은 분량 : Part 1 - 1 Hello, HTML + CSS + 자바스크립트 ~ 3.5 텍스트 강조하기Part 1 HTML로 웹 구조 설계하기1 Hello, HTML + CSS + 자바스크립트1.1 개발 환경 설정하기책을 직접 보자. 설명 생략.1.2 첫 번째 HTML 문서 만들기프로젝트 폴더 설정 후 index.html 파일 만들기참고 : 웹 브라우저는 주소에 명시적으로 파일을 요청하지 않으면 가장 먼저 index.html 파일을 요청하기 때문에 HTML 문서는 index.html 파일을 기본으로 만든다. 예시 코드 &lt;!DOCTYPE html&gt; &lt;html lang=\"ko\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;My First Web Page!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 웹 페이지에 표시할 내용 작성 --&gt; &lt;p&gt;이것은 파이프가 아니다.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 위 코드를 책에서 시키는 대로 실행해보면 해당 코드로 생성된 웹 페이지를 볼 수 있다.2 HTML 문서 작성을 위한 기본 내용 살펴보기2.1 HTML의 기본 구성 요소 태그 웹 페이지를 구성하는 다양한 요소를 정의하며 html 문법을 이루는 가장 작은 단위. 기본 형식은 &lt;&gt; 안에 태그명을 작성하는 형태. 키보드로 쓸 때는 편의상 부등호를 쓰지만 책에서는 ‘홑화살괄호’라 칭하고 있음. 속성 태그에 의미나 기능을 보충함. 선택사항이지만 태그 없이 단독으로 사용할 수 없음. 보통 속성명은 그대로 쓰고 속성값은 큰따옴표 안에 쓴다. 속성값이 여러 개일 때는 쉼표로 구분하면 되고 속성이 여러 개일 때는 공백으로 구분한다. 예시 코드에 있었던 &lt;html lang=\"ko\"&gt; 태그는 html 문서의 시작(태그)이며, 언어가 한국어임(속성)을 의미한다. 문법 콘텐츠가 있는 문법 여는 태그와 닫는 태그로 내용물을 감싼다. 여는 태그는 홑화살괄호 안에 태그명을 그대로 쓰고, 닫는 괄호는 여는 홑화살괄호와 태그명 사이에 슬래시가 들어간다. 예) &lt;p&gt;This is not a pipe.&lt;/p&gt; ← 이 한 줄을 통틀어서 요소라고 부른다. 콘텐츠가 없는 문법 내용물이 없어서 닫는 태그가 필요 없는 태그. 빈 태그라고도 한다. 예) &lt;br&gt; → 이전 버전의 html에서는 빈 태그에도 닫는 표시가 필요했으나 html5에서는 필요 없다. 그리고 &lt;/br&gt;을 쓰면 태그가 제대로 적용되지 않더라. 주석 코딩할 때 가장 먼저 배우는 것 중 하나인 그 주석. 웹 페이지에 안 나타나긴 하지만 소스 보기로 볼 수 있으니 보안상 중요한 걸 쓰면 안 된다고 한다. 예) &lt;!-- 이것은 주석이 아니다 --&gt;2.2 HTML의 기본 구조위에 나와있는 예제 코드를 다시 보자. 편의상 줄 번호로 표기하겠다. 1번 줄 &lt;!DOCTYPE html&gt; : 문서형 정의. 항상 가장 처음에 작성해야 한다. 이 웹문서가 html5로 작성되었음을 나타낸다. 2 ~ 13번 줄 &lt;html&gt;&lt;/html&gt; : 이 문서의 시작과 끝 모든 태그는 이 안에 작성해야 한다. 3 ~ 8번 줄 &lt;head&gt;&lt;/head&gt; : 문서 정보 해당 문서의 메타데이터를 정의하는 영역. 웹 브라우저에 직접 노출되지 않는다. &lt;meta&gt; : 문서의 문자 집합(charset), 특정 브라우저의 렌더링 엔진 지정(http-equiv content), 뷰포트(나중에 배움) 등을 지정한다. title : 문서의 제목 지정. 한 문서당 하나씩만 있고, 여러 문서에서 같은 제목이 중복될 경우 검색 엔진 노출에 불이익을 받을 수 있다(해당 웹 사이트의 신뢰성이 떨어짐). 9 ~ 12번 줄 &lt;body&gt;&lt;/body&gt; : 웹 브라우저에 표시할 내용2.3 HTML의 특징 파악하기2.3.1 블록 요소와 인라인 요소 블록 요소(block element) : 웹 브라우저의 공간 유무와 관계없이 사용할 때마다 자동으로 줄바꿈되는 태그. 인라인 요소(inline element) : 공간이 부족할 때에만 다음 줄로 넘어가는 태그.2.3.2 부모, 자식, 형제 관계겉을 감싸는 태그가 부모 태그, 안에 들어간 태그가 자식 태그. 서로 같은 태그 안에 함께 있는 태그는 형제 태그. 부모, 자식, 형제의 사전적 정의와 크게 다르지 않음.2.3.3 줄 바꿈과 들여쓰기코드를 보기 좋게 줄 바꿈과 들여쓰기를 잘 하자.3 실무에서 자주 사용하는 HTML 필수 태그 다루기* 자주 쓰는 태그만 소개하는 챕터이며, html에서 사용하는 모든 태그를 보고 싶다면 W3C 공식 사이트 참고. W3C(World Wide Web Consortium)는 월드 와이드 웹을 위한 표준을 개발하고 장려하는 국제 조직이다.3.1 텍스트 작성하기3.1.1 &lt;hn&gt;&lt;/hn&gt;(1 ≤ n ≤ 6)h는 ‘heading’을 의미하고 제목이나 주제에 사용하는 태그이다. 숫자가 작을수록 글씨 크기가 크고 중요한 것으로 취급된다. 이 태그로 작성된 내용은 검색 엔진이 키워드로 인식한다. 검색 엔진 최적화(SEO, Search Engine Optimization)를 하려면 제목을 잘 지어야 한다.검색 엔진은 무조건 h1 태그부터 순차적으로 검색하므로 번호를 건너뛰지 말고 1번부터 순서대로 써야 한다.오 내 글은 전부 h2부터 시작하는데.. 글 제목이 당연히 h1으로 들어갈 테니까 괜찮지 않을까? 검색 엔진 최적화(SEO, Search Engine Optimization) : 검색 엔진에서 상위에 랭크(rank)될 수 있도록 검색 엔진에 친화적으로 마크업(markup, 문서 구조)을 작성하는 것3.1.2 &lt;p&gt;&lt;/p&gt;본문에서 문단(paragraph)을 작성할 때 사용.3.1.3 &lt;br&gt;문단 내 줄 바꿈3.1.4 &lt;blockquote&gt;&lt;/blockquote&gt;문단 단위의 인용 작성에 사용. 명확한 출처가 있다면 cite 속성에 명시해야 한다. 내부에 반드시 1개 이상의 &lt;p&gt; 태그를 포함해야 한다. 예) &lt;blockquote cite=\"출처 URL\"&gt; &lt;p&gt;문단 단위 인용문&lt;/p&gt; &lt;/blockquote&gt; 3.1.5 &lt;q&gt;&lt;/q&gt;텍스트 단위의 짧은 인용문 작성. 내부의 컨텐츠는 웹 페이지에서 큰따옴표로 묶여 표현된다. soqndp &lt;p&gt;가 없어도 된다는 점을 제외하면 &lt;blockquote&gt;와 사용법이 동일하다. 예) &lt;q cite=\"출처 URL\"&gt;짧은 인용문&lt;/q&gt; 3.1.6 &lt;ins&gt;&lt;/ins&gt;와 &lt;del&gt;&lt;/del&gt;&lt;ins&gt;는 새로 추가된 텍스트임을 나타내고 밑줄을 긋는다. &lt;del&gt;은 삭제된 텍스트임을 나타내고 취소선을 긋는다.3.1.7 &lt;sup&gt;&lt;/sup&gt;와 &lt;sub&gt;&lt;/sub&gt;&lt;sup&gt;는 위 첨자, &lt;sub&gt;는 아래 첨자.3.2 그룹 짓기* 공간 분할 태그 : 관련 있는 요소끼리 그룹지어 다른 영역과 분리하는 것이 공간 분할, 이 작업을 수행하는 것이 공간 분할 태그.3.2.1 &lt;div&gt;&lt;/div&gt;블록 요소와 인라인 요소를 그룹으로 묶음. class 선택자(나중에 배움)를 사용하면 더 좋다.3.2.2 &lt;span&gt;&lt;/span&gt;인라인 요소를 그룹으로 묶음. 한 문단 내에서 일부 텍스트만 다른 서식을 적용하고 싶을 때 사용할 수 있다(← CSS와 함께 사용한다).3.3 목록 만들기3.3.1 &lt;ul&gt;&lt;/ul&gt;(unordered list)순서가 없는 목록. 내용물은 &lt;li&gt;&lt;/li&gt;로 작성하며 각 목록마다 글머리 기호(bullet point)가 붙음.3.3.2 &lt;ol&gt;&lt;/ol&gt;(ordered list)순서가 있는 목록. 내용물은 &lt;ul&gt;과 마찬가지로 &lt;li&gt;&lt;/li&gt;로 작성하며 자동으로 번호가 붙음.3.3.3 &lt;dl&gt;&lt;/dl&gt;(description list)정의형 목록. 정의할 개념은 &lt;dt&gt;&lt;/dt&gt;(description term), 해당 개념의 정의는 &lt;dd&gt;&lt;/dd&gt;(description details)로 작성. 실행 결과는 각자 해보자.3.4 링크와 이미지 넣기3.4.1 &lt;a&gt;&lt;/a&gt;html 내/외부 링크 생성. 링크 경로를 지정하는 href 속성 필수 사용(넣을 링크가 없다면 \"#\"으로 지정), target(현재 탭 열기/새 탭 열기 지정), title(링크 설명, 마우스를 올리고 잠시 기다리면 보이는 텍스트) 속성 추가 사용 가능. 태그 사이의 내용물에는 해당 태그에 지정된 하이퍼링크가 걸릴 요소(&lt;p&gt;, &lt;img&gt; 등 사용 가능)를 작성한다. 예) 코드 &lt;a href=\"https://dapin1490.github.io/satinbower/\" target=\"_blank\" title=\"dapin1490의 블로그\"&gt;새틴바우어&lt;/a&gt; 결과 새틴바우어 3.4.2 &lt;img&gt;이미지 삽입. src 속성과 alt 속성을 가지며 컨텐츠를 포함하지 않는 빈 태그이므로 닫는 태그는 없다. src 속성은 저장소의 상대 경로 또는 링크를 이용해 이미지 경로를 지정하고 alt 속성은 해당 이미지를 설명할 수 있는 텍스트를 쓰는데, 이 설명은 마우스를 올리고 기다리면 나타나며 이미지가 어떠한 오류로 페이지에 나타나지 못했을 때에는 엑스박스 옆에 텍스트로 화면에 나타난다. 예) 코드 &lt;img src=\"/assets/img/category-it/220206-1-quick-sort.gif\" alt=\"퀵 정렬 애니메이션\"&gt; &lt;img src=\"#\" alt=\"존재하지 않는 이미지 넣기\"&gt; 결과 3.4.3 &lt;a&gt;&lt;img&gt;&lt;/a&gt;이미지 링크(이미지에 링크 걸기). 사용법은 &lt;a&gt; 안에 &lt;img&gt;를 넣는 것이다.3.5 텍스트 강조하기3.5.1 &lt;strong&gt;&lt;/strong&gt;굵은 글씨. 웹 브라우저에서 중요한 부분임을 알려줌. 중첩 가능하며 외관상의 실행 결과는 같지만 구조적으로 더 중요함을 의미함.3.5.2 &lt;em&gt;&lt;/em&gt;기울인 글씨. 텍스트의 의미를 강조할 때 사용하며 마찬가지로 중첩은 가능하나 외관상 차이는 없고 구조적으로 더 강조된다." }, { "title": "[백준][c++] 1966 프린터 큐", "url": "/satinbower-legacy/posts/it-boj-1966/", "categories": "IT, 문제풀이", "tags": "지식, IT, 문제풀이, 백준, Data Structure, Priority Queue", "date": "2022-09-17 14:40:00 +0900", "snippet": "문제 요약문제백준 1966 프린터 큐문서를 중요도에 따라 순서대로 인쇄하는 프린터 큐를 조건에 맞게 구현하라.입력첫 줄에 테스트케이스의 수두 번째 줄부터 두 줄씩 각 테스트케이스 입력각 테스트케이스의 첫 번째 줄은 문서의 개수와 인쇄 순서를 알아낼 문서의 위치 번호, 두 번째 줄은 대기중인 문서의 중요도 수열문서 위치 번호는 0번부터 시작하며 중요도는 1 이상 9 이하의 정수이고 중복 가능하다.출력줄마다 각 테스트케이스에 대해 문서가 몇 번째로 인쇄되는지 출력문제 풀기첫 번째 시도 방법 STL의 우선순위 큐를 사용했고, 큐에 각 인쇄물의 중요도와 대기열 순서를 pair&lt;int, int&gt;로 넣었다. 결과 : 예제 틀림 사유 중요도는 같고 대기열 순서가 다른 인쇄물의 인쇄 순서를 맞히지 못한다. 코드 설명 pair&lt;int, int&gt;에 입력된 정수의 순서는 &lt;중요도, 대기열 순번&gt;이다. 파일 입출력 연습을 겸하여 ifstream를 사용했으나 이를 cin으로 대체하고, 문제 풀이 함수에 전달되는 파라미터를 지우면 백준에 제출할 수 있다. 또한 빠른 예제 채점을 위해 매 테스트케이스마다 자동으로 정답을 확인하도록 했다. 코드 #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;string&gt; #include &lt;queue&gt; #include &lt;utility&gt; using namespace std; const string in_file_route = \"example_input.txt\"; // 예제 입력 텍스트 파일 const string out_file_route = \"example_output.txt\"; // 예제 정답 텍스트 파일 int when_print(ifstream* inputs); // 문제 풀이 함수. 파일 입출력을 위해 ifstream 객체 포인터 전달. int main() { // 빠른 입출력 ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); ifstream input_file{ in_file_route }; ifstream output_file{ out_file_route }; int t; // 테스트케이스 개수 input_file &gt;&gt; t; for (int i = 0; i &lt; t; i++) { int ans = when_print(&amp;input_file); // 테스트케이스 풀이 결과 반환 int correct; // 예제 정답 output_file &gt;&gt; correct; cout &lt;&lt; ans &lt;&lt; \"\\n\"; if (ans == correct) // 정답 확인 cout &lt;&lt; \"answer = \" &lt;&lt; correct &lt;&lt; \"\\ncorrect\\n\\n\"; else cout &lt;&lt; \"answer = \" &lt;&lt; correct &lt;&lt; \"\\nwrong\\n\\n\"; } // 파일 사용 후 반드시 close input_file.close(); output_file.close(); return 0; } int when_print(ifstream* inputs) { int n, m; int cnt = 0; priority_queue&lt;pair&lt;int, int&gt;&gt; pq; *inputs &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) { // 인쇄 대기열 입력 int num; *inputs &gt;&gt; num; pq.emplace(num, i); } for (int i = 1; i &lt;= n; i++) { // 인쇄 시작 pair&lt;int, int&gt; current_page = pq.top(); if (current_page.second == m) { // 원하는 인쇄물이 인쇄됨 cnt++; break; } else { // 원하는 인쇄물이 아님 pq.pop(); cnt++; } } return cnt; // 결과 반환 } 두 번째 시도 방법 덱에 pair&lt;int, int&gt;로 문제에서 주어진 인쇄 대기열을 그대로 저장하고(pair&lt;중요도, 순서&gt;), 우선순위 큐에는 인쇄물의 중요도만을 저장한다. 이후 큐의 top과 덱의 front를 비교해 중요도가 같다면 출력하며 출력 횟수를 세고, 만약 출력한 인쇄물의 인쇄 대기열 순서가 문제에서 지정한 순번의 인쇄물과 같다면 세어 두었던 출력 횟수를 반환한다. 결과 : 통과 설명 우선순위 큐만 사용하면 틀리는 이유가 있다. 우선순위 큐는 디폴트로 내림차순 정렬을 하는데, 앞서 시도한 방법처럼 pair&lt;int, int&gt;를 사용하고 first 요소가 중복되는 경우가 생긴다면 second 요소도 같이 비교하여 내림차순 정렬을 한다. 대기열 번호는 오름차순으로 부여했기 때문에 원래 대기열의 역순으로 정렬이 되어버려 인쇄 순서가 달라진다. 우선순위 큐가 대기열 번호를 정렬 기준으로 삼지 않게 처음부터 중요도만 입력하면 이런 문제가 발생하지 않고, 대신 원래의 인쇄 대기열을 따로 저장해야 한다. 또한 인쇄 우선순위가 1순위가 아닌 문서가 대기열의 맨 뒤로 갈 수 있도록 하기 위해 양방향 출입이 가능한 덱으로 인쇄 대기열을 저장했다. 첫 번째 시도와 달라진 부분이 하나 더 있는데, 인쇄물 인쇄 반복문이 for에서 while로 바뀌었다. 그 이유는 대기열 순번이 우선순위 순번과 다를 경우 인쇄를 하지 않고 넘어가야 했기 때문이다. for의 반복 횟수는 전체 인쇄물의 개수와 같고, 이는 모든 인쇄물이 한번에 인쇄되는 것을 전제로 한다. 그렇기 때문에 인쇄물이 대기열에 다시 추가될 경우 해당 문서는 인쇄될 수 없다. 그런 경우를 방지하기 위해 큐가 완전히 비워질 때까지 실행하는 조건으로 while을 사용했다. 코드 - 깃허브에서 보기 #include &lt;iostream&gt; #include &lt;queue&gt; // 큐, 우선순위 큐 #include &lt;utility&gt; // pair #include &lt;deque&gt; // 덱 using namespace std; int when_print(); // 문제 풀이 함수 int main() { // 빠른 입출력 ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int t; // 테스트케이스 개수 cin &gt;&gt; t; for (int i = 0; i &lt; t; i++) { int ans = when_print(); // 테스트케이스 연산 결과 반환 cout &lt;&lt; ans &lt;&lt; \"\\n\"; } return 0; } int when_print() { int n, m; int cnt = 0; deque&lt;pair&lt;int, int&gt;&gt; printer; // 실제 프린터 대기열 priority_queue&lt;int&gt; pq; // 우선순위 대기열 cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) { // 대기열 입력 int num; cin &gt;&gt; num; printer.emplace_back(num, i); pq.push(num); } while (!pq.empty()) { // 인쇄물이 남지 않을 때까지 인쇄 pair&lt;int, int&gt; ptr_curr_page = printer.front(); int pq_current_page = pq.top(); if (ptr_curr_page.first == pq_current_page) { // 현재 인쇄 대기 인쇄물의 중요도가 실제 대기열과 우선순위 대기열에서 동일할 때 출력 cnt++; pq.pop(); printer.pop_front(); if (ptr_curr_page.second == m) // 인쇄한 인쇄물의 순번이 문제에서 지정한 것과 같다면 정답 반환 break; } else { // 올바르지 않은 인쇄물은 대기열 맨 뒤로 보냄 printer.pop_front(); printer.push_back(ptr_curr_page); } } return cnt; } 참고 자료 C++ fstream 객체를 통한 파일 입출력 094. 파일을 한 줄씩 읽기 (ifstream, getline) std::ifstream, 파일에서 한 줄씩 읽어서 출력 [C++] emplace 함수 C++ STL 프로그래밍: 덱(deque) cplusplus.com - std::deque" }, { "title": "22.09.15 a bit cloudy", "url": "/satinbower-legacy/posts/daily-220915/", "categories": "내가 해냄", "tags": "내가 해냄", "date": "2022-09-15 23:00:00 +0900", "snippet": "대면 강의이번 학기 딱 하나 듣는 이론과목인데 내용이 꽤 흥미롭다. 재밌다. 시간표가 퇴근 시간에 끝나게 되어 있어서 저녁 먹기가 꽤 곤란하고 집에 가는 길이 고단하다는 것만 빼면 괜찮다.한자 쓰기8급 첫 번째 10글자. 복습이다.블로그 고치기, 개조하기giscus로 댓글을 만들고 싶었지만 연결을 거부했다는 오류를 끝내 해결하지 못해서 utterances로 바꿨다. 놀랍게도 하나도 오류 나지 않고 바로 됐다! 마음에 듭니다.댓글 추가하고 나서 얼마 전에 _drafts라는 폴더의 존재를 알게 되었는데, 블로그에 노출은 안 되지만 포스트는 써볼 수 있는 테스트용 폴더 정도로 이해하면 되는 것 같다. 로컬에서 따로 포스팅된 모습을 미리보기 할 수 있다고 한다. 나는 지킬이랑 루비로 이 글을 쓰고 있는 게 아니니까 테스트는 못해보지만 블로그에 노출시키지 않을 글을 써서 저장해두는 건 필요했던 참이라 레포지토리에 추가했다. 좋은 걸 알았습니다.과제 하기아니 수업은 수요일에 해놓고 과제를 일요일까지 해오라니 기한이 좀 짧지 않냐구요 양도 적은 것도 아닌데 좀 그렇지 않냐구요하지만 교수님이 진짜 학생들을 사람 만들어보겠다고 깔깔한 일만 골라서 시키는 것 같아서 좋습니다. 어디 한번 시련을 내려보시죠 견뎌낼 테니까." }, { "title": "[자료구조] 우선순위 큐와 힙", "url": "/satinbower-legacy/posts/it-priority-queue-heap/", "categories": "IT, Data Structure", "tags": "지식, IT, 자료구조, 우선순위 큐, 힙, 과제", "date": "2022-09-14 21:13:00 +0900", "snippet": "과제우선순위 큐와 힙 내용 정리, C++를 이용한 우선순위큐 프로그래밍 방법 정리백준 1966번 프린터 큐 풀이(필수)백준 1655번 가운데를 말해요 풀이(선택)우선순위 큐와 힙 내용 정리힙도 자료구조다힙 heap : 트리의 형태로 표현됨.트리 : 사이클이 없는 그래프. 참고 : [자료구조] 트리, 참고 : [자료구조] 이진 탐색 트리이진 트리 binary tree : 모든 노드가 두 개 이하의 자식을 가지는 트리.포화 이진 트리 : 단말 노드를 제외한 모든 노드가 두 개의 자식을 가지는 트리.완전 이진 트리 : 마지막 레벨을 제외한 모든 레벨에 노드가 완전히 채워져 있고, 마지막 레벨에서는 왼쪽부터 차례로 노드가 채워진 트리.거의 완전 이진 트리 nearly complete- : 마지막 레벨에서 노드가 왼쪽부터 채워지되, 한 노드가 자식 노드를 하나만 가져도 되는 트리.힙의 구성 조건 거의 완전 이진 트리일 것 부모의 키가 자식의 키보다 크거나 같아야 함(루트가 최댓값을 가짐, max heap) 부모의 키가 자식의 키보다 작거나 같은 힙은 min heap 같은 부모 아래의 자식 노드의 정렬은 고려하지 않는다.삽입 연산 수행 과정 힙을 구성하는 트리의 마지막 자리에 새 요소를 넣는다. 전체 트리가 힙 성질을 만족할 때까지 새로 넣은 요소와 부모 노드를 비교하고 바꾼다.삭제 연산 수행 과정 루트 노드를 삭제한다. 마지막 노드를 루트로 가져온다. 삽입 연산과 마찬가지로 힙 성질을 만족할 때까지 정렬한다.우선순위 큐 : 정렬된 큐우선순위 큐는 힙을 이용해 구현한다.우선순위 큐에서 사용할 기능 insert(S, x) : 새 요소 삽입 max(S) : 최댓값 보기 extract_max(S) : 최댓값 꺼내기 increase_key(S, x, k) : 설명 제대로 못 들었음. 요소 x의 키 값을 k 증가.우선순위 큐를 배열로 구현할 때 계산의 편의성을 위해 0번 인덱스는 무시한다.배열 다루기 root : 첫 요소 parent(i) = i / 2 left(i) = i * 2, right(i) = i * 2 + 1 build_max_heap : 어떤 배열 전체를 최대 힙으로 바꿔주는 것 max_heapify : 특정 인덱스에 대한 서브트리를 최대 힙 조건을 만족하도록 바꾸는 것.max_heapify 전제 : 주어진 인덱스의 자식노드를 루트로 하는 서브트리는 각각 힙 성질을 만족한다고 본다. 만약 주어진 인덱스의 요소와 그 자식 노드가 힙 성질을 만족하지 않는다면 두 자식 중 큰 쪽과 부모를 바꾼다. 만약 바꿨다면 교환한 자식 노드에 대해 다시 max_heapify를 호출한다.build_max_heap(A) 주어진 배열 A를 최대 힙으로 바꾼다 for i=n/2 downto 1 do max heapify(i) i가 n/2부터 시작하는 이유 : 인덱스가 가장 작은 리프노드가 2/n + 1부터 시작하고, 리프노드는 정렬할 필요가 없으니 리프노드 앞에서부터 시작.힙 정렬 build max heap find max A[1] swap A[1] &amp; A[n] discard node n run max_heapify goto step 2, until empty주의2번 과정에서 최댓값을 찾아낸 후, 배열에 남은 값을 한 칸씩 앞으로 당기지 않는다. 그렇게 한다고 해서 새로 만들어진 힙이 힙 성질을 만족한다고 보장할 수 없다.그렇기 때문에 배열의 마지막에 있는 값을 가져온다(step 3).C++를 이용한 우선순위큐 프로그래밍 방법 정리필요 헤더와 기본 사용 예시 디폴트는 내림차순 정렬이다.#include &lt;iostream&gt; // cpp 기본 헤더#include &lt;queue&gt; // 큐와 우선순위 큐using namespace std;int main() { priority_queue&lt;int&gt; pq; pq.push(4); pq.push(7); pq.push(3); pq.push(1); pq.push(10); while (!pq.empty()) { cout &lt;&lt; pq.top() &lt;&lt; ' '; pq.pop(); } // 출력 결과 : 10 7 4 3 1 return 0;}멤버 함수 empty : 우선순위 큐가 비었는지 확인 size : 우선순위 큐의 크기 확인 top : 현재 우선순위 큐의 가장 앞에 있는(우선순위가 최상위인) 요소 확인 push : 우선순위 큐에 값 넣기 emplace : 우선순위 큐에 구조 넣기(큐의 요소가 단순 자료형이 아닐 때 사용) pop : 현재 top의 값 제거 swap : 두 개의 우선순위 큐를 서로 바꾼다. (== 내용물을 바꾼다)◼ push와 emplacepush는 전달된 값을 복제해서 큐에 넣는다. 반면 emplace는 전달된 것을 복제하지 않고 전달된 인수로 객체를 바로 생성해 넣는다.나는 오름차순 우선순위 큐가 쓰고 싶다 우선순위 큐를 생성할 때 전달하는 인자가 달라진다.// 템플릿 타입template&lt;typename T, typename Container=std::vector&lt;T&gt;, typename Compare=std::less&lt;T&gt;&gt;class priority_queue// 실제 사용할 때는priority_queue&lt;자료형, 구현체, 비교 연산자&gt; 인스턴스명; 자료형 : 정수, 불 등의 단순 자료형을 써도 되고 벡터, 구조체 등을 사용해도 된다. 구현체 : 보통 vector를 사용하며 STL에서 힙을 구현할 수 있는 자료구조면 뭐든 괜찮다고 한다. 원소를 저장할 컨테이너를 지정한다. 비교 연산자 : 비교를 위한 기준을 지정한다. 원소의 순서를 결정하는 조건자를 정의한 함수 객체 타입이 들어간다고 한다. 디폴트는 내림차순, greater&lt;T&gt;를 쓰면 오름차순, 그 외에 직접 지정한 기준이 있다면 그 기준을 전달하면 된다.커스텀 비교 연산자 쓰기특별히 원하는 비교 기준이 있다면 해당 기준에 따라 값을 비교하는 함수 객체를 만들어서 우선순위 큐의 생성자에 전달해야 한다. 그런데 나는 함수 객체가 뭔지도 몰랐으니 그것부터 잠깐 알아보고 가자. 함수 객체 : 함수처럼 동작하는 객체. 연산자를 오버로딩하는 데에 사용했다. 참고여기서 오버로딩할 연산자는 ()이다. 함수 호출 연산자라고 한다. 이 연산자를 오버로딩하는 함수를 정의한 클래스 혹은 구조체의 객체가 함수 객체가 된다고 한다. 또한 이 함수 객체를 사용할 때는 보통의 다른 함수를 호출하는 것처럼 function_name(parameter1, parameter2) 이름, 괄호, 그 안에 파라미터 전달 형식으로 쓰는데, 이것은 .operator()가 생략된 것이라고 한다. 그러니 .operator()를 생략하지 않는다면 function_name.operator()(parameter1, parameter2) 이렇게 쓴다.함수 객체를 만들 때는 구조체로 정의해도 되고, 클래스 내부에 정의해도 되지만 여기서는 구조체로 정의한다. 내 생각엔 클래스로 쓸 필요가 없어서 구조체를 쓰는 것 같다. 구현 예시는 다음과 같다.struct cmp { bool operator()(int a, int b) { return a &gt; b; }};예시 코드에서는 단순히 정수의 크기를 비교했지만 다른 구조체끼리 특정 속성을 비교하게 만들어도 되고, 그러려고 쓰는 것이다. 전달할 때는 구조체 이름만 호출하면 된다.// 사용 예priority_queue &lt;int, vector&lt;int&gt;, cmp&gt; pq;나는 큐에 넣을 내용물이 이미 준비되어 있다우선순위 큐 인스턴스를 생성할 때, 큐에 들어갈 요소들이 먼저 준비되어 있다면 그것을 생성자에 전달해서 초기화할 수 있다. 당연히 생성될 큐의 요소와 준비된 배열의 타입이 일치해야 한다. 예시 코드를 보자(출처).using namespace std;// 배열 초기화string wrds[] {\"one\", \"two\", \"three\", \"four\"};priority_queue&lt;string&gt; words {begin(wrds), end(wrds)}; // \"two\" \"three\" \"one \"four\"// 큐 복제priority_queue&lt;string&gt; copy_words {words}; // words의 복제본예시의 배열은 영단어 4개로 이루어졌고, 생성된 큐는 문자열 내림차순 우선순위 큐이다. 배열은 중괄호 생성자를 이용해 초기화되었고 우선순위 큐는 이 배열의 시작과 끝을 받아 배열의 내용으로 구성되었다. 중괄호를 저렇게 쓰는 게 어떤 의미인지 몰라서 잠시 찾아봤는데 쉽게 이해가 가지 않아서 참고 자료[9][10]로만 올려두고, 나는 저것이 생성자라고만 말해두겠다. 내가 이해를 못했는데 설명하면 안 되지.요점은 꼭 빈 큐를 생성해야만 하는 건 아니라는 말이다. 큐 생성 시에 전달되는 배열은 정렬되어 있을 필요가 없고, 우선순위 큐 객체를 복제하는 것도 가능하다. 벡터를 많이들 쓰긴 하지만 front(), push_back(), pop_back(), size(empty() 함수를 지원하는 컨테이너라면 사용 가능하여 덱을 써도 된다고 한다.에제 문제 풀이내가 과제로 받은 우선순위 큐를 위한 예제 문제는 백준 1966번 프린터 큐(필수), 백준 1655번 가운데를 말해요(선택) 두 가지인데, 이것까지 한 포스트에 다 풀이하면 글이 너무 길어지니 보기 지루하지 않겠는가? 링크로 첨부한다.[백준] 1966 프린터 큐참고 자료 [C++ STL] Priority_queue 사용법 C++ STL priority_queue 우선순위 큐 사용법 priority_queue emplace() in C++ STL priority_queue 사용법 C++14 STL 철저 입문 - 3.4 | priority_queue&lt;T&gt; 컨테이너 어댑터 사용하기 C++/STL 강좌 2편. 함수 객체(Function Object) 72) 함수 객체 - 코딩의 시작, TCP School [자료구조] 힙(heap)이란 객체 생성시 괄호와 중괄호의 구분 [Modern C++]Initializer_list [HTML] HTML 특수문자 코드표 정리" }, { "title": "22.09.14 cloudy, little rain", "url": "/satinbower-legacy/posts/daily-220914/", "categories": "내가 해냄", "tags": "내가 해냄", "date": "2022-09-14 20:58:00 +0900", "snippet": "아침에 일찍 일어나서 학교도 가고 밥도 먹기평소엔 8시나 9시쯤에 일어나는데 오늘은 아침 수업이 있어서 6시에 일어났다구요. 지하철 시위 있대서 일부러 일찍 나간건데 오늘은 경로를 바꿔서 시위의 영향권에서 벗어났고, 남은 시간만큼 먹을거 준비해서 아침도 먹고 점심도 때웠다. 아침은 편의점 김밥, 점심은 서브웨이 샌드위치.한자 쓰기8급 2번째 10글자. 생각해보니 복습을 안 했네. 내일은 다시 첫 번째 10글자 복습할게.블로그 새로 만들어보려다 실패하기내가 이 블로그에 댓글 기능을 추가해보고 싶은데, giscus를 아무리 찾아보고 고쳐봐도 연결이 안 된다더라고. 그래서 아예 새 블로그를 만들고 처음부터 다시 설정하면 다를까 싶어서 새로 레포지토리 만들어서 한참을 커밋만 넣었는데 이번에는 아예 페이지 자체가 안 나와. 지금 블로그를 과제에 쓰고 있어서 당장 이걸 없애버릴 수는 없으니 이건 그대로 두고 그건 그것대로 오류를 천천히 고쳐보기로 했다. 근데 오늘은 더 이상 기운이 없다.. 그냥 쓰던 블로그에 일기나 쓰자구요..과제하기과제 내용 중 일부가 오늘 수업 들으면서 바쁘게 필기한 걸로 때울 수가 있어서 바로 올렸다. 그러게 사람이 필기를 잘 하고 살아야 해요. 나 이제 키보드 안 보고 칠 수 있어. 아직도 ㅋㅌㅊㅍ는 구분하기가 좀 애매하긴 한데 손가락이 움직이는 거리감을 외워서 어디에 어느 글자가 있는지 몰라도 글은 쓸 수 있어. 대신 오타는 꽤 많이 나지. 오타 안 나게 쓰려면 키보드 보면서 쳐야 함." }, { "title": "22.09.13 cloudy, a bit of rain", "url": "/satinbower-legacy/posts/daily-220913/", "categories": "내가 해냄", "tags": "내가 해냄", "date": "2022-09-13 23:30:00 +0900", "snippet": "지하철 시위 있대서 일찍 나왔는데 강의실 잠겨있어서 시간 때우고 1시간 강의 듣고 하루일과 끝나기소감 : 허망물쓰레기 사진 찍기프로젝트 준비로 사진 찍으러 갔다왔다. 그냥 갔을 때는 신경을 안 썼는데 생각보다 여기저기 잘 박혀있더라. 반성하시라고요 인류.하다 만 과제 완성하기그래요 내가 문제 잘못 이해해서 헛짓한 그 과제예요 어쩐지 이 교수님이 아무리 그래도 68페이지를 가볍다고 말할리가 없는데 이상하다 했다니까.. 그래도 이제 거의 다 했어. 가장 중요한 것만 쓰면 돼." }, { "title": "22.09.12 I didn't go out", "url": "/satinbower-legacy/posts/daily-220912/", "categories": "내가 해냄", "tags": "내가 해냄", "date": "2022-09-12 19:29:00 +0900", "snippet": "녹화 강의 보기출석만 먼저 채워뒀던 강의의 내용을 봤다. 내일 실시간 수업이 있거든요. 이른바 벼락치기라는 것입니다. 교수님이 2년 전(추정) 영상을 올려놔서 실시간 수업에서는 내용이 좀 바뀔 것 같다. 이게 원래 그런 과목이에요. 자주 내용이 바뀌는 과목인데 교수님이 그걸 알면서도 2년이나 된(추정) 영상을 올렸네.블로그 고치기구글에다가 내 블로그 사이트맵을 낸 지가 언젠데 아직도 내 사이트는 검색이 불가하다길래 이것저것 확인해봤는데, 사이트맵이 뭔가 문제가 있었던 것 같아서 새로 올렸다. 아마도 자바스크립트로 짐작되는 코드로 쓰인 자동 사이트맵이랑 내가 직접 수정해야 하는 수동 사이트맵 두 개 올렸는데, 자동 사이트맵은 이전과 똑같이 올려지기만 하고 정작 생성되어야 할 인덱스는 아무것도 만들어지지 않는 상태 그대로였고, 수동 사이트맵은 올리자마자 색인 생성이 가능하다고 떴다. 진짜로 뭐가 문제인지는 내가 자바스크립트를 공부해야 알 수 있겠죠. 한참 멀었습니다.과제 하기며칠 동안 계속 하던 영어 번역을 끝낼 때가 되었다. 과제 문제를 다시 확인해보니 내가 처음부터 문제를 잘못 이해해서 안 해도 되는 노가다를 하고 있었더라고.. 양이 확 줄긴 했지만 허탈한 마음은 감출 수가 없습니다. 그래 나 허망해요 내가 헛짓을 했어.한자 쓰기한국어문회 8급 가나다순으로 10글자." }, { "title": "22.09.11 cloudy ← I love it", "url": "/satinbower-legacy/posts/daily-220911/", "categories": "내가 해냄", "tags": "내가 해냄", "date": "2022-09-11 19:52:00 +0900", "snippet": "생물다양성 강의 듣기학교 비교과 프로그램으로 듣게 된 강의인데 이 프로그램을 이수한걸로 인정받으려면 기한 내에 강의를 들어야 해서 벼락치기한 거다. 그래도 나름 즐겼답니다.하나는 지구과학 강의. 광물과 암석에 대해 배웠다. 내가 지구과학에는 큰 흥미가 없어서 리뷰는 이걸로 끝.다른 하나는 식물 관련 강의. 재밌었다. 교수님도 내가 좋아하는 교수님이고 내용도 아주 좋았다. 쇠뜨기의 이름의 유래(소가 뜯어먹는 풀이라서 쇠뜨기)라든가, 함박꽃나무(이름에 아주 어울리는 꽃을 갖고 있었다)라든가, 백목련과 목련의 차이(꽃잎의 개수, 꽃받침 유무, 원산지 등), 금방동사니는 사초과라는 사실, 내가 길거리에서 뜯어다 우산 만들던 풀은 바랭이라는 이름을 갖고 있었다든가, 식물의 이름을 알고 싶을 때 시도할 수 있는 방법 등 많은 걸 배웠다만 사실 온전히 기억하지는 못한다. 강의 영상을 영구 소장하고 싶다.한자 교본 새로 준비하기일본식 한자와 한국식 한자 중에서 고민하다가(사실 고민 시작한 순간부터 답은 정해져 있었음) 한국식 한자를 공부하기로 하고, 한국어문회의 한자 급수 기준으로 8급부터 시작하기로 했다. 8급은 50글자이고 하루에 10글자씩 보는 게 지금의 계획이다. 근데 문제는 여기서 배정 한자라고 올려준 자료에는 한자만 써있고 훈음이 없어서 그것부터 내가 채워야 한다. 물론 구글링 좀만 하면 훈음 보기 좋게 쓰인 자료 많겠지만, 내가 마음에 안 든다. 직접 사전 찾아서 써놓고 시작할 거다. 내 취미니까 내 맘대로 할 거다.번역하기아 이 과제 언제 끝나요 마감이 벌써 코앞인데 반도 못했어 교수님 가볍다면서요 금방 한다면서요" }, { "title": "22.09.10 sunny", "url": "/satinbower-legacy/posts/daily-220910/", "categories": "내가 해냄", "tags": "내가 해냄", "date": "2022-09-10 17:12:00 +0900", "snippet": "차례 지내기별로 즐겁지는 않았고.. 졸림.프로젝트 준비물 만들기물에 버려진 쓰레기 사진 100장 준비하기, 중에 18장 준비했다. 이번 학기에 듣는 전공 과목 중 하나가 포트폴리오를 겸해서 좀 까다로운 프로젝트를 시켜서 계속 생각 중이다. 내가 뭘 할 수 있을까?일단 나는 간단한 딥러닝, 약간의 사이킷런, 초보적인 크롤링을 할 줄 알아. 그리고 이 프로젝트는 ‘자료구조’를 활용해야 해. 다른 수강생 사진까지 합쳐서 약 4만 장의 쓰레기 사진과 자료구조로 학부생이 뭘 할 수 있을까?한자 쓰기오늘은 진도를 나가기로 했다. 초등 2학년 4페이지 쓰자.원래 쓰던 교본은 일본 초등학생용 교본이었는데, 이게 보다보니까 한국식 한자 생김새랑 일본식 한자 생김새가 꽤 다른 경우가 있는 것 같더라고. 나야 취미로 공부하는 거니까 어느 쪽이든 한자만 익히면 됐다만, 생각해보면 일본식 한자를 읽을 수 있게 되어봐야 히라가나, 가타카나를 못읽으면 쓸모가 없고, 한국식 한자랑 다르니까 한국에서도 쓸모가 부족해. 그렇다고 한국식 한자를 익히면 더 쓸모가 있나? 사실 그것도 아니야. 내 목적은 쓰기가 아니라 읽기거든. 한국어는 한자어가 많대도 대부분 한글로 표기하니까 단어 뜻을 안다면 한자를 몰라도 소통에 지장이 없어. 그러니까 없어도 되지만 있으면 그냥 있어보일 뿐인 소양을 키운다 이 말이죠. 그래서 한자를 쓰는 대신에 어느 쪽 한자를 공부할지 확실하게 정하는 시간을 갖기로 했다. 물론 약간 탈이 나서 공부할 상태가 아니기도 했어." }, { "title": "22.09.09 sunny", "url": "/satinbower-legacy/posts/daily-220909/", "categories": "내가 해냄", "tags": "내가 해냄", "date": "2022-09-09 13:11:00 +0900", "snippet": "어제 한 일 녹화 강의 출석 채우기 영어 번역 : https://dapin1490.github.io/satinbower/posts/knowledge-SDG-2021/ 대면 강의 알차게 듣고 오기 : 재밌었다 귀가 시간이 늦어 블로그 업로드 없음영어 번역이거 68페이진데 기한 내에 끝나기는 하겠냐. 파파고가 해석 다 해줘도 정리가 오래 걸리는데.https://dapin1490.github.io/satinbower/posts/knowledge-SDG-2021/한자 노트 사오기(+ 푸룬주스)이마트 가서 한자 노트 사왔다. 하나에 900원. 덤으로 푸룬주스도 사봤는데 싼 거라 그랬는지 한약 맛 나더라.. 친모가 예전에 푸룬주스 비싸고 좋은 거 먹어봤는데 그건 맛있었다고 했거든. 다음에 또 사게 되면 그 때는 더 비싼 거 사보기로 했다. 근데 굳이 살 일은 없을 것 같다. 난 그거 안 마셔도 화장실 문제 없거든요!" }, { "title": "22.09.07 too sunny", "url": "/satinbower-legacy/posts/daily-220907/", "categories": "내가 해냄", "tags": "내가 해냄", "date": "2022-09-07 19:03:00 +0900", "snippet": "대면 강의이번 학기 실습 과목들은 대부분 그냥 학교 컴퓨터를 쓰기로 마음먹었다. 노트북을 들고 다니기엔 너무 무겁거든요. 그래서 깃허브 레포지토리를 잔뜩 만들었다. 노션이든 뭐든 깃허브가 제일 파일 다루기가 편하고 로그인도 빠르고 편해서 이론 과목도 깃허브에 정리하기로 했다.한자 쓰기초등 2학년 3페이지 썼다. 획 순서는 금방 외울 수 있어서 빠르게 끝났다.과제 시작하기교수님이 어떤 글을 읽어보고 그 내용을 정리하라는 과제를 냈는데 글이 영어로 써있는 68페이지 가량의 pdf였다. 해석부터 해야 한다..번역문 링크 : https://dapin1490.github.io/satinbower/posts/knowledge-SDG-2021/" }, { "title": "The Sustainable Development Goals Report 2021 주제 골라서 의견 쓰기", "url": "/satinbower-legacy/posts/knowledge-SDG-2021/", "categories": "사회문화", "tags": "지식, 사회문화, UN, SDG, 과제", "date": "2022-09-06 18:41:00 +0900", "snippet": "과제 내용본인 포트폴리오가 될 틀(웹페이지, .git, YouTube, 블로그 등)을 만듭니다.강의자료 Reading Material 1의 여러 주제 중 본인이 원하는 주제 하나를 선택합니다.본인의 포트폴리오 방향성과 형식에 맞게 자료 내용을 요약하고, 본인 생각을 함께 업로드합니다.웹페이지 주소를 별도의 첨부파일 없이 글 작성칸에 웹페이지 시작 단어(http://)를 포함한 전체 주소를 남깁니다.평가는 차주 수업 중 친구들이 합니다.평가자를 생각해 자료를 작성하세요.차주 숙제부터는 프로그래밍 숙제입니다.읽기 자료 숙제는 1회, 또는 2회 예정되어 있습니다.The Sustainable Development Goals Report 2021 원문은 영어로 기술되어 있으며 모든 번역은 파파고를 이용했음. 그 파파고로 번역한 것을 내가 다시 요약함. 요약을 하긴 했지만 짧지는 않음.원문 목차 Foreword View from the pandemic Investing in data Overview Goal 1 No poverty Goal 2 Zero hunger Goal 3 Good health and well-being Goal 4 Quality education Goal 5 Gender equality Goal 6 Clean water and sanitation Goal 7 Affordable and clean energy Goal 8 Decent work and economic growth Goal 9 Industry, innovation and infrastructure Goal 10 Reduced inequalities Goal 11 Sustainable cities and communities Goal 12 Responsable Goal 13 Climate action Goal 14 Life below water Goal 15 Life on land Goal 16 Peace, justice and strong institutions Goal 17 Partnership for the Goals Note to the reader Regional groupings내가 고른 주제Goal 14 Life below water | 목표 14 물 밑에서의 삶고른 이유이번 프로젝트 주제에 참고가 될까 해서, 였는데 강이 아니라 바다에 대해서만 서술하고 있어서 이게 도움이 될까 싶다.Goal 14 Life below water | 목표 14 물 밑에서의 삶▣ 해양(oceans), 해양(sea) 및 해양(marine) 자원을 보존하고 지속 가능한 개발을 위해 사용한다.바다 30억 명 이상의 사람들의 생계 수단 전세계 무역품 80%의 무역로 빈곤 퇴치, 지속적인 경제 성장, 식량 안보에 기여문제 CO2 배출량 증가 → 해양 온난화, 산성화, 탈산소화 촉진 → 해양 생태계 위협, 자정능력 초과 남획 → 물고기 고갈 오염물질(플라스틱, 하수, 육상 오염물질 등) 유출 → 해안 서식지와 지역사회 악영향해결하려면 해양 환경 보호, 해양 과학에 대한 투자, 소규모 어업 공동체에 대한 지원과 해양의 지속 가능한 관리의 긴급한 확장▣ 우리 바다의 지속가능성은 주요 생물 다양성 지역을 보호하기 위한 새로운 노력을 요구한다.해양 보호 구역 범위 크게 증가 : 2020년 그 영역이 전 세계 해안 수역과 해양의 7.74%에 도달 주요 생물 다양성 구역(KBA)의 평균 비율은 28%에서 44%로 증가 증가세 감소, 실질적으로 보호받지 못하는 구역 많음 주요 생물 다양성 구역(KBA) 해양의 지속 가능성에 매우 중요한 구역 사례: 남대서양 → 바다새와 바다표범의 위성 추적으로 주요 생태 정확히 파악 이후 어업 폐업, 영구 금어구 확대 등 규제/관리 개정에 활용 ▣ 세계 해안 수역의 데드존의 수가 놀라운 속도로 증가하고 있다.해안 지역 세계 인구의 약 40% 거주 인간 활동으로 인해 부영양화 발생 주요 원인 : 비료 유출, 가축 폐기물, 하수 배출, 양식 및 대기 질소 배출 해안 부영양화 환경 및 해안 개체군에 유해 해조류, 저산소증, 어류 살처분, 해초 폐사, 산호초 및 해안의 단단한 바닥 서식지 상실, 수영객과 어부들의 건강 위험과 관련 데드존(해양 생물을 지탱하기에 충분한 산소가 부족한 수역) 10년 사이 약 2배로 증가부영양화의 관찰 조류의 성장과 엽록소-a를 분석하여 간접적으로 관찰 가능 세계 각국의 배타적 경제 구역은 기준치 이상의 엽록소 관찰됨전망 2018년부터 2020년까지 엽록소-a 이상 발생 빈도 20% 감소 일부 지역에서 해안 지역 영양소 유입 감소 노력의 성과 관찰됨 녹조는 남아있음▣ 해양 자원을 보존하고 책임감 있게 사용하기 위한 국제 기구의 구현이 불균일하게 유지되고 있어, 지원 증대의 필요성을 강조하고 있다.목표 14를 달성하려면 여러 부문과 통합된 방식으로 해양의 보존과 지속 가능한 사용을 위해 법적 및 제도적 틀을 통한 국제 기구의 구현이 필요하다. 진전이 있었지만, 구현은 도구마다 다르므로, 새로운 노력과 지원 증대의 필요성을 강조한다.1982년 유엔해양법협약(UNCLOS)과 그 이행협약 168개 당사국(유럽연합 포함)이 UNCLOS를 비준하거나 가입 회원국들은 이행 협정을 비준하거나 승인, 많은 당사국이 이를 이행하기 위한 조치를 취함 다만 이행의 정도는 각자 다름 UNCLOS와 그 이행 협정을 효과적으로 이행하기 위해서는 국가의 기존 병목 현상 이해 필요 ← 무슨 말인지 잘 모르겠으나 국가별 발전 정도가 치우친 것에 대해 말하는 것 같음. 부유한 선진국은 계속 발전해나가고 그렇지 못한 개발도상국이 계속 뒤처지는 상황. 개발 도상국을 위한 표적화되고 지속적인 역량 개발 이니셔티브는 그러한 장애물(국가의 병목 현상)을 제거하는 데 핵심 불법, 미신고 및 비규제 어업을 예방, 방지 및 제거하기 위한 항구 국가 조치에 관한 협정 배경 : 수산자원 밀렵 → 지역 수산물 붕괴, 관리 노력 저해 IUUU 어업을 구체적으로 목표로 하는 최초의 구속력 있는 국제 협약 2016년 발효, 현재 66개 당사국(유럽연합 포함) 포함 IUU 어업에 종사하는 선박이 항구를 이용하거나 어획물을 상륙시키는 것을 방지, 저지, 철폐하는 것이 목적 2018~2020년 국제기구 평균 이행 정도 개선, 글로벌 종합대책 상승 잘 하고 있지만 더 노력 필요식량안보와 빈곤퇴치 차원에서 지속가능한 소규모 어업확보를 위한 자발적 지침 자발적 지침(The Voluntary Guidelines)은 가치사슬, 수확 후 운영 및 무역을 포함한 소규모 어업에 대한 거버넌스 개선을 촉진하는 국제적으로 합의된 도구 개발도상국에서 전 세계 어획량의 약 절반에 기여, 전 세계 어부및 어업 종사자의 90% 이상을 고용하고 있고, 이중 약 절반이 여성 이러한 소규모 어업 공동체는 소외되고 불이익을 받는 경향이 있음 코로나로 인해 악화되고 있음 2015년부터 대부분의 지역에서 소규모 어업을 지원하고 참여적 의사결정을 촉진하는 규제 프레임워크의 채택 확대▣ 세계 해양의 막대한 경제적 기여에 비해 해양 연구에 대한 자금 지원은 희박하다.해양 연구 고급 기술, 장비, 특수 센서 등이 필요해 비용이 많이 들고 물류적으로 어려울 수 있음 그러나 다른 연구 분야에 비해 투자 적음 2013~2017년에 평균적으로 국가 연구 예산의 1.2%만이 해양 과학에 할당, 세계 경제에 대한 해양의 기여도에 비하면 미미함 미국이 가장 높은 예산을 발표했고, 2017년에 일본과 호주가 뒤를 이음 코로나가 해양 과학에 미치는 영향은 아직 알려지지 않음내 의견나는 이 챕터 제목이 물 밑에서의 삶이라길래 육수와 해수를 다 포함하는 주제인 줄 알았는데 아니더라. 바다면 바다라고 좀 써 주지.. 원래 내 목적은 강이긴 했는데 크게 생각해보면 강이나 바다나 문제는 비슷할 것 같아. 배운다 생각하고 봅시다.내가 요약한 글에서 주로 나오는 얘기들을 좀 더 대략적으로 요약해보면 바다는 인간의 생계와 생활, 생태계에 아주 중요하지만 인간 활동으로 인해 많은 문제가 발생하고 있고, 이를 해결하기 위해 전 세계가 협력하고 해양 연구에 적극적으로 투자해야 한다 라고 하면 되겠어. 그럼 이제 이 요약을 나눠보자. (1) 바다는 인간의 생계와 생활, 생태계에 아주 중요, (2) 인간 활동으로 인해 많은 문제가 발생하고 있다, (3) 해결하기 위해 전 세계가 협력해야 한다, (4) 해양 연구에 적극적으로 투자해야 한다 넷 정도로 나누면 되겠다.(1) 바다는 인간의 생계와 생활, 생태계에 아주 중요이 보고서에서는 바다의 중요성에 대해 생계 수단, 무역로, 빈곤 퇴치, 지속적인 경제 성장, 식량 안보, 해양 생물의 생태 파악 등을 얘기하고 있었어. 나는 다른 얘기는 다 대충 무슨 말인지 짐작이 되는데 빈곤 퇴치, 지속적인 경제 성장, 식량 안보에 대해서는 잘 모르겠더라.바다가 생계 수단이 되니까 그걸로 빈곤을 해결할 수 있다는 말일까? 빈곤이 해결되면 경제는 성장할 테고. 식량 안보는 해산물을 말하는 거겠지? 이거 쓰면서 다시 생각해보면 아주 모를 말은 아닐수도 있겠다만 확 느낌이 오지는 않네. 그래도 바다가 중요하다고 말하는 건 알겠어.(2) 인간 활동으로 인해 많은 문제가 발생하고 있다이건 어렵지 않지. 인간 활동으로 문제가 생기는 건 바다뿐만이 아니니까 아무리 내가 이런 걸 모르고 산대도 전혀 모를 수는 없어. 오늘(22.09.13)도 프로젝트 준비하려고 물에 있는 쓰레기 찍으러 갔는데 나는 거기에 쓰레기가 있을 거라고 예상하고 가긴 했지만 그렇게 많을 줄은 몰랐다니까.이 보고서에서는 CO2 배출량 증가, 남획, 오염물질, 부영양화에 대해 언급했어.CO2는 지구과학 시간에 배워서 알아. 물에 녹으면 탄산이 돼서 물의 산성도를 바꾸고, 그로 인해 해양 생태계가 망가지지? 그리고 바다가 흡수하지 못한 CO2는 대기 중에서 온난화를 일으켜서 바다의 온도를 높여. 온실가스거든. 게다가 바다가 흡수하지 못한 CO2가 있다는 것부터가 자정능력을 초과했다는 뜻일 거야.남획은 가끔 뉴스에도 나오니까 낯설지 않은 문제야. 멸종도 멸종이고, 바다 생태계의 한 요소로 어울려야 할 물고기들을 인간이 빼다 먹는 거니까 그 물고기를 먹이로 하거나, 그 물고기의 먹이가 되는 생물들에게 영향이 있지. 해당 물고기가 대체 불가능한 종이라면 더 심할 거야.오염물질도 많이 들어 본 얘기지. 이 보고서에서 언급한 건 아니지만 원전 냉각수도 오염물질 아니야? 플라스틱은 예전부터 많이 문제제기가 되어왔고, 하수도 비슷해.부영양화는 모르고 들으면 그게 왜 문제야? 싶을 수도 있어. 영양이 너무 많아서 문제라는 거야. 영양이 너무 많으면 많이 먹으면 되는 거 아니냐, 생각할 수 있다는 거지. 근데 문제는 그렇게 많아진 영양을 소비하는 생물들에 있어. 이 영양이라는 게 포식자가 먹을 물고기가 아니라 플랑크톤이나 조류들이 먹을 밥이거든. 플랑크톤과 조류는 밥이 많으면 당연히 번성하지. 그리고 이들이 번성하면 바닷물이 녹색이나 빨간색이 돼. 그리고 그것들이 수면 아래로 비쳐야 하는 햇빛을 가려. 녹조와 적조의 문제는 거기서 오는 거야. 바닷물 아래에도 햇빛이 들어야 하는데, 육지에 화산이 터져서 화산재가 뜨는 것처럼 바다 밑에도 햇빛이 들지 않는다는 거지. 그러니 광합성이 안 되고, 산소가 줄어들고, 호흡을 못해서 다들 죽는 거야.(3) 해결하기 위해 전 세계가 협력해야 한다전 세계가 협력하는 가장 잘 알려진 방법은 단체를 만들거나, 조약/협약/협정 등을 맺는 거지. 이 보고서도 그 방법을 말하고 있어. 근데 나는 나라 정도로 큰 주체는 되지 못해서 잘 모르겠더라. 공감이나 이입이 안되니까 와닿지 않아. 나는 정치인도 아니고 영향력 있는 사람도 아니라서 저런 걸 봐봐야 내가 할 수 있는 게 뭐가 있겠나 싶거든. 내가 시민으로서 할 수 있는 건 투표가 있긴 하지만 그것도 마냥 내 마음대로 되는 방법은 아니잖아. 하지만 알아야 생각할 수 있다는 점에서 이런 주제도 필요하다고는 생각해. 좋은 배움이야.(4) 해양 연구에 적극적으로 투자해야 한다적을 알아야 이길 수 있다는 말처럼(원래는 저런 말이 아님, 원문은 지피지기 백전불태) 바다에 대해서도 잘 알아야 보호하고 관리할 수 있다는 거겠지? 식물도 그렇잖아. 언제 물을 주는 게 좋고, 온도는 어느 정도가 좋고, 이 정도 식물에게 화분 크기는 어느 정도가 좋은지까지 그 식물에 대해 잘 알아야 잘 키우잖아. 바다는 작은 화분에 있는 식물과는 스케일이 다르니까 국가 차원에서 투자하고 연구해야 하는 거지. 다만 이 내용도 나는 잘 모르겠어. 이 내용을 보고 내가 할 수 있는 게 있을까?총평가볍게만 보면 그리 어려운 내용은 아닌데, 이 글이 왜 쓰였는지, 무엇을/누구를 위해 쓰였는지, 무얼 전달하고 싶은 건지 생각해보는 건 나에게 꽤 어려운 일인 것 같다. 주로 국가 간의 협력과 국가 단위의 행동에 대해 언급하는 걸 보면 나 같은 시민이 읽으라고 썼다기보다는 국가의 요직을 맡은 사람들이 보라고 쓴 것 같지? 하지만 잘 봤습니다. 이런 것도 경험이야. 내가 할 수 있는 일이 없대도 이 글을 본 적이 없는 사람과는 달라질 수 있지." }, { "title": "[자료구조] 이진 탐색 트리", "url": "/satinbower-legacy/posts/it-data-structure-binary-search-tree/", "categories": "IT, Data Structure", "tags": "지식, IT, 자료구조, 트리, 이진 탐색 트리", "date": "2022-09-06 18:41:00 +0900", "snippet": "참고자료&lt;C++로 쉽게 풀어쓴 자료구조&gt; 천인국, 최영규 지음, 생능 출판사공부 범위 : 챕터 9 이진 탐색 트리이진 탐색 트리탐색이란?\t탐색 : 레코드(record)의 집합에서 특정한 레코드를 찾아내는 작업\t레코드(record) : 하나 이상의 필드(field)로 구성된다\t테이블(table) : 레코드의 집합\t키(key) : 레코드를 식별할 수 있게 하는 필드\t주요키(primary key) : 서로 중복되지 않는 고유한 값을 갖는 키이진 탐색 트리란?이진트리 기반, 효율적인 탐색을 위한 자료구조. 다음 조건을 만족해야 한다. 이 정의에 따라 이진 탐색 트리는 어느 정도 정렬된 상태를 유지하게 된다.\t모든 노드는 유일한 키를 갖는다.\t왼쪽 서브트리의 키들은 루트의 키보다 작다.\t오른쪽 서브트리의 키들은 루트의 키보다 크다.\t왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다.이진 탐색 트리의 추상 자료형이진 탐색 트리의 특성을 항상 만족하도록 하면서 삽입, 삭제, 탐색을 할 수 있어야 한다. 자세한 추상 자료형은 책으로 보자. 이진트리의 기본적인 모든 연산 또한 사용 가능하다.이진 탐색 트리의 기본 틀 설계이 책에서는 앞 챕터에서 만든 이진트리 클래스를 상속하고 삽입, 삭제, 탐색 함수를 추가했다.이진 탐색 트리의 연산탐색 연산비교한 값이 루트보다 작으면 왼쪽으로, 크면 오른쪽으로, 같으면 탐색이 끝난다. 재귀를 기반으로 하나 반복으로 구현할 수 있다고 한다. 반복으로 구현한 함수에서는 while을 사용했다. 함수는 이진 탐색 트리에서 구현하는 방법도 있고, 노드 클래스에서 구현하는 방법도 있다. 자세한 코드는 생략한다.삽입 연산삽입하기에 앞서 적절한 자리를 찾기 위해 탐색을 해야 한다. 탐색해서 같은 값을 찾으면 키가 중복되므로 삽입할 수 없고, 탐색에 실패하면 같은 키가 없는 것이므로 실패한 자리에 삽입하면 된다. 마찬가지로 재귀와 반복 모두 구현 가능하다.삭제 연산삭제할 노드를 찾기 위해 탐색을 먼저 해야 하며, 세 가지 상황으로 나뉜다.\t삭제하려는 노드가 단말 노드일 때 : 그냥 지우면 된다.\t삭제하려는 노드가 양쪽 서브트리 중 하나만 가질 때 : 노드를 삭제한 후 서브트리를 이어붙이면 된다.\t삭제하려는 노드가 양쪽 서브트리를 모두 가질 때 : 두 서브트리 중 하나를 루트로 만들어 이어붙여야 한다.삭제하려는 노드가 단말 노드일 때해당 노드의 부모 노드를 찾아서 링크를 null로 만들고 해당 노드는 메모리를 동적으로 해제하면 된다. 이때 삭제할 노드와 부모 노드를 함께 알아야만 삭제가 가능하다.삭제하려는 노드가 서브트리를 하나 가질 때해당 노드를 삭제한 후 자식으로 있던 서브트리를 붙이면 된다. 부모 노드와 자식 노드를 알아야 한다.삭제하려는 노드가 서브트리를 두 개 가질 때해당 노드를 삭제한 후 왼쪽이나 오른쪽 서브트리를 이어 붙이면 되는데, 붙이고 나서도 이진 탐색 트리의 조건을 만족해야 한다. 고로 삭제되는 노드와 가장 값이 비슷한 노드를 붙여야 한다.삭제되는 노드와 가장 비슷한 노드는 왼쪽 서브트리의 가장 오른쪽 값과 오른쪽 서브트리의 가장 왼쪽 값이다. 책의 설명에 의하면 둘 중 어떤 것을 선택해도 상관 없으며 여기서는 오른쪽 서브트리의 값을 선택한다고 한다.이어 붙일 노드를 정했다면 원래 있던 노드를 삭제한 자리로 옮기면 된다. 서브트리를 모두 옮기는 것이 아니고 단말 노드 하나만을 옮긴다.이 과정을 수행하기 위해 삭제할 노드, 삭제 노드의 부모 노드, 후계자 노드, 후계자 노드의 부모 노드를 알아야 한다. 이중 후계 노드와 후계 노드의 부모 노드는 함수 내에서 탐색을 통해 찾을 수 있으므로 함수에는 삭제 노드와 삭제 노드의 부모 노드만 전달하면 된다.세 가지 경우 모두 삭제 노드와 삭제 노드의 부모 노드만 알면 수행 가능하므로 하나의 함수로 구현하고 선택문을 두어 세 가지 경우를 구분하여 처리한다. 복수의 노드 정보를 필요로 하므로 노드 클래스에서 구현할 수는 없다.이진 탐색 프로그램위에서 설계한 이진 트리 클래스를 종합하고 인스턴스를 생성하여 테스트해본다.이진 탐색 트리의 성능 분석이진 탐색 트리의 시간 복잡도에 대해 설명하고 있다. 균형 트리에 대해 언급하였다.이진 탐색 트리의 응용: 영어 사전꼭 영어 사전일 필요는 없다. 트리에 저장되는 레코드는 단어와 의미를 갖고, 단어는 공백이 없는 하나의 문자열, 의미는 여러 개의 단어로 이루어진 문자열이다.사전의 기능은 입력, 삭제, 단어 탐색, 의미 탐색, 사전 출력, 종료로 구성된다." }, { "title": "22.09.06 sunny after rain", "url": "/satinbower-legacy/posts/daily-220906/", "categories": "내가 해냄", "tags": "내가 해냄", "date": "2022-09-06 16:46:00 +0900", "snippet": "대면 강의이번 학기부터 대부분 심전 과목이라 좀 자신이 없다. 내가 언제까지 잘할 수 있을지 모르잖아요. 잘하는 줄 알았는데 사실 빈 깡통이었으면 어떻게 해.한자 쓰기초등 2학년 2페이지 복습. 피곤해서 그런지 쓰다가 조금 졸았다.자료구조 이진 탐색 트리 공부하기나는 트리 다음 챕터가 우선순위 큐인 줄 알고.. 강의가 우선순위 큐부터 시작하니까 오늘은 트리 복습만 하면 되겠지 했는데.. 그게 아니더라고. 트리와 우선순위 큐 사이에 챕터가 하나 더 있었어. 오늘도 내가 헤내볼게.공부 결과 : [자료구조] 이진 탐색 트리" }, { "title": "22.09.05 localized heavy rain", "url": "/satinbower-legacy/posts/daily-220905/", "categories": "내가 해냄", "tags": "내가 해냄", "date": "2022-09-05 20:50:00 +0900", "snippet": "대면 강의비가 오니까 조금 일찍 출발했다. 도착은 그럭저럭 일찍 해서 잠깐 놀았다. 집에 갈 때는 너무 귀찮았다..비대면 공지 기다리기그러나 일기예보상으로 아침에 비가 그친다는 사유로 단호하게 대면 공지 받았고요.. 비는 8시쯤에 그친다지만 난 7시에 나가야 하고요.. 학교에 도착하기 전까진 학생이 아니다 이거지한자 쓰기초등 2학년 1페이지 복습하면서 못 외운 한자 더 쓰고 2페이지 진도 나간다." }, { "title": "[자료구조] 트리", "url": "/satinbower-legacy/posts/it-data-structure-tree/", "categories": "IT, Data Structure", "tags": "지식, IT, 자료구조, 트리", "date": "2022-09-04 20:05:00 +0900", "snippet": "참고자료&lt;C++로 쉽게 풀어쓴 자료구조&gt; 천인국, 최영규 지음, 생능 출판사공부 범위 : 챕터 8 트리트리의 개념트리는 계층적인 자료구조. 인공지능 문제에서는 결정 트리에 사용됨.용어 정리 노드(node) : 트리에 존재하는 각 지점들 루트 노드(root node) : 트리 최상단에 있는 노드 서브트리(subtree) : 루트 노드 아래에 있는 노드들 간선(edge, 에지) : 노드의 연결선 부모 노드(parent node) : 어떤 노드의 바로 위에 연결된 노드 자식 노드(children node) : 어떤 노드의 바로 아래에 연결된 노드 형제 관계(sibling) : 같은 부모 노드를 갖는 자식 노드들 간의 관계 조상 노드(ancestor node) : 루트 노드에서 어떤 노드까지의 경로를 이루는 노드들 자손 노드(descendent node) : 어떤 노드 아래에 연결된 모든 노드 단말 노드(terminal node, leaf node) : 자식 노드가 없는 노드 비단말 노드(nonterminal node) : 자식 노드가 존재하는 노드, 단말 노드의 반대 차수(degree) : 어떤 노드가 갖는 자식 노드의 개수 트리의 차수 : 트리가 갖는 노드들의 차수 중 가장 큰 값 레벨(level) : 트리의 각 층에 번호를 매기는 것, 루트 노드에서 1부터 셈 트리의 높이(height) : 트리가 갖는 최대 레벨 포리스트(forest) : 트리의 집합트리의 표현가장 일반적인 방법은 노드 구조를 이용하는 것. 연결 리스트와 유사하며 각 노드는 데이터 필드와 링크 필드를 갖는다. 링크 필드의 개수는 자식 노드의 수와 같다. 실제로 구현할 때는 링크 필드의 수가 일정하지 않으면 구조가 복잡해지므로 이진트리를 많이 사용함. 이 책에서는 이진트리만 다룬다.이진트리 소개이진트리란?모든 노드가 2개의 서브트리를 갖는 트리, 서브트리는 공집합일 수 있다. 모든 노드는 최대 2개의 자식만을 가질 수 있으며 왼쪽과 오른쪽이 구분되어야 한다.이진트리의 성질 노드 n개 → 간선 (n - 1)개 높이가 h인 이진트리의 노드 수 : h개 이상, (2h - 1)개 이하. 레벨 i에서 노드의 최대 개수는 (2i - 1)개. n개의 노드를 갖는 이진트리의 높이 : ⌈log2(n + 1)⌉ 이상, n 이하 포화 이진트리(full binary tree) : 각 레벨에 노드가 꽉 찬 이진트리. 높이가 k이면 노드는 (2k - 1)개. 각 노드에 번호를 붙일 수 있으며 레벨 단위로 왼쪽에서부터 차례로 붙이면 되고, 항상 일정하게 부여됨. 완전 이진트리(complete binary tree) : 높이가 k인 트리에서 레벨 1부터 (k - 1)까지는 모든 노드가 채워져 있고, 마지막 레벨은 왼쪽부터 순서대로 노드가 채워진 트리. 절대 중간이 비어 있으면 안 되고 노드 번호는 포화 이진트리와 같음.이진트리의 추상 자료형트리를 생성하고, 이런저런 정보를 확인하고 삽입, 삭제 등을 수행하는 추상 자료형. 자세한 건 직접 책을 보자.이진트리의 표현배열 표현법저장하고자 하는 이진트리가 완전 이진트리라고 가정, 정해진 높이에 따른 노드 수만큼의 배열을 생성한다. 완전 이진트리의 노드 번호대로 정보를 배열에 저장한다. 주로 포화/완전 이진트리에서 많이 쓰긴 하는데 일반 이진트리도 저장할 수 있다(대신 공간 낭비 심함). 다만 인덱스 0번은 사용하지 않는다. 그게 편하다. 배열의 크기를 변경할 수 없으므로 트리의 높이가 제한되어 많이 사용하지 않음.링크 표현법트리의 노드들은 공간적으로는 흩어져 있고, 각각 데이터 필드와 링크 필드를 갖는다. 왼쪽과 오른쪽을 구분한다.링크 표현법을 이용한 이진트리의 구현자세한 코드는 생략. 노드 클래스를 먼저 만들고, 그것을 이용해 트리 클래스를 만든다. 노드 클래스는 데이터 필드와 왼쪽, 오른쪽 자식 노드의 링크 필드를 갖고, 트리 클래스는 루트 노드의 포인터만을 멤버 필드로 갖는다.이진트리의 순회이진트리의 순회 방법루트와 서브트리 방문 순서에 따라 구분, 이름은 루트 기준 전위(preorder) : 루트 - 왼쪽 - 오른쪽 중위(inorder) : 왼쪽 - 루트 - 오른쪽 후위(postorder) : 왼쪽 - 오른쪽 - 루트순회 방법은 자식 노드와 부모 노드의 처리 순서에 따라 다르게 선택한다. 자식 노드를 먼저 봐야 한다면 후위 순회, 부모 노드를 먼저 봐야 한다면 전위 순회. 실제 구현하는 코드는 재귀 호출의 순서만 다를 뿐 큰 구조는 같다.레벨 순회(level order)표준 순회 방법은 아니지만 많이 사용한다고 한다. 각 노드를 레벨 순으로 검사하는 방법이다. 앞서 소개한 세 가지 방법은 자료구조로 치면 스택을 사용한 것이고 이 방법은 큐를 사용하는 것이다.큐에서 노드를 하나 꺼내 방문하고 그 자식들을 큐에 넣어 같은 과정을 반복한다. 자식이 없으면 삽입하지 않고 큐가 빌 때까지 한다. 처음에는 루트 노드를 넣는다. 재귀 호출을 사용하지 않는다.이진트리 연산트리의 노드 개수 구하기모든 노드를 순회하여 개수를 센다. 루트 노드와 양쪽 서브트리의 노드 개수를 합하면 된다. 재귀 호출로 구현한다.단말 노드 개수 구하기마찬가지로 모든 노드를 순회하는데, 양쪽 자식이 모두 없는 경우만 센다. 구현은 전체 노드 개수 구하기와 유사하다.높이 구하기루트노드에 대해 양쪽 서브트리의 높이를 구하고 그 중 (높은 쪽 + 1)을 결과로 반환한다. 루트 노드도 높이로 셈해야 하기 때문에 서브트리의 높이에 1을 더해야 한다. 재귀 호출로 구현한다. 이 챕터에서 다루는 함수 중 재귀 호출로 구현되는 것 대부분이 실제 사용을 위해 작성되는 함수와 그것을 호출했을 때 실행되는 함수가 메소드 오버로딩으로 서로 다른 인자를 받도록 구현되어 있음에 주의해야 한다.이진트리 응용수식 트리노드가 산술식이나 논리식의 연산자와 피연산자로 이루어진 트리이다. 피연산자는 단말 노드가 되며 연산자는 비단말노드이다. 이 트리는 자식 노드를 먼저 계산하고 부모 노드를 계산해야 하므로 후위 순회를 해야 한다.디렉터리 용량 계산지금은 이진트리를 사용하고 있기 때문에 한 폴더에 두 개보다 많은 하위 폴더가 존재하면 안 된다. 서브 디렉터리의 용량을 계산한 후 루트 디렉터리의 용량을 계산해야 하므로 마찬가지로 후위 순회를 사용한다.스레드 이진트리목적 : 재귀 호출이나 다른 자료구조의 혼용 없이 순회를 구현하고 싶다.실현 방안 : 트리에 존재하는 null 링크들(주로 단말 노드에 많음)을 원래 순회 과정에서 다음에 방문해야 할 노드(후속자)에 연결해놓기. 예를 들어 중위 순회이고 B - A - C 순서로 방문해야 한다면 실제 트리 구조상 연결 관계는 B ← A → C인데, 순회 순서에 맞게 B → A 링크를 만들어 둔다는 것. 이때 각 노드에 연결된 링크가 트리의 간선인지 순회를 위한 링크인지 구분하기 위한 필드 변수(bool)가 추가로 필요하다. 순회를 위해 연결하는 링크는 오른쪽 간선을 이용한다. 자세한 코드는 생략한다." }, { "title": "22.09.04 today I did", "url": "/satinbower-legacy/posts/daily-220904/", "categories": "내가 해냄", "tags": "내가 해냄", "date": "2022-09-04 18:30:00 +0900", "snippet": "수강 정정 고민하기원어민 교수님이 강의하시는 영어 녹화 강의를 하나 신청했었는데, 아무래도 귀에 들어오지 않는다. 영어 유튜버 영상은 잘만 보는데 왜 그건 안 되나 몰라.. 내가 열심히 집중하면 테드 유튜브도 볼 수 있거든요. 그건 집중력이 많이 필요하긴 한데 되긴 돼. 근데 이 강의 영상은 그냥 뭔가 귀에 안 들어와. 그래서 학점을 위해 내려놓기로 했다. 테드나 들어라 휴먼.낮잠 자기개강해서 3일 연속으로 통학을 했더니 정말 피곤하더라. 금요일에도 종일 자고 오늘도 종일 잤다. 뭐 잘은 잤는데 내 하루를 빼앗기는 느낌이라 달갑지는 않네요.한자 쓰기초등 2학년 1페이지 복습이야. 오늘은 종이에 되는 만큼 썼다. 내일도 같은 페이지를 쓸까 아니면 진도를 나갈까?자료구조 트리 공부하기전공 학과 문제로 다른 교수님의 같은 과목을 들어야 하게 됐는데, 내가 이전에 배웠던 선수과목 진도랑 안 맞아서 그 빈 공간을 독학으로 채워야 한다. 쉽지 않네..공부 결과 : [자료구조] 트리" }, { "title": "22.09.03 today I did", "url": "/satinbower-legacy/posts/daily-220903/", "categories": "내가 해냄", "tags": "내가 해냄", "date": "2022-09-03 14:29:00 +0900", "snippet": "수강 신청 문제내가 지금 주전공으로 속한 A라는 학과가 특정 학번부터 B라는 다른 학과로 바뀌는 과이다. 그래서 의미상으로는 A학과는 B학과의 전신이니까 같은 전공 수업을 듣는 게 맞는데, 행정적으로는 별개의 과라서 내가 B학과 전공 수업을 듣지 못하게 된 과목이 생겼다. 문제는 A학과에서는 이제는 개설되지 않는 과목이라 이걸 못 들으면 그대로 그냥 못듣는 과목이었다. 다만 내가 A, B 학과와 계열이 같은 C학과를 부전공으로 이수하고 있었는데, C학과에서도 같은 수업이 개설된다. 이 C학과의 수업은 수강 신청이 가능해서 수강 신청을 해뒀었다.개강을 하고 오리엔테이션 영상이 올라와서 봤는데 교수님이 C학과가 주전공이 아닌 같은 계열 학과 전공생들은 각자 자기 전공에 맞는 수업을 들어야 한다고 수강하지 말라고 하셨다. 내가 이걸 보고 또 가만히 있으면 안 될 것 같아서 (1) 수강 정정 기간에 수강 정정 시도해보고(불가했음), (2) 교학팀에 전화해서 내가 잘못한 게 있나 물어보고(행정적 문제 없음), (3) 마지막으로 내가 수강 신청한 과목의 교수님께 사정이 이리 되었으니 내가 이 수업을 들어도 되겠느냐 이메일을 보냈다. 사실 이런저런 이유로 내심 C학과 수업이 듣고 싶기도 해서 교수님이 허락해주시길 바라고 어떻게든 내 무력함을 어필했지만 교수님은 생각만큼 만만하지 않으셨고.. A학과의 학과장님과 바로 얘기해서 내가 B학과의 전공 수업을 들을 수 있게 될 것 같다고 알려주셨다. 지금은 주말이니 당연히 바로 고쳐지기를 바라긴 어려울 테고, 월요일에 다시 수강 정정을 시도해봐야 한다. 아니 근데 나는 진짜로 C학과 그 교수님 수업 들어보고 싶은데..한자 쓰기초등 1학년 한자 복습하고 2학년 한자 1페이지 썼다. 학년 하나 달라졌을 뿐인데 획 수가 갑자기 많아진 느낌이더라. 그래서 이제부터는 한 페이지씩 쓰기로 했다. 그리고 한자 노트를 사기로 했다. 역시 필기는 종이에 손으로 하는 게.블로그 글 옮기기이번에 옮길 글은 사진도 많고 글에 서식도 꽤 들어가서 처음부터 html로 쓰고 있다. 마크다운은 편하게 쓰기 좋은 건 맞는데, 이런저런 세부적인 꾸미기라든가 서식을 쓰고 싶으면 결국 html을 섞어야 하고, 이게 또 잘못 섞으면 서로 서식을 잡아먹어서 글이 이상해지거든요. 그러느니 처음부터 끝까지 html로 쓰는 게 훨씬 낫더라. 재밌습니다. 내가 코드를 얼마나 잘 써먹냐에 따라 글이 점점 까리해진다구요. 크롬 창으로 바로 확인도 되니까 할 맛이 납니다. 나는 결과가 눈에 바로 보이는 코딩이 좋아.근데 나는 코드 블록이 이렇게나 정말 빚어서 만든 결과물인 줄은 몰랐다.. 어쭙잖게 따라해보려다 눈만 건조해져서 그냥 자동 생성된 코드 그대로 썼다. 참 쉽지 않네. 아니 사실 이게 마크다운 쓰면 그냥 ```로 감싸기만 해도 되는데 html로 아예 새로 빚으려니까 어려운 거야. 내가 이대로 공부를 계속 해서 뭐라도 사람 몫이나 할까 싶다.참고 링크 HTML-CSS] 글자 색깔 지정하기, 글자색 변경 - Color 컬러 지정 ← 오타 아니고 진짜 원본 글 제목에 여는 대괄호가 안 써있다. 내가 오타 낸 거 아님. [HTML/CSS] HTML 에서 진짜 탭(tab)을 사용하는 방법 코딩 자율학습 HTML + CSS + 자바스크립트 - 4.2.1 내부 스타일 시트 사용하기 HTML로 코드 블록 작성 CSS / background-color / 배경색을 정하는 속성 블로그 HTML 코드블럭 스크립트 (Color Scripter) Color Scripter Simple &amp; Flexible Syntax HighLighter CSS / 기초 / !important" }, { "title": "22.09.02 daily log", "url": "/satinbower-legacy/posts/daily-220902/", "categories": "내가 해냄", "tags": "내가 해냄", "date": "2022-09-02 21:49:00 +0900", "snippet": "어제 한 일 개강하기 통학 1일차 피곤해서 아무것도 안하고 누워있다가 자기오늘 한 일다른 강의 또 개강하기. 이번에 새로 고용된 강사님이었는데 첫인상이 좋다. 이론+프로젝트 수업인데 수강 인원도 적어서 딱 좋다. 마음에 들었지만 1시간 반 걸려서 갔는데 오티가 20분만에 끝나서 허망했다. 돌아갈 때는 지쳐서 2시간도 넘게 걸리거든요.. 내가 3시간이 넘도록 지하철을 타야 했는데 수업이 겨우 20분이라니 그러느니 풀강을 해달라구요.한자 쓰기초등 1학년 한자를 다 써서 오늘은 쭉 훑어보면서 기억 안 나는 것들 다시 한 번 썼다. 내일 또 써보고 기억하면 초등 2학년으로 넘어간다.html만 써서 포스트 올려보기(8월 31일)잘만 되더라. 맘에 든다.그 포스트 : 향낭 만들기, 정원 박광훈 복식박물관, 성신여대 자연사박물관" }, { "title": "향낭 만들기, 정원 박광훈 복식박물관, 성신여대 자연사박물관", "url": "/satinbower-legacy/posts/knowledge-make-scent-bag/", "categories": "기타 지식", "tags": "박물관, 후기", "date": "2022-08-31 20:42:00 +0900", "snippet": " 향낭 만들기 정원 박광훈 복식박물관에서 향낭 만들기를 했다. 사전 신청을 하고 추첨(선착순)에 뽑혀야 참석 안내 연락이 오고 그 연락을 받아야 갈 수 있다. 내가 이걸 몰라서 한 번은 뽑히지도 않았는데 냅다 찾아간 적이 있었지. 다행히도 그때는 재료가 여분이 있어서 같이 끼어서 할 수 있었다. 이번 향낭 만들기는 정원 박광훈 복식박물관을 간단히 안내와 함께 관람한 후 바느질을 하는 게 주요 활동인데, 안내가 정말 신기하긴 했지만 내가 메모를 못해서(사실 필기라고 하는 게 맞다) 기억이 하나도 안 남았다. 아니 진짜 신기하고 재밌긴 했는데 내가 기억을 못하는 것 뿐이야.. 오늘 활동은 미리 모양이 잡힌 비단 주머니에 끈이 지나갈 길을 만들어주는 게 내가 할 일이었다. 바느질 이름이 생각이 안 나서 잠깐 찾아봤는데 박음질이 내가 했던 방법이랑 같다. 확인해보려고 영상도 봤는데 나보다 두 배는 효율적으로 하더라.. 어쩐지 내가 수강생 중에 제일 느리다 했어.. 어쨌든 박음질로 끈이 지나갈 길을 만들고 나면 '고무줄빼기'라는 것으로 끈을 잡고 비단 주머니를 통과시킨다. 두 개의 매듭 끈을 교차하여 끼워넣고 각각 양쪽에서 약간의 길이를 남긴 후 바짝 묶고 남은 끈은 과감히 자른다. 선생님 말로는 라이터로 끈을 지지면 플라스틱처럼 녹아 붙어서 안 풀릴 거라는데, 집에 와서 해보니까 끈이 타기만 하고 안 녹았다.. 안 풀리게 곱게 써야지 별 수 있나. 끈까지 다 감고 나면 바느질을 하기 위해 그렸던 선을 지우고 향낭 안에 들어갈 다시백을 채운다. 주머니가 무려 비단인데 향낭 내용물을 직접 넣어서야 되겠습니까. 비단에도 안 좋고 내용물도 샙니다. 다시백에 욕심 부리지 말고 조금만 넣어서 향이 나는 오일 조금 뿌리고 다시백을 곱게 접어서 향낭에 넣고 끈을 쭉 당기면 완성이다. 향 오일도 욕심 내면 냄새 엄청 많이 난다. 욕심 내면 안 되더라. 향낭 만들기, 복식박물관 사진 향낭 만들기 재료 왼쪽부터 비단 주머니에 밑선을 그을 자와 수예용 수성펜, 매듭 끈, 다시백, 고무줄빼기, 프로그램 팜플렛이 있고, 다시백 위에 포장용 상자가 있다. 포장용 상자에는 복식박물관 스티커가 붙어 있다. 완성한 향낭 사진은 학식당에서 찍었다. 향낭 만들고 나서 밥 먹으러 가서 밥 받아 놓고 먹기 전에 찍은 거다. 꽃 자수는 목공풀로 붙인 거라고 했다. 진짜 비단 주머니에 자수가 되어 있는 게 아니다. 정원 박광훈 모형 복식박물관에 600여 벌의 한복을 기증하셨고, 19년도에 돌아가셨다고 한다. 같이 프로그램을 들었던 아주머님들은 다들 저 방 안에 있는 가구가 익숙하다며 반가워하셨지만 나는 인두나 화로 같은 것 빼고는 잘 모르겠다. 한복 입은 테디베어들 박물관에 찾아오는 어린이들이 가장 좋아하는 것이라고 한다. 박물관 구석에 있다. 전시관에서 찍은 사진 자세한 설명 내용은 기억이 안 난다. 황비가 입는 예복이었다고 들은 것 같다. 손에 든 물건은 나중에 다시 찾아봤는데 '규'라고 부르면 되는 것 같다. 전시관에서 찍은 속치마 사진 저 때깔 고운 치마가 속치마라고 한다! 중국의 한푸는 몸에 딱 붙어서 몸매를 드러내는 걸 미로 여기지만 한국의 한복은 비단으로 지은 옷을 겹겹이 입어서 풍성하게 만드는 것을 미로 여겼다고 한다. 당시엔 비싸고 귀한 재료였던 비단을 많이 살 수 있다는 재력을 보여준다는 의미도 있었다고 한다. 그래서 속옷도 저렇게 풀을 먹여 모양을 잡아주게 하거나(제일 왼쪽), 물을 들여 꾸미기도 했다고 한다(오른쪽 삼색 치마). 아래에 살짝 보이는 건 진짜 속옷이다. 이너웨어라고 부르는 그 속옷. 전시되어 있던 단추 도슨트 설명에서는 듣지 못했지만 내가 예뻐서 찍었다. 자연사박물관 관람하기 향낭 만들기 선생님이 여기 박물관 다 돌고 스티커 모아서 가면 선물을 준대서 도장깨기를 하러 갔었다. 내가 어제 저녁에 커피를 마셨더니 새벽까지 영 잠이 안 와서 못잤더니 너무 피곤해서 제대로 즐기지는 못했다. 관람에는 대충 1시간 정도 걸렸던 것 같다. 그나마도 전부 정독하고 싶은 걸 피곤해서 다 못 보고 표본만 하나씩 보고 나온 시간이다. 물론 내가 관심이 있어서 그렇게 자세히 보는 거니까 보통은 1시간도 길고 30분 정도면 금방 보고 나올 정도의 양이었다. 표본이 많아서 좋았다. 근데 박물관 다 돌고 나서 스티커를 받으러 갔더니 스티커북이랑 스티커를 줬는데, 나는 스티커 3개만 붙이면 되는 줄 알고 금방 하겠네 싶었다만 스티커 붙일 자리가 6개나 있었다. 게다가 하나는 인스타 팔로우를 해야 붙일 수 있는 스티커였다. 내가 인스타 계정이 없는 시점에서 도장깨기는 글렀다. 그리고 이 학교 박물관은 입구에 사람이 없어서 들어가기가 너무 부담스럽거든요. 그냥 스티커 안 모을래.. 사진 보기(* 벌레 사진 있음) 오케나이트 광석인데 곰팡이같이 생겨서 신기해서 찍었다. 아게이트 예뻐서 찍었다. 굳이 내 마음에 더 들었던 전시물을 고르자면 자수정 기둥이긴 한데 그건 핸드폰 카메라로 내 마음에 들게 찍을 자신도 없고 기운도 없어서 그냥 이걸로 대리만족한 셈 치자. 댕댕이덩굴 표본 이름이 재밌어서 찍었다. 이 식물에 대해서는 아무것도 모른다. 아까시나무 표본 보통 아카시아 나무라고 부르는 것들이 사실은 이 식물이라고 들은 적 있는 것 같다. 학명도 잘 읽어보면 슈도아카시아라고 써있다. 이름부터 가짜 아카시아라니 한 존재의 이름으로서는 퍽 유감스러운 작명입니다만 학자들이 다 그렇죠 뭐. 학자들은 감성이 중요한 게 아니거든요. 저건 필요해서 지은 이름이지 예쁘라고 지은 이름이 아니니까 저렇게 불러야 했던 이유가 있을 겁니다. 나방 표본 사진 내가 필요를 못느껴서 안 찍긴 했는데, 이게 바닥에 곤충 표본을 모아서 소용돌이라든가 동심원 같이 모양을 만들어서 전시한 부분에 있던 거라 따로 써있는 이름은 없고 곤충 표본 밑에 같이 꽂는 표본 이름표만 있다. 문제는 그 이름표는 저 나방에 가려서 안 보인다는 거지. 그래도 이름은 대충 안다. 옥색긴꼬리나방 아니야? 이건 전에 다른 박물관에서 본 적 있는데 생긴 게 딱 눈에 들어와서 금방 외웠어. 크기만 작았다면 귀엽다고 생각했을 테지만 저게 살아서 날아다닌다고 생각하면 아무리 때깔이 고와도 나는 피하고 싶어. 방동사니 모형 내가 집 근처 강가 걸어다니다가 저렇게 생긴 식물을 몇 번 봤거든. 이름을 몰라서 사진만 찍어뒀던 것 같은데 저게 딱 그 식물이랑 비슷하게 생겨서 이건가 하고 찍어왔다. 근데 아닐 수도 있음. 식식성 풍뎅이류 설명과 한살이 그림 내가 사는 집 옥상에 500리터들이 노란 수조가 있는데, 거기에 물 대신 흙이 채워져 있어. 매년 그 흙을 뒤적거리면 꼭 저렇게 생긴 굼벵이들이 서너 마리씩 굴러나오더라고. 대체 뭔가 싶었는데 여기 식식성 풍뎅이 설명이랑 한살이 보니까 대충 식식성 풍뎅이 중 하나가 아닐까 싶어서 찍었다. 난 한 번도 성체를 본 적이 없어.. 꽃무지류 유충 모형 옥상 화분에서 나오는 굼벵이가 딱 저렇게 생기고 저정도 크기야. 근처에 장수풍뎅이 유충 모형도 있었는데 그건 크기가 집에 있는 것보다 컸어. 삵 삵이 그래도 육식성 포식자인데 너무 애처로운 얼굴과 자세로 박제된 것 같아서 사진 찍었다. 저건 너무 아기 고양이 같잖아. 저 위에 청설모 박제가 있었는데 그게 더 당당했어. 꾀꼬리 꾀꼬리가 노란색인 줄은 몰랐다. 신기해서 찍었다. 쇠박새 가끔 길가다 보면 보이는 참새 정도 크기에 팬더 색깔인 새 이름을 몰라서 팬더 참새라고 불렀는데 이 새인 것 같다. 박새 쇠박새랑 비슷하게 생겼는데 좀 더 크다. 이 새도 내가 이름을 몰라서 부르던 팬더 참새랑 비슷하게 생기긴 했는데 그 새는 아닐 것 같다. " }, { "title": "22.08.31 today I did", "url": "/satinbower-legacy/posts/daily-220831/", "categories": "내가 해냄", "tags": "내가 해냄", "date": "2022-08-31 20:41:00 +0900", "snippet": "향낭 만들기, 자연사박물관 관람내용이 하도 길어서 따로 썼다.향낭 만들기, 정원 박광훈 복식박물관, 성신여대 자연사박물관 학식당에서 점심 먹기 사진 보기 점심 메뉴 메뉴는 귀찮으니 굳이 말하지 않겠다. 맛있었다. 내가 19년도에 대면 수업 다닐 때는 이렇게 딱 식판에 정해진 메뉴 말고도 별도로 주문할 수 있는 단품 메뉴가 있었는데 그간 코로나로 비대면 시기를 거치면서 뭔가 달라졌는지 이제 그런 단품 메뉴는 없었다. 간만에 급식 먹으니까 좀 그냥 뭐 그렇긴 하더랍니다.. 예전엔 학식 맛있었는데 그때보다는 맛이 덜한 것 같긴 하다.블로그에 오늘 한 일 쓰기사진이 많아서 참 쉽지 않았다. 내가 해냄이다." }, { "title": "생물다양성과 분류학", "url": "/satinbower-legacy/posts/knowledge-biodiversity-1/", "categories": "생물", "tags": "지식, 생물, 생물다양성, 분류학", "date": "2022-08-30 20:10:00 +0900", "snippet": "강의명 : 생물 다양성과 분류학매년 5월 22일은 국제 생물다양성의 날.강의 구성 생물 다양성을 왜 보존해야 하는가? 생물다양성 협약 분류학: 생물다양성을 연구하는 학문 한반도 생물들의 자료1. 생물다양성을 왜 보존해야 하는가?국제자연보호연맹 IUCN에 의하면 지구상에는 약 166만 종이 존재하는 것으로 파악됨(기준 연도는 강의에서 언급하지 않음). 우리에게 익숙한 척추동물, 포유류는 각각 전체의 4%, 0.33%밖에 차지하지 않고, 가장 종류가 많은 군은 곤충이다. 그러나 곤충은 지구상에 가장 “많은” 생물은 아님. 지구 표면의 우점 생물은 식물이다. 우주에서 보면 파랗잖아.국립생물자원관의 통계에 의하면 우리나라에는 약 5만 4천 종의 생물이 존재한다. 그중 동물은 약 3만 1천 종, 식물은 약 8천 종, 그리고 그중에서도 꽃식물은 약 4천 종.지구에는 지금까지 5번의 대멸종이 있었다. 그리고 최근, 6차 대멸종의 조짐이 보이고 있다. 인간 활동으로 인한 환경 오염, 기후 변화, 서식지 파괴, 남획, 밀렵과 밀거래, 침입외래종 피해 등으로 인해 지구의 생물다양성이 급속도로 감소하고 있다. 이 속도가 과거 다섯 차례의 대멸종에 비견할만 하여 학자들은 인간에 의한 6차 대멸종을 말하고 있다고 한다. 고로, 생물다양성을 보존하자.생물다양성 보존이 왜 중요한가? (1) 다양한 생물은 인간이 활용할 수 있는 잠재적인 자원이다(예: 페니실린, 아스피린, DNA 중합효소). (2) 생물다양성은 생태계를 유지하는 완충제 역할을 한다(예: 바나나의 유전적 다양성 문제 - 바나나 원종 수집 후 보존 노력). (3) 각각의 생물들은 자연의 먹이사슬을 이루는 단위 요소이다(species jenga, 종들의 젠가).2. 생물다양성 협약생물다양성 협약 : 생물다양성을 종, 생태계, 유전자의 세 가지 수준에서 파악하고, (1) 생물다양성의 보전, (2) 생물다양성 구성 요소의 지속 가능한 이용, (3) 유전자원의 이용으로부터 발생하는 이익의 공정하고 공평한 배분을 목적으로 하는 국제조약. 대한민국은 154번째 회원국이다. 국가에 대한 “생물종주권”을 인정한다.ABS : 접근과 이익 공유 원칙. 지구상에 존재하는 생물을 이용할 수가 있는데, 누구나 그러한 권리가 있고, 이익이 발생한다면 그것을 그 생물의 주권국과 공유해야 한다는 원칙.나고야 의정서 : ABS가 실효성을 갖게 된 의정서.생물종주권에 대한 예시 세 가지 : 미스김 라일락과 구상나무, 타미플루. 미스김 라일락은 원래 국내 자생종이었으나 미국에서 이 종의 대량 증식에 성공하여 미국 라일락 시장의 히트상품이 되었는데, 이 종이 현재 우리나라에 역수입되고 있음. 마찬가지로 국내 자생종이었던 구상나무는 외국에서 크리스마스 트리로 잘 팔리고 있는데, 나고야 의정서 이전에 반출되어 우리나라에는 전혀 경제적 이익을 주지 않음. 타미플루는 중국의 붓순나무에서 유래했는데, 이 약의 개발 시점이 종주권 발효 이전이라 중국에는 아무런 이익이 생기지 않음.3. 분류학: 생물다양성을 연구하는 학문분류가 무엇인가? 책을 분류한다고 생각해보자. 크기별로 분류할 수도 있고, 색깔별로 분류할 수도 있다. 그러나 실제로는 듀이십진분류법을 따른다. 대상의 특성에 맞게 분류해야 한다는 말이다. 컴퓨터의 파일도 비슷하다. 여러 폴더를 이용하여 체계적으로 정리한다. 사물을 정리하는 것도 마찬가지다. 정리한다는 것은 잘 분류한다는 것과 같다.생물의 분류는 어떤가? 수많은 생물들을 어떤 원칙과 체계에 따라 분류한다. 강의에 따르면 분류란 사물의 실체를 파악하기 위한 가장 빠른 접근법이라고 설명한다. 생물의 분류는 진화의 역사를 바탕으로 하여 계통을 반영하는 분류가 가장 좋은 분류 방법이라고 한다.생물 분류학의 연구 과정 모든 생물의 목록 만들기 계통 유연관계 조사 유연관계에 의해 분류체계를 만든다. ‘종속과목강문계’좋은 분류 체계가 만들어지면 뭐가 좋나? 연구가 안 된 종에 대해서도 그 가치를 예상할 수 있다. 한 그룹에 속한 생물들은 비슷한 성질을 갖고 있을 것이다.분류학은 생물학에서 가장 기초가 되는 학문이고, 생물의 다양성을 연구하고 “이름”과 이들의 계통적 유연관계에 대한 학문이다. 정보의 전달에 있어서 이름은 명확해야 한다. 그렇지 않을 때 발생할 수 있는 문제의 예시로 기생성 새삼에 대한 연구가 있다. 원래 해당 연구는 새삼을 연구하는 것이 목적이었으나 실제로 연구한 식물은 실새삼이었다고 한다. 잘못된 연구를 수행한 것이다.사물탕에 대한 연구에서도 같은 문제가 있었다. 한의학에서 사물탕이란 네 가지 약재를 이용해 만드는 감기약인데, 같은 ‘사물탕’에 대해 같은 연구를 수행한 두 연구에서 전혀 다른 결과가 나온 적이 있다. 그 이유는 한약재의 이름때문이었다. 한약재로서의 식물의 이름과 분류학적 종명이 일치하지 않아 서로 다른 종을 같은 한약재로 취급하여 연구한 것이었다.쑥에 대한 연구도 예시로 들 수 있다. 동아제약에서 쑥을 이용해 스티렌이라는 약을 개발했는데, 약효의 검증에 문제가 있었다. 한국에는 약 40여 종의 쑥이 있고 이를 구분하는 것은 상당히 어렵다. 한국에는 약 40여 종의 쑥이 있고 이들을 구분하는 것은 상당히 어렵다. 따라서 학자들은 약을 만드는 데 쓰인 쑥이 어떤 종이었는지가 명확하지 않아 발생한 문제라고 보았다. 물론 현재는 잘 팔리고 있다고 한다.이 다음에 설명한 내용도 많은데 정리하다가 지쳐서 이만 끝냄..리뷰내가 생공과를 전공한 적이 있어서(중도 탈주함) 분류학 강의도 맛보기는 들어봤는데, 같은 교수님한테 배워서 그런지 익숙한 설명이 많았다. 오랜만에 다시 들으니 반갑기도 했고, 잊어버린 부분도 다시 배울 수 있어서 좋았다. 아니 원래 내가 생물 좋아했거든요. 좋아서 들은 겁니다. 생물학 취미로 하면 재밌어요 전공은 하지 말고 교양으로만 하세요." }, { "title": "22.08.30 today I did", "url": "/satinbower-legacy/posts/daily-220830/", "categories": "내가 해냄", "tags": "내가 해냄", "date": "2022-08-30 18:04:00 +0900", "snippet": "오늘 아침 메뉴김칫국, 소금 후추 뿌리고 전자레인지에 돌린 계란, 냉장고에 소분해뒀던 밥, 팝콘치킨팝콘치킨 맛있어. 어릴 때 콜팝 사면 위에 얹어주던 그 치킨 있잖아. 난 콜라 못마셔서 직접 사먹지는 않고 누가 반 전체에 간식 돌렸을 때나 먹었는데 그게 그렇게 맛있었어. 어린이 입맛에 딱이야. 오늘 먹은 건 그때랑 같은 맛은 당연히 아니지만 그래도 추억 보정이라는 게 있잖아요.노션 템플릿 만들기아니 뭐 말은 저렇게 했지만 그리 대단한 일은 아니고 내가 원래 쓰던 메모장 복제해서 조금 다듬고 공유용으로 만들었을 뿐이야. 재밌잖아. 잘 써준다니까 그것도 좋고.혹시 이 글 보는 사람 중에도 갖고 싶은 사람 있을 수 있으니까 링크를 달아두겠습니다. 이런 거 있으면 편하거든요. 삶의 질이 달라져요. 링크는 토글 누르면 나오는 이미지 누르면 됩니다. html 재밌네. 강의 노트 템플릿 강의 노트 템플릿 예시 이미지 할일 목록 템플릿 할일 목록 템플릿 예시 이미지 돈 쓰기새 마우스 2개(무선 버티컬, 무선 저소음), 핸드카트 샀다. 심부름으로 유선 마우스 하나 더 포함해서 7만원 쓰고 왔다. 간식은.. 못 사먹을지도 모른다. 아니 돈이 없는 건 아닌데 뭔가 한번에 너무 돈을 많이 쓰고 오니까 또 쓰고 싶지가 않단 말입니다. 그러니까 굳이 따지자면 안 사먹는 거지.점심 메뉴참치마요 삼각김밥 큰 거. 내 하루 일과 구성 상 점심과 저녁의 간격이 짧아서 간단하게 때우기만 했다. 근데 그거 먹고 나서 과자 더 먹긴 했어. 그래서 배 안 고픔.알약 지우기아까 트위터를 보니까 알약이 이번에 업데이트를 잘못했는지 멀쩡한 프로그램들을 랜섬웨어라고 다 지워버린다더라? 그래서 내 노트북도 뭔가 지워지기 전에 알약을 먼저 지워버렸다. 그리고 그냥 윈도우 방화벽 쓰기로 했어.한자 쓰기초등 1학년 한자 9 - 10 페이지. 이게 초등 1학년 마지막 페이지라서 내일은 9 - 10 페이지 복습하고 그 다음날에는 1 - 10 페이지 한번 훑어보고 확인할거야. 내가 벌써 일본 초등학생 1학년 수준의 한자를 다 해간다구요.저녁 메뉴김칫국에 밥 넣고 끓인 김치죽, 햄참치김밥. 3인분 쯤 된다. 2인이서 식사하고 1인이 먹을 양을 남겼으면 3인분이지. 나는 내 기준 1.5인분 먹었다. 의도한 건 아닌데 먹고 나서 생각해보니 과식이더라.문제 풀기백준 11648 지속9자리 이하의 수라고 하니까 정수로 입력받아도 돼. 각 자리 수를 곱해서 다음 수를 만드는 거니까 모듈로 쓰면 되고, 그 곱하는 과정을 함수로 만들어서 함수 한 번 호출할 때마다 카운트 증가. 함수를 호출하기 전에 자릿수를 확인해서 한 자리 수이면 중단.난 또 이것도 1000자리 수 주고 그러면 어쩌나 했는데 그건 아니었네. 내가 또 이 정도는 금방 하지!강의 듣기강의명 : 생물 다양성과 분류학매년 5월 22일은 국제 생물다양성의 날.마크다운, html로 토글 만드는 법 찾아보기마크다운은 토글을 지원하지 않아서 html로 써야 한다고 한다. 태그 이름은 &lt;details&gt;이고, 토글 제목에 들어갈 텍스트는 &lt;summary&gt; 태그 안에, 토글 내용물은 &lt;div&gt;에 쓰는데 이때 markdown=\"1\"을 옆에 붙여줘야 한다고 한다. 내가 찾아봤던 블로그의 설명에 의하면 jekyll에서 html 사이에 들어간 마크다운을 인식하게 해준다고 한다. 근데 나는 markdown=\"1\" 안 썼다. 링크나 이미지는 html로 넣는 게 편하거든요.출처 : [마크다운, Markdown] 토글(toggle), Expander control(접기/펼치기)근데 이건 좀 다른 얘기인데 지금 찾아본 블로그처럼 깃허브 페이지에 대한 설명을 하면서 정작 본인은 티스토리 쓴느 거 보면 조금 뭔가 미묘한 기분이 든다고 해야 하나, 저렇게 잘 아는데 왜 안 쓰지? 싶더라. 그래 사실 매번 마크다운 쓰고 커밋 넣는 거 귀찮긴 해.. 그냥 업로드 버튼 한 번 꾹 누른다고 되는 게 아니잖아. deploy도 매번 기다려야 하고. 그래서 안 쓰는 걸 수도 있겠다.그 뭐냐 잠시 삽질 시간이 있었어요~ 내가 참고한 블로그에서는 &lt;details&gt; 태그 안에 &lt;div&gt; 태그를 넣었는데, 내가 그걸 그대로 마크다운 문서에 섞어서 쓰니까 토글 영역이 내맘대로 설정이 안 되더라고.. &lt;details&gt; 태그 아래로 전부 다 토글 영역에 잡혀서 내 글이 죄다 잡아먹힌 데다가 마크다운도 전부 그냥 텍스트로 나와서 글이 고장났어. 내가 참 이것저것 다 바꿔가면서 커밋을 넣어봤는데 결국 마지막에 해결된 방법은 &lt;details&gt; 태그 안에 있던 &lt;div&gt; 태그를 지우는 거였어. &lt;div&gt;도 마음대로 쓰면 안 되나 봅니다. 내가 html 기본기가 없어서 아직은 잘 모르겠지만 일단 내 글은 내가 원하는 모양으로 만들었어. 공부합시다 휴먼.내 블로그 구글 검색에 노출시키기아무리 생각해도 내 블로그는 구글에서 검색해도 안 나오는 것 같아. 그래서 그걸 또 구글에 검색했더니 그냥 가만히 있으면 안 되고, 구글이 내 블로그를 크롤링할 수 있게 사이트맵이랑 로봇텍스트를 만들어줘야 한다더라고. 내가 한번 실습해보겠습니다.참고 : 깃허브 블로그 구글 검색 결과에 노출시키기나중에는 다른 블로그에서 네이버나 다음에 사이트 등록하는 것도 알려줘서 한번 해보려고 했는데, 네이버는 무조건 루트 주소(https://dapin1490.github.io)만 등록하라고 하면서 내 주소(https://dapin1490.github.io/satinbower/)는 안 받아주더라고. 아니 근데 나는 그게 루트 주소가 맞거든요. 네이버가 원하는 루트 주소로 가면 404가 뜬단 말입니다. 그래서 그냥 안 하기로 했어. 구글에만 나와도 돼..참고 : GitHub Pages 검색 등록 하기내일 할 일md 문서에 html 섞는 거 말고 아예 html 파일로 써도 블로그에 제대로 업로드되는지 해보기. 혹시 이 내용으로 글 올린 블로그 있나 잠깐 검색해봤는데 다들 마크다운으로 포스트 쓰는 걸 전제로 설명하더라. 근데 나는 마크다운에는 없고 html 태그를 써야만 되는 기능이 많이 쓰고 싶거든요. 마크다운 문서에 html 섞는 게 영 쉽지 않아요. 영역 구분을 잘 해야 한단 말이죠. 그러느니 그냥 통으로 html을 쓰면 되는 게 아니냐 이 말이에요.근데 이 글 쓰면서 생각나는 게 html로 쓰면 카테고리나 태그 지정을 못하겠더라. 내가 아직 그정도로 아는 게 없어요. 그러니까 파일 확장자를 html로 쓸 수는 없겠고, md 파일인데 실상 내용은 다 html로 쓰인 파일은 만들 수 있겠지. 한 번 해보죠. 오늘 말고 내일." }, { "title": "22.08.29 today I did", "url": "/satinbower-legacy/posts/daily-220829/", "categories": "내가 해냄", "tags": "내가 해냄", "date": "2022-08-29 15:05:00 +0900", "snippet": "한자 쓰기초등 한자 7 - 8 페이지. 복습이다.강의 듣기벌써 녹화 강의를 올리는 교수님이 있더라.. 강의 소개 영상 봤다. 학점 채우기 쉽지 않네..마크다운, html, css 찾아보기글자 색깔을 바꾸고 싶어서 찾아봤는데 이미지에 캡션 넣는 법도 같이 나왔다. 유용하게 잘 써보겠습니다.글자 색깔 바꾸기, 이미지에 캡션 넣기 : [Markdown] 마크다운 글 색상/형광펜, 이미지 크기조정/캡션삽입두 개의 이미지 나란히 나타내기 : HTML DIV tag: 두개의 영역(그림, 글자, 광고 등)을 나란히 놓기 - float:left/right아니 근데 html css 하나도 공부 안하고 필요한 것만 배워서 하려니까 어렵더라.. 그래도 성공했으니 됐지. 좀 주먹구구 같은 느낌은 있지만 나중에 내가 더 공부해서 다듬으면 되는 거 아닙니까. 일단은 공부를 하시라고요.추가앞으로 구글에서 뭐 찾아볼 때는 그 자료 언제 쓴 건지도 확인해보자.. HTML5에서는 지원이 안 되고 사라진 기능을 썼다가 고쳐넣은 포스트 죄다 오류났다. 즐겁다 이게 코딩이지.추가 2css 속성은 제대로 고쳤지만 이미지 링크를 죄다 잘못 넣어서 다시 고쳤다. 그냥 깃허브 링크만 넣으면 되는 게 아니고 raw 링크를 넣어야 한다. 아니 근데 그렇잖아 나야 눈으로 보이니까 화면 가운데 있는 저게 나타내야 할 이미지구나 하지만 HTML이 그걸 알겠냐고요 그러니까 내가 정말 딱 이미지만 골라서 찍어줘야 하는데 깃허브 리포지도리에 있는 파일만 냅다 찍어준거지. 그러니까 이미지가 안 나오지. 어쨌든 수리 성공!" }, { "title": "[html/css] 22.08.28 DAY 1", "url": "/satinbower-legacy/posts/it-220828-read-html/", "categories": "IT, HTML", "tags": "지식, IT, HTML", "date": "2022-08-28 18:07:00 +0900", "snippet": "책 정보읽은 책 : 모두의 HTML5 &amp; CSS3읽은 분량 : 책의 DAY 분류 기준으로 DAY 11. 웹 사이트의 구성HTML은 웹사이트의 설계 역할. 사이트에서 눈에 보이는 정보를 입력함. CSS는 디자인, 애니메이션 효과나 팝업 같은 기능은 js.2. 웹 사이트 레이아웃의 종류: 정적/동적, 적응형/반응형 레이아웃. 정적 레이아웃 : 공간의 크기가 변하지 않음, 고정. 브라우저 너비를 줄이면 가로 스크롤이 생김. PC에서는 화면이 모니터보다 크면 잘려서 보이고, 모바일 기기에서는 전체 화면을 디바이스에 한번에 나타내기 때문에 글씨가 너무 작게 나옴. 사용자가 쓰기 불편하다(당연히 만들기는 편하겠지). 동적 레이아웃 : 브라우저 너비와 상관 없이 콘텐츠가 화면을 꽉 채우게 나옴. 화면 크기가 변하기 때문에 가로 스크롤 없다. 대신 레이아웃이 틀어질 수 있음. 적응형 레이아웃 : 브라우저 너비에 따라 레이아웃이 달라짐. 공간의 크기는 고정되어 있다. 다양한 기기에서 지원 가능하고 반응형 레이아웃보다 빨리 만들 수 있다. 반응형 레이아웃 : 동적 + 적응형 레이아웃. 과거에는 모바일용 웹사이트를 따로 만들었지만(주소에 m.이 들어감) 반응형 레이아웃을 쓰면 그럴 필요가 없다. 개발 비용은 줄지만 개발자는 더 많은 고민을 해야 한다.3. 크로스 브라우징사용자가 사용하는 브라우저 종류와 관계 없이 같은 화면을 볼 수 있게 하는 것(정상 작동 포함). 익스플로러를 조심하라. Can I use(http://caniuse.com/) : 특정 언어의 지원 여부를 브라우저 버전별로 보여주는 웹 사이트. html, css, js의 특정 태그나 명령어를 입력하면 됨.4. 웹 표준 : 협업을 위한 약속W3C(World Wide Web Consortium)이 만든 가이드라인.웹 표준에 맞춰 사이트를 제작하면 검색 사이트에 노출될 확률이 높아지고, 장애에 대한 접근성 좋아지고, 유지보수가 편해짐.덤 - 독학 추천 사이트(내 의견 아님, 책이 추천함) 생활코딩: https://opentutorials.org/ 코드카데미: http://www.codecademy.com W3Schools : http://www.w3schools.com/내 의견 : “생활코딩”은 실상 들어가보면 사이트 이름이 “생활코딩”이 아니었다. 책에서 추천한 의도는 ‘이 사이트에서 “생활코딩”의 강의를 찾아라’인 것 같음. 코드카데미는 나도 잘 쓰고 있는데 책에서 한국어가 된다고 하는 것과는 달리 한국어 안 된다. 영어 할 줄 알면 유용하게 배울 수 있다. 영어를 못하면 크롬 자동 번역을 쓰면 된다. 번역이 그렇게 잘 되는 건 아닌데 그럭저럭 공부는 할 수 있다. W3Schools는 가끔 간단한 문법 검색하면 뜨는 사이트인데, while문을 for문 같이 써서 마음에 안 든다. while 종료 조건으로 인덱스를 따로 만들어서 쓰면 그게 for문이지 while이냐?" }, { "title": "22.08.28 today I did", "url": "/satinbower-legacy/posts/daily-220828/", "categories": "내가 해냄", "tags": "내가 해냄", "date": "2022-08-28 17:42:00 +0900", "snippet": "어나더 에덴 피어 리스트 만들기도감은 없지만 업적은 있다. 그냥은 못지나가지 수집 시작이다 이 말이야.한자 쓰기초등 1학년 7 - 8 페이지 썼다. 5 - 6 페이지는 확인해 봤는데 수풀 삼을 수풀 림으로 헷갈린 거 빼고는 다 읽을 수 있어서 넘어갔다.블로그에 오늘 한 일 쓰기그래요 내가 종일 게임을 했어요html 책 읽기읽은 책 : 모두의 HTML5 &amp; CSS3쓴 정리 : DAY 1문제 풀기백준 6378 디지털 루트. 입력되는 숫자의 길이가 최대 1000이라니까 숫자로 받으면 안 되고 문자열로 받아서 한 자리씩 떼어서 계산해야 돼. 그것만 할 줄 알면 끝났지." }, { "title": "22.08.27 today I did", "url": "/satinbower-legacy/posts/daily-220827/", "categories": "내가 해냄", "tags": "내가 해냄", "date": "2022-08-27 18:53:00 +0900", "snippet": "탈나서 새벽에 잠 설치기쉽지 않은 밤이었어.한자 쓰기초등 1학년 5 - 6 페이지 두 번째 쓴 날. 내일은 5 - 6 페이지 한자를 얼마나 알고있는지 확인하고 적당히 읽을 줄 알면 다음으로 진도 넘어가기.블로그 채우기오늘도 이전 블로그에 있던 글을 옮기고 있다. 언제 끝나냐." }, { "title": "22.08.26 today I did", "url": "/satinbower-legacy/posts/daily-220826/", "categories": "내가 해냄", "tags": "내가 해냄", "date": "2022-08-26 17:25:00 +0900", "snippet": "블로그 채우기다른 블로그에 썼던 공부 글을 옮기고 있다. 웹프로그래밍에 대해서는 하나도 몰라도 마크다운은 잘하게 될 것 같다. 나중엔 html 태그로 쓰는 것도 해볼까? 지금도 두 줄 이상 줄바꿈 할 때나 &lt;li&gt; 리스트 만들지 않고 숫자 목록 쓸 때 html 태그를 섞어서 쓰고 있긴 한데, 어디까지나 부차적인 수단이고 css는 손도 못 댄다. 그래도 배운 건 있다. 마크다운으로 글을 쓰기만 하는 건 상관이 없는데 그걸 깃허브 페이지로 올리려면 html 태그가 아닌 &lt;&gt;를 쓸 때 역슬래시를 하나씩 붙여줘야 한다. 깃허브에서 내가 마크다운으로 쓴 글을 html로 변환할 때 &lt;가 나오면 여기에 html 태그가 나올 것이라고 판단을 하는데, 이때 내가 부등호 안에 쓴 내용이 html 태그가 아니면 ‘이 태그는 존재하지 않는 태그다’ 라는 내용의 오류가 나서 블로그를 올릴 수 없다. 오류 메시지는 “ERROR: Invalid first code point of tag name U+C18C.”. 어제는 이거 해결한다고 하루 종일 커밋만 했다. 아무튼 해결했으니 됐지!하나 더 배웠다. HTML5에서 줄 바꿈 태그는 &lt;br&gt;과 &lt;br/&gt;만 쓸 수 있다. 근데 나는 전부 &lt;/br&gt;로 써서 서식으로 변환이 안 되고 태그가 본문에 그대로 나왔었다.. 사람이 뭘 모르면 이런 문제가 생깁니다..한자 쓰기초등 1학년 5 - 6 페이지 썼다. 내일 같은 페이지 또 쓴다.코딩 문제 풀기백준 3059 등장하지 않는 문자의 합, 15781 헬멧과 조끼둘 다 브론즈라서 별로 어렵지 않게 풀었다는 점이 문제라면 문제지. 실버에 쓸 기운이 없어.." }, { "title": "22.08.25 today I did", "url": "/satinbower-legacy/posts/daily-220825/", "categories": "내가 해냄", "tags": "내가 해냄", "date": "2022-08-25 17:35:00 +0900", "snippet": "한자 쓰기오늘 쓴 부분은 초등 1학년 3 - 4 페이지. 폰으로 한자 보면서 종이에 썼다. 학교 교, 가르칠 학, 바를 정 등등 16글자. 아직까지는 할만하다!깃허브 블로그 고치기(새로 만들기)전에 쓰던 템플릿이 아무리 해도 내 마음대로 다뤄지지도 않고 내가 원하는 대로 보이지도 않아서 다른 템플릿으로 새로 만들었다. 내가 뭔가 할 때마다 결과가 잘 보이고 문제 해결도 어떻게든 자료를 찾을 수가 있으니 지금은 꽤 만족스럽다! 그래도 이 블로그를 좀 더 내 손발처럼 다루려면 html, css, js는 공부해야 한다. 아니 애초에 그 세 가지 언어를 모르면서 블로그만 냅다 만든다는 게 말이 됩니까. 이래서 사람이 마음이 급하면 안 돼요 뭐든 빨리 결과 보고 싶다고 무작정 지르고 본 거잖아. 고로 내일부터 html/css 책 보기 시작합니다. 근데 다음 주 개강인데 될까?" }, { "title": "22.08.23 today I did", "url": "/satinbower-legacy/posts/daily-220823/", "categories": "내가 해냄", "tags": "내가 해냄", "date": "2022-08-23 14:46:00 +0900", "snippet": "일본어 초등 1학년 한자 1-2 페이지 쓰기어제랑 똑같은 부분 썼다. 어제는 종이로 프린트해서 썼는데, 이걸 매일 프린트하긴 좀 그렇잖아. 그래서 폰으로 쓰기 시작했다. 손목은 많이 힘들겠지만 뭐 어떻게든 타협안을 찾지 않을까?깃허브 블로그 고치기어제 열심히 헤매면서 블로그를 고치는 방법을 알았으니 오늘은 좀 더 내가 원하는 대로 카테고리도 추가하고, 어제 올린 포스트 내용도 보충했다. 아니 근데 카테고리 추가까지는 좋은데 카테고리 이름을 한글로 쓰고 띄어쓰기를 하면 그게 단어 단위로 나뉘어서 별개의 카테고리가 되더라. 그래서 언더바로 대체해보기도 하고 큰따옴표로 감싸보기도 했는데 뭘 해도 바뀌질 않아서 결국엔 띄어쓰기 포기하고 다 붙여서 썼는데도 이게 수정이 안 되는 거야. 왜 안 되지?? 하면서 어제 쓴 포스트를 보니까 포스트에 쓴 카테고리 이름 안 바꿨더라.. 설정 잘 하면 뭐하니 그걸 그대로 두면 당연히 안 바뀌지.. 아직도 띄어쓰기에 미련이 남아서 언더바라도 써봤는데, 그냥 붙여 쓰는 게 낫겠더라.. 아 정말 유감스러워요." }, { "title": "22.08.22 daily study", "url": "/satinbower-legacy/posts/daliy-220822/", "categories": "내가 해냄", "tags": "내가 해냄", "date": "2022-08-22 21:25:00 +0900", "snippet": "일본 초등 1학년 한자 교본 1-2 페이지 따라 쓰기한 페이지에 8글자씩 2페이지 해서 총 16글자. 1부터 10까지, 클 대, 작을 소, 나무 목, 남자 남, 빌 공, 아들 자.백준 9358 순열 접기 게임 해결전체 게임을 실행하는 하나의 함수를 만들고, 그 안에서 포인터 배열을 이용해 길이가 지정되지 않은 순열을 입력받음. 그 후 순열 접기 함수를 별도로 구현해 조건에 따라 호출하거나 결과 반환. cpp로 해결.깃허브 블로그 고치기포스트를 수정하거나 추가해도 블로그에 반영이 안 되는 문제가 있었음. 작성자명, 날짜 표기, 한글 사용 세 가지가 문제 사유로 추정되어 하나씩 차례로 바꿔본 결과 날짜 표기가 문제였던 것으로 밝혀짐. 이 블로그에 포스트를 쓸 때 사용하는 날짜 형식은 ISO 8601이고, YYYY-MM-DDThh:mm:ss+09:00 형식으로 쓰면 한국 시간인 UTC+9 시간으로 표기된다. 중간에 들어가는 T는 형식을 구성하는 요소이므로 바꾸지 말고 그대로 써야 함. 시간(hour)은 24시간 형식으로 써야 한다. 포스트를 고치는 것도 해결 방법이었지만 이리저리 검색해보니 변경사항이 실제 블로그에 보이게 하려면 깃허브 페이지 리포지토리에서 gh-pages라는 브랜치에 이 내용을 같이 적용시켜야 한다고 했다. 그거 merge하는 것도 쉽지 않았다. 포스트만 바꿨으면 쉽게 했을지도 모르는데, 내가 _config.yml 파일에 수정한 게 있어서 conflict가 났었다. 한참 찾다가 conflict 발생한 부분 코드 직접 수정해서 커밋 올리고 merge했다. 힘들었지만 좋은 경험이었다!" }, { "title": "[UROP] 4주 - 영화 흥행 예측 관련 논문 스터디(1)", "url": "/satinbower-legacy/posts/it-project-urop-4/", "categories": "IT, Machine Learning", "tags": "지식, IT, 프로젝트, 크롤링, 논문", "date": "2022-06-14 00:00:00 +0900", "snippet": "* 노란 글씨 : 이해 못 함읽은 논문성민·김동성·김종우(2021, 6월). &lt;온라인 리뷰에 대한 특성 기반 감성 분석을 활용한 영화 흥행 조기 예측&gt;. 대한산업공학회 춘계공동학술대회 논문집. 제주: 국제컨벤션센터.* 일반적으로 보던 논문이 아니라 ppt로 되어 있던데, 아무리 찾아도 같은 제목으로 글로 쓰인 논문은 찾을 수가 없어서 ppt로 봤다. 읽어야 할 논문이 미리 정해져 있었기 때문에 새 논문을 찾을 수는 없음. 아니 근데 진짜 발표용으로 이미 정리된 내용이라 자세히 설명된 게 별로 없고 내가 해야 할 도식화와 요약이 다 되어 있어서 원저작자의 설명을 안 듣고 이걸 어떻게 공부해야 할지 모르겠다.22.06.14 화 - 정독하고 단어 찾아보기* 기관명, 고유명사 등은 필요하다고 판단되지 않을 경우 따로 찾아보지 않음BeautifulSoup : HTML 및 XML 파일에서 데이터를 가져오기 위한 Python 라이브러리. 즐겨 찾는 파서(your favorite parser)와 함께 작동하여 구문 분석 트리를 탐색, 검색 및 수정하는 관용적 방법을 제공합니다. a Python library for pulling data out of HTML and XML files. It works with your favorite parser to provide idiomatic ways of navigating, searching, and modifying the parse tree.(출처 Beautiful Soup Documentation)Selenium : 셀레늄(Selenium)은 웹 애플리케이션 테스트를 위한 포터블 프레임워크이다. 셀레늄은 테스트 스크립트 언어를 학습할 필요 없이 기능 테스트를 만들기 위한 플레이백 도구를 제공한다.(출처 위키백과)- 플레이백 : 영상 편집에서 사용하는 용어로, 영상 소스 또는 편집이 완료된 영상을 재생하는 것을 말한다고 한다. 이때 재생하는 영상의 화질을 낮춰도 최종 결과물에는 영향이 없다고 한다. 위의 셀레늄 정의에서는, 맥락을 고려하건대 셀레늄으로 만든 기능을 재현성 있게 테스트할 수 있도록 한다는 뜻으로 쓰인 것 같다.웹크롤링 : 웹 크롤러(web crawler)는 조직적, 자동화된 방법으로 월드 와이드 웹을 탐색하는 컴퓨터 프로그램이고, 웹 크롤러가 하는 작업을 ‘웹 크롤링’(web crawling) 혹은 ‘스파이더링’(spidering)이라 부른다. 웹 크롤러는 대체로 방문한 사이트의 모든 페이지의 복사본을 생성하는 데 사용되며, 검색 엔진은 이렇게 생성된 페이지를 보다 빠른 검색을 위해 인덱싱한다. 또한 크롤러는 링크 체크나 HTML 코드 검증과 같은 웹 사이트의 자동 유지 관리 작업을 위해 사용되기도 하며, 자동 이메일 수집과 같은 웹 페이지의 특정 형태의 정보를 수집하는 데도 사용된다. 웹 크롤러는 봇이나 소프트웨어 에이전트의 한 형태이다. 웹 크롤러는 대개 시드(seeds)라고 불리는 URL 리스트에서부터 시작하는데, 페이지의 모든 하이퍼링크를 인식하여 URL 리스트를 갱신한다. 갱신된 URL 리스트는 재귀적으로 다시 방문한다.(출처 위키백과)한 블로그에 따르면 웹 크롤링은 인터넷에 검색하면 수두룩하게 나오는 것처럼 간단히 웹페이지 CSS의 특정 태그만을 긁어다 내놓는 게 아니라 www라는 월드 와이드 웹을 DFS나 BFS 방식으로 하나하나 방문하며 탐색하는 것이라고 한다.- robots.txt : 웹 페이지를 아무 데나 다 긁으면 안 된다고 한다. 웹 페이지의 루트 도메인마다 이 페이지에서 뭘 해도 되고 뭘 하면 안 되는지 알려주는 robots.txt라는 페이지가 있다고 한다. 웹 크롤러를 만들 때는 적어도 robots.txt에 적힌 내용을 따르는 것이 윤리적이며, 크롤링하여 얻은 데이터를 이익을 위해 사용하면 문제가 될 수 있다. 이 내용 이외에도 어떤 회사의 크롤러가 robots.txt를 잘 지키는지, 어디서는 어떻게 이 규칙을 지키는지 등을 원본 블로그에서 소개하고 있다.Big 6 Distributor : 논문의 맥락상 영화계의 특정 거대 배급사 여부를 데이터로 사용했다는 것 같은데, 인터넷 검색을 해봤더니 전혀 상관없는 내용만 잔뜩 나와서 정확히 무슨 의미로 사용된 말인지는 못찾았다.Random Forest : [기계학습] 랜덤 포레스트는 분류, 회귀 분석 등에 사용되는 앙상블 학습 방법의 일종으로, 훈련 과정에서 구성한 다수의 결정 트리로부터 부류(분류) 또는 평균 예측치(회귀 분석)를 출력함으로써 동작한다.(출처 위키백과)- 앙상블 학습 방법 : [통계학, 기계학습] 앙상블 학습법(ensemble learning method)은 학습 알고리즘(learning algorithm)들을 따로 쓰는 경우에 비해 더 좋은 예측 성능을 얻기위해 다수의 학습 알고리즘을 사용하는 방법이다.(출처 위키백과)XG-Boost : XGBoost(eXtreme Gradient Boosting)는 C++, Java, Python, R, Julia, Perl 및 Scala 용 정규화 그래디언트 부스팅 프레임워크를 제공하는 오픈 소스 소프트웨어 라이브러리 입니다. Linux, Windows 및 macOS에서 작동합니다.(출처 위키피디아 - 번역됨)22.06.17 금 - 논문 요약, 도식화, 재서술요약 서론 : 한 자료에 따르면 2019년 전세계 박스오피스 매출액이 420억에 달한다. 이만한 규모의 산업에서 영화의 흥행을 조기 예측하는 것은 여러 모로 도움이 된다. 관련 연구 : 생략 연구 설계 : 이 연구의 목표는 개봉 n주 후 티켓 판매량을 예측하는 것이다. 영화의 내재적 정보와 외재적 정보를 함께 고려하여 머신러닝 모델에 학습시킨다. 데이터는 전세계 영화 리뷰를 모아 놓은 사이트 IMDb에서 영화의 기본 정보를, 웹크롤링을 이용하여 기타 영화 정보를 수집했다. 수집한 테이터는 각각의 특성에 맞게 원 핫 인코딩, 최대-최소 정규화, boolean 타입, 비율 환산 등의 전처리를 했다. 리뷰 데이터는 개봉 후 몇 주 후에 몇 개나 나왔는지, 그리고 해당 기간의 평점 평균을 산출해 이용했다. 이 리뷰 데이터는 이후 주차별 모델 성능을 평가하는 데 사용한다. 데이터셋 구성은 학습셋이 전체의 80%, 6317개의 영화로 이루어지고, 테스트셋이 전체의 20%, 1580개의 영화로 이루어졌다. 활용한 모델은 선형 회귀, 랜덤 포레스트, XGBoost, DNN이다. 연구결과 : 총 티켓 판매 수를 예측하는 모델 중 MAE 기준으로 랜덤 포레스트가 가장 성능이 좋았고, RMSE 기준으로는 XGBoost가 가장 성능이 좋았다. 랜덤 포레스트 모델을 학습시킬 때 리뷰 수와 평균 평점을 데이터에 추가하거나, 리뷰 수만 데이터에 추가하거나, 평균 평점만 데이터에 추가하는 방법 중 리뷰 수만 데이터에 추가했을 때 가장 높은 성능을 냈다. RMSE 기준으로 가장 좋은 성능을 냈던 XGBoost 모델 또한 랜덤포레스트와 마찬가지로 리뷰 수를 추가했을 때 가장 좋은 성능을 냈다. 결론 및 향후 연구 방향 : 이 연구에서는 여러 가지 머신 러닝 모델을 통해 영화의 흥행을 예측할 수 있었다. 특히 랜덤 포레스트와 XGBoost가 가장 좋은 성능을 보였다. 그리고 온라인 리뷰어들의 리뷰 수를 데이터에 추가했을 때 총 티켓 판매 수를 예측하는 데 도움이 된다는 것을 확인했다. 그러니 이 연구는 정량적 정보만을 활용했을 뿐 리뷰의 정성적 요소는 활용하지 못했다. 향후 영화 리뷰의 aspect(양상, 측면)를 기반으로 감성 분석을 진행하여 리뷰어들의 영화의 aspect에 대한 평가를 정량적으로 산출하는 연구가 필요하다. 참고 문헌 : 내가 참고한 게 아니니까 생략.도식화, 재서술 목표 : 영화의 흥행을 예측하자. 사용할(수집할) 데이터 : 영화 등급, 장르, 제작사 등의 내재적 정보와 온라인 리뷰 수, 티켓 판매량, 리뷰 평점 등의 외재적 정보. 전처리 : 원 핫 인코딩, 최대-최소 정규화, boolean 타입으로만 사용하기, 비율 환산 등 데이터셋 분할 : 학습셋과 테스트셋 8:2 비율, 분할 기준에 대한 언급 없으므로 랜덤 샘플링으로 분할한 것으로 예상됨. 모델 구분 : 개봉 후 1주차 예측, 2주차 예측 등 개봉 이후 주차별로 예측 사용한 모델 : 선형 회귀, 랜덤 포레스트, XGBoost, DNN 결과 : MAE 기준 랜덤 포레스트, RMSE 기준 XGBoost가 성능이 가장 좋았다. 또한 리뷰 수를 데이터에 추가했을 때 성능이 향상됨을 확인했다. 결론 : 여러 가지 머신 러닝 모델을 통해 영화의 흥행을 예측할 수 있었으며 랜덤 포레스트와 XGBoost가 가장 성능이 좋았다. 또한 리뷰 수를 데이터에 추가하면 도움이 되었다. 이 연구는 정성적 요소를 평가에 포함하지 않았으므로 추후 이 요소를 이용하는 연구가 필요하다. 평가 의견(내 의견) : 이 연구에서는 2000년부터 2019년까지 상영된 영화의 정보를 수집하여 사용했다고 한다. 그러면 이 데이터는 개봉 일자 기준으로 시계열 데이터로 사용할 수도 있지 않았을까? 학습셋과 테스트셋을 분할할 때에도 비교적 과거의 영화를 학습셋으로 사용하고 최근의 영화를 테스트셋으로 사용했다면 시간의 흐름을 모델의 학습에 반영할 수 있을 테고, 이런 방식으로 시대의 변화에 따른 유행의 흐름도 학습 요소로 포함할 수 있을지도 모른다. 그러니까 이 연구에는 정말 정량적 요소만이 포함되었을 뿐 시대의 변화, 유행의 흐름 등은 고려되지 못했다는 말이다. 논문에 첨부된 이미지를 보면 mae가 80만이 넘게 나오던데, 최댓값이 정해진 r2 score(최대 1.0)를 평가 지표로 사용하지 않아서 확신할 수는 없지만 이 연구에서 완성한 모델은 실제로 사용하기엔 성능이 별로 좋지 못할 것 같다는 생각이 든다. 내가 지금까지 만들어본 선형 회귀 모델은 데이터에 따라 r2 score가 0.8~0.9 정도 나올 때 mae는 크게는 만 단위에서 작게는 10 미만까지 나왔다. RMSE도 r2 score가 0.8~0.9 정도 나올 때 만 단위에서 그쳤다. 데이터셋이 어떤 것이냐에 따라 큰 영향을 받긴 하지만 mae, RMSE, r2 score 모두 선형 회귀 모델의 평가 지표라는 공통점을 감안하면 mae가 80만이 넘는 건 꽤 큰 수치라고 본다. 왠지 이 논문이 연구의 부실한 점을 감추고 잘 된 부분만 보여주고 있다는 느낌이 든다. 내가 아직 논문을 써본 적이 없어서 그렇게 생각하는 것일 수도 있지. 배운 점, 계획 : 나는 게임의 흥행을 예측하는 연구를 해야 한다. 어떤 데이터를 수집하고, 어떻게 가공하는지 좋은 참고가 되었으며 시계열 데이터로 활용한다는 아이디어도 얻었다. 리뷰 텍스트를 감성분석하여 사용하는 것은 나도 고민해봐야겠다. 내가 항상 기억하고 의식해야 할 점은 난 학부생이지 석박사가 아니라는 점이다.. 감당할 수 있는 일을 하자. 텍스트 감성 분석은 아무래도 하나의 모델이 감성도 분석하고, 그 데이터를 또 스스로 예측 모델에까지 이용하게 만들기는 힘들 것 같으니 감성 분석 모델 따로, 예측 모델 따로 만들어야 할 것 같다. 감성 분석 데이터와 수치/범주형 데이터를 별도의 데이터프레임으로 사용하게 될테니 기준이 될 인덱스도 필요한데, 그건 게임 이름으로 하면 될까? 그렇게 되면 문제가 생기는데, 게임의 내재적/외재적 정보는 한 게임 당 한세트씩만 나온다. 그러나 리뷰는 한 게임 당 수백 수천개가 나올 수 있다. 이걸 게임 이름을 기준으로 매치시킨다? 과연 가능할까? 역시 추가 연구가 필요하다고 한 이유가 있는 거였다. 그러면 리뷰 전체의 감성을 평균내는 건 어떨까? 마침 스팀은 사용자도 볼 수 있게 리뷰의 추천과 비추천 비율을 계산해 ‘압도적으로 긍정적’, ‘긍정적’, ‘복합적’, ‘부정적’, ‘압도적으로 부정적(아직까지 한번도 못봤음)’ 등으로 나누어 표시해준다. 이게 각 리뷰의 감성을 온전히 반영하기는 어렵지만 대안으로 사용할 수는 있을 것 같다. 스팀 리뷰는 ‘추천’, ‘비추천’ 두 가지 선택만을 제공하지만 간혹 ‘비추천’이지만 이런 부분은 좋았다, 라든가 ‘추천’이지만 이건 별로였다 등 추천 여부와 실제 사용자의 감정이 온전히 일치하지 않는 경우가 있다. 실제로 나도 그런 리뷰를 쓴 적이 있다. 그러니 이 점을 이용해 ‘추천’, ‘비추천’과 ‘사용자가 긍정적으로 서술’, ‘사용자가 부정적으로 서술’ 이 두 가지 기준을 조건부확률처럼 조합해서 쓰는 건 어떨까? ‘추천-긍정서술’, ‘추천-부정서술’, ‘비추천-긍정서술’, ‘비추천-부정서술’ 이렇게 네 가지로 리뷰의 분류가 자세해진다. 여기에 중립까지 끼우면 종류가 더 많아지고 자세해질 수 있겠지만, 일단은 생각하지 않기로 하자. 내가 할 수 있는 일에는 한계가 있고 중립까지 고려하는 건 과한 것 같다. 이게 팀플이면 생각해볼만 하지만 개인 프로젝트거든요.. 혼자서 모든 일을 다 해야 한다는 점이 예산에 포함됩니다. 아까까지 리뷰의 감정을 총 네 가지로 나눴다. 그렇다고 해도 역시 하나의 게임에 수많은 리뷰 감정이 대응된다는 점은 여전하다. 나는 이걸 일대일 대응으로 만들고 싶다. 스팀에서 제공하는 ‘압도적으로 긍정적’ ~ ‘압도적으로 부정적’ 지표에 더해 ‘리뷰 감정’이라는 항목으로 내가 분류한 네 가지 상태를 추가하는 건 어떨까? 스팀에서 하는 방법대로 평균을 낸다든가 최빈값을 사용한다든가 해서 하나의 값을 고르는 것이다. 잠깐 스팀의 리뷰 지표 계산 기준을 알아보고 왔다. 리뷰의 추천/비추천 비율과 총 리뷰 수에 따라 출력되는 문구가 다르다고 한다. 이 기준을 비슷하게 따르면 될 것 같다. 정리하자면 스팀에서 제공하는 ‘긍정적’ 정도를 하나의 속성으로 데이터에 포함하고, 내가 따로 텍스트 감정분석을 해서 만들어낸 ‘추천-서술’ 지표를 스팀의 계산 방식대로 계산해 별개의 속성으로 추가한다는 계획이다. 실현할수만 있으면 참 괜찮겠네. 추가 의견 : 아까 지인과 게임의 흥행 요소에 대해 잠깐 말해봤는데, 영화도 물론 비슷하겠지만, 요즘 게임은 게임 자체에 더해 제작사와 배급사의 운영과 이미지도 큰 비중을 차지해서 게임의 외재적 정보에 이런 맥락까지 같이 포함할 방법을 고민해봐야 할 것 같다. 데이터셋 구성을 좀 많이 고민해봐야겠다. 게임의 이름은 각 게임의 식별을 위해 필요하고, 제작사/배급사도 당연히 같이 수집해야 한다. 그리고 게임은 영화와 다르게 출시 이후에도 업데이트가 되고 새로운 컨텐츠가 추가되는 등 지속적인 관찰을 필요로 하니까 최근 일정 기간 이내 업데이트 여부도 같이 수집하는 게 좋을 것 같다. 스팀 내에서 수집 가능한 정보 : 게임 이름, 제작사, 배급사, 이용 연령가, 장르, 태그, 영어 지원 여부, 지원 언어의 수, 출시 일자, 최근 공지 업데이트 일자(오늘로부터 얼마나 이전인지), 스팀에서 제공하는 최근 평가 긍정성과 모든 평가 긍정성, 리뷰 수, 스팀 어워드 수상 여부 및 수상 횟수, “지금 유행하는 게임” 체크 여부, 메타크리틱 점수, ‘앞서 해보기’ 여부, 권장 사양, 해당 게임을 평가한 큐레이터의 수, 싱글/멀티/컨트롤러 지원/스팀 클라우드 등 각종 지원 사항, 최근 1개월 내 커뮤니티 게시물 업데이트 수, 타사 EULA 동의 필요 여부, 시리즈/DLC 여부와 수, 리뷰에 나타나는 플레이타임으로부터 평균 플레이타임(가능할지 안될지 모름), 지원하는 운영체제 종류, 도전과제의 수, 전체 플레이어의 각 도전과제 달성 비율(→ 평균 도전과제 달성률) 스팀 외부에서 수집 가능한 정보 : 게임과 제작사 관련 뉴스 기사, ‘논란’ 키워드 여부, 관련 기사의 긍정/부정 여부, 스팀 이외 플랫폼 지원 여부 스팀 DB에서 수집 가능한 정보 : 각 게임의 국가별 최고 할인율, 실시간 플레이 중인 유저 수, 최근 24시간 내 최다 플레이 수, 최근 2년 이내 최다 플레이 수, 총 리뷰 수와 ‘추천’ 리뷰 비율, 최근 업데이트 일자(오늘로부터 얼마나 이전인지), 해당 게임을 팔로우한 사람 수, 최근 2주간 플레이타임 중간값, 총 플레이타임 중간값, 최근 2주간 평균 플레이타임, 총 평균 플레이타임, 추정 게임 소유자 수, 커뮤니티/워크샵 활성화 여부, 기본 장르(메인 장르), 스토어 장르(상점 페이지에 뜨는 장르), 지원 언어의 수와 목록, 리뷰 점수, 리뷰 비율, 스팀덱 호환성 추가 사항 : 스팀 DB API 사용 가능, 그러나 어떤 기능을 할 수 있는지 모름. 코드 봤는데 내가 잠깐 공부해서 써먹을 수 있을만한 물건은 아님. 아 좀 아득한데.. 너무 많은데.. 저걸 어떻게 내가 쓸 수 있는 만큼만 골라내..일단 예측하는 게 목적이니까 게임이 출시되자마자 알 수 있는 정보가 기본적으로 데이터셋에 포함되어야 하고, 그걸 바탕으로 게임이 플레이된 이후에 알 수 있는 정보를 예측해야 한다. 흥행 여부의 기준도 정해야 한다. 일단 다음 주 논문 하나 더 읽고 생각하자.참고 자료220614 참고 자료 Beautiful Soup Documentation 셀레늄 (소프트웨어) - 위키백과, 우리 모두의 백과사전. 웹 크롤러 - 위키백과, 우리 모두의 백과사전. 🖨 ‘웹 크롤러’ 좀 그만 만들어라 랜덤 포레스트 - 위키백과, 우리 모두의 백과사전. 앙상블 학습법 - 위키백과, 우리 모두의 백과사전. XGBoost - From Wikipedia, the free encyclopedia 220617 참고 자료 스팀 ‘압도적으로 긍정적’에 대해 알아보자" }, { "title": "[UROP] 3주 - 2. 특수 데이터 처리", "url": "/satinbower-legacy/posts/it-project-urop-3-2/", "categories": "IT, Machine Learning", "tags": "지식, IT, 프로젝트, 데이터, 머신러닝, 데이터 전처리", "date": "2022-06-10 00:00:00 +0900", "snippet": "* 노란 글씨 : 이해 잘 안 됨* 파란 글씨 : 이해 후 재서술원래 오늘 공부 주제가 ‘특수 데이터 처리하는 다양한 방법’인데, 특수 데이터라는 게 뭘 말하는 건지 잘 모르겠어서 우선 내가 아는 딥러닝에 사용하는 데이터들부터 살펴보기로 했다.데이터 유형에 따른 분류내가 다룰 수 있는 데이터와 다룰 수 있는지 여부에 상관 없이 존재를 아는 데이터의 목록을 써보자. 무슨 검색어를 써야 하는지도 감이 안 잡혀서 내가 아는 내용으로 썼다. 주로 csv 파일 형식으로 사용되는 수치/범주형 데이터 → 분류/회귀 서로 연관을 갖지 않는 실수/정수 값 : 예를 들어 어떤 광물의 함량, 무언가의 무게, 어떤 것의 개수 등 각각의 샘플이 가질 수 있는 값을 말한다. 모든 샘플이 각자의 값을 갖지만 서로 다른 샘플 사이에 상관 관계는 없다. 이 값이 출력 데이터로 사용된다면 회귀 문제가 된다. 입력 데이터로 사용될 경우 시도할 수 있는 처리는 정규화(Standardization, 데이터를 표준정규분포로 만듦), 표준화(Normalization, 값의 범위를 0~1로 만듦), 로그 취하기 등이 있다. 일정한 몇 가지 범주 내의 값을 가짐 : 샘플이 갖는 값이 객관식인 것을 말한다. 예를 들면 성별, 어떤 조건에 대한 해당 여부 등이 있다. 이 값이 출력 데이터로 사용된다면 분류 문제가 된다. 입력 데이터로 사용될 경우 시도할 수 있는 처리는 레이블 인코딩, 원 핫 인코딩 등이 있다. 일정한 순서가 존재하는 값 : 시계열 데이터라고 부르는 값들을 말한다. 주로 시간적 순서와 관계가 있다. 말 그대로 날짜나 시각 등을 말한다. 자연어라 부르는 텍스트도 순서가 있기 때문에 시계열 데이터에 포함되지만 일단 여기에는 포함하지 않았다. 입력 데이터로 사용될 경우 LSTM이라는 신경망 구조를 사용하고, 출력 데이터로 사용되는 경우는 아직 내가 해본 적이 없지만 이전 주차에서 공부한 내용 중 Cox 비례 회귀에서 시간이 종속 변수로 사용된다고 배웠다. (참고)시간과 시각 : 네이버 사전에 의하면 시간은 “하루의 24분의 1이 되는 동안을 세는 단위”, 시각은 “시간의 어느 한 시점” 또는 “짧은 시간”을 의미한다고 한다. 다시 말해 시작과 종료가 있는 기간의 의미라면 시간, 특정 지점을 지칭하는 의미라면 시각이라고 말하면 된다. 이미지/영상 데이터 → 분류, 생성 분류 : 이 이미지가 강아지인가 고양이인가? 같이 객관식 질문에 대답하는 문제를 말한다. 이미지 크기 조절, 증강 등을 시도할 수 있다. 생성 : 원본 이미지와 유사하지만 실제가 아닌 가짜 이미지 만들기(GAN), 원본 이미지의 특징을 드러내는 이미지 만들기(오토인코더), 원본 이미지와 결과 이미지의 짝을 학습해 임의의 이미지로부터 결과 이미지 만들기(pix2pix), 특정 부류의 이미지의 스타일을 학습해 다른 이미지를 해당 부류의 이미지처럼 조작하기(CycleGAN) 등 다양한 생성 모델이 있고, 다양한 것을 할 수 있다. 전처리는 모델의 종류에 따라 다르지만 보통은 이미지 크기 조절 외에는 잘 안 하는 것 같았다. 자연어 → 분류, 생성 분류 : 이 텍스트 슬퍼보이니 기뻐보이니 아니면 중립? 같이 객관식 질문에 대답하는 문제를 말한다. 주 사용 예시로 텍스트 감정 분석이 있다. 문장부호/특수기호 제거, 토큰화, 패딩 등을 할 수 있다. 생성 : 아직 직접 해본 적은 없다. 텍스트 번역, 감정 키워드 추출 등을 하는 것 같다. 전처리 과정은 비슷하리라 생각한다. 처리 과정에 따른 분류내가 찾아본 데이터 처리 과정은 다음과 같다. Data Cleaning : 결측값/불필요한 값 처리 불필요 데이터 처리 : 결측값 삭제/대체, 속성 삭제. 결측값은 평균값, 중간값, 앞뒤 샘플의 값, 최빈값 등으로 채울 수 있고 보간으로 채울 수도 있다. 속성은 결측값 비율이 너무 높아 채워도 손해이거나 전체 학습과 관련이 없다고 판단되는 것을 삭제한다. Handling Text and Categorical Attributes / Representation transformation : 숫자가 아닌 데이터 숫자로 바꾸기 데이터에 텍스트가 있거나 범주형 데이터일 때 이를 숫자로 바꿔준다. 서로 연관이 있거나 순서가 있다면 정수로만 바꿔도 되고, 그렇지 않다면 원 핫 인코딩을 권장한다. 원 핫 인코딩의 필요성은 다른 주차에서 이미 공부했다. 텍스트(자연어)는 토큰화, 임베딩 등을 한다. Custom Transformers : 데이터에 특정 알고리즘 적용해 변환하기 예를 들어 주택의 평수와 거주민의 수가 있을 때 각 주택에서 평당 거주민의 수를 계산하는 것. Feature Scaling / Feature tuning : 데이터의 범위 또는 분포를 특정 형태로 바꾸거나 제한하기 정규화(Standardization) : 정규 분포를 따르는 데이터를 표준정규분포로 만든다. 각 값에서 평균 빼고 분산으로 나누기. 최대-최소 정규화 : 데이터의 분포가 정규 분포를 따르지 않아도 사용할 수 있다. 각 값에서 최솟값을 빼고 최댓값과 최솟값의 차로 나누기. 이 방법을 응용해 데이터를 특정 범위 이내의 값으로 제한할 수 있다. 로그 취하기 : 각 값에 로그를 취한다. 값의 분포가 상당히 치우쳤거나, 단위가 너무 클 때 사용할 수 있다. 첨도나 왜도가 너무 클 때 이를 개선하는 효과가 있다. Instance selection &amp; partitioning : 학습셋, 테스트셋 분리 기본적으로는 학습용, 중간 테스트용, 성능 평가용 데이터를 분리하는 것을 말한다. 단순히 분할만 할 수도 있지만 데이터의 분포 비율에 맞춰서 샘플링할 수도 있다. 이것을 stratified partitioning이라고 한다, 라고 원문에 적혀있었다. 특정 데이터가 너무 적을 때 오버샘플링을 하는 과정도 포함된다. Feature extraction : 전체 속성의 수를 줄이거나 해시값으로 변환하여 더 효율적인 속성을 사용 차원 감소 기법을 사용한다고 하는데, 이해하지는 못했다. 오늘 전공 시험만 5시간 정도 보고 나서 + 아파서 낮잠까지 자고 나서 남은 기력으로 공부하는 거라 아주 새로운 걸 배우기는 힘들다(변명 맞음). ‘차원 감소’라고 하니 임베딩도 이 기법의 일종이지 않을까 싶긴 한데, 내가 개념을 이해하지 못해서 그냥 혹시나 하고 추측만 할 뿐이지 더 생각은 못하겠다. 요점은 데이터를 변환하거나 압축해서 더 작은 사이즈로, 더 효율적으로 사용할 수 있도록 만드는 게 목적인 것 같다. Feature selection : 여러 가지 속성 중 사용할 속성 고르기 말 그대로 딥러닝 모델에게 제공할 속성을 고른다. 기준은 여러 가지 있을 수 있지만 나는 주로 상관 관계 값을 본다. 판다스의 데이터프레임이 제공하는 상관 관계 값은 절댓값이 작을 수록 관계성이 낮음을 나타낸다. 이를 이용해 예측해야 할 결과 값과 별로 상관없는 속성을 골라 삭제한다. Feature construction : 기존 속성을 기반으로 여러 가지 기법을 이용해 새로운 속성 만들기 원문에서는 “기존의 피처를 기반으로 polynomial expansion 이나, feature crossing 등의 기법을 이용하여 새로운 피처를 만들어낸다.” 라고 하는데, 모르는 단어가 둘이나 있고 그게 문장에서 가장 중요한 말이라 이해를 못했다. 내일 또 스터디 있는데 그때 복습하겠습니다.. Transformation Pipelines : 데이터 전처리 과정 자동화 위의 과정들을 특정 라이브러리를 이용해 하나의 객체로 선언한다거나 하는 방법으로 데이터마다 일일이 같은 과정을 반복하지 않게 해줌. 참고 자료[1] 머신러닝 (3) - 데이터 전처리, https://davinci-ai.tistory.com/15[2] [GCP] 머신러닝 파이프라인에서 데이터 변환, https://medium.com/google-cloud-apac/gcp-머신러닝-파이프라인에서-데이터-변환-da834f3dff48" }, { "title": "[UROP] 3주 - 1. 복습, 데이터 결측치와 원 핫 인코딩", "url": "/satinbower-legacy/posts/it-project-urop-3-1/", "categories": "IT, Machine Learning", "tags": "프로젝트, 지식, IT, 결측치, 원핫인코딩", "date": "2022-06-06 00:00:00 +0900", "snippet": "* 노란 글씨 : 이해 잘 안 됨* 파란 글씨 : 이해 후 재서술1, 2주 복습 DNN은 대부분 딥러닝 모델의 밑바탕이 되는 기본적인 구조이다. CNN은 컨볼루션과 풀링이 사용되는 신경망이고, 정보 추출, 문장 분류, 이미지 처리에 잘 쓰인다. 활성화 함수는 직선밖에 모르는 DNN이 제대로 기능할 수 있도록 직선이 아닌 것을 직선처럼 보이게 만들어 준다. 편향은 모델이 예측하는 값이 정답으로부터 얼마나 떨어져있는지 나타낸다. 분산은 모델이 예측하는 값이 얼마나 퍼져있는지 나타낸다. 예측과 정답이 가까울수록 편향이 낮고, 예측이 일정할수록 분산이 낮다. 편향과 분산은 ‘모델이 복잡한 정도’와 관련이 있다. 모델을 적절히 학습시켜 학습 데이터에 지나치게 딱 맞게 되지 않도록 하는 게 좋다. Regularization(정규화, 규제) : 모델이 가질 수 있는 분산에 제약을 부여한다. 과하면 편향이 증가할 수 있으니 적당히 해야 한다. 과적합을 줄일 수 있다. 내가 사용하는 모델은 대부분 mini-batch 방식. 배치 정규화는 모델의 가중치가 특정 방향으로 몰리지 않도록 하기 위한 가중치 바로세우기. optimizer는 모델이 지역최솟값에 빠지지 않게 도와준다지만 어떻게 적당한 optimizer를 고르는지는 모르겠다. hyperparameter : 내가 모델에게 정해주는 파라미터 값. 학습이 불가능하며 경험적으로 적당한 값을 찾아야 한다. CNN은 이미지를 처리할 때 이미지의 공간적 정보를 유지하면서 학습할 수 있다. 그것이 DNN과의 차이. 활성화 함수는 다음 층으로 넘길 신호의 세기를 정한다. 중요한 값은 세게, 그렇지 않은 값은 약하게. 선형 회귀 : 어떤 변수의 값을 기반으로 다른 변수의 값을 예측한다. 선형 방정식을 이용하며 지도학습이다. 단순 선형 회귀, 다중 선형 회귀, 로지스틱 회귀, Cox 비례 회귀 등이 있다. 산점도를 그리면 변수들 사이의 상관 관계를 눈으로 확인할 수 있다. tf.newaxis : 필요한 곳에 한 차원 추가 나는 아직 내가 많은 요소를 직접 만들고 지정해야 하는 모델을 다루기는 힘들다. 코드를 이해하려 하는 건 좋지만 그걸 써먹을 수 없겠다는 생각이 들면 곤란하다. 앞으로는 쓸 수 있는 코드를 보자. 콜백을 직접 만들어 본 건 괜찮은 경험이었다. 그래도 API 쓰는 게 훨씬 성능이 좋다. custom metric을 만들 수 있다. r2 score를 metric으로 사용하고 싶었다. 선형 회귀는 주기함수 형태를 띄는 데이터에는 잘 적응하지 못한다고 한다. 나중에 실험해볼 여지가 있다.데이터 결측치 처리 방법 삭제하기 대충 채우기삭제하기결측치가 많지 않고, 전체적인 경향을 훼손하지 않을 만하다면 결측치가 포함된 행이나 열을 삭제하는 게 낫다. 특정 샘플에 결측치가 많으면 행을 삭제하고 특정 속성에 결측치가 많으면 열을 삭제한다. 행 삭제, 열 삭제 모든 속성이 결측치인 샘플만 삭제 결측치가 n개 이상인 샘플만 삭제(thresh) 특정 열에 결측치가 있는 샘플만 삭제(다른 열에는 결측치 있든 말든)채우기평균, 중앙값 등의 통계치로 채울 수 있고, 결측치에 경향이 있을 경우(결측치가 랜덤으로 빠진 게 아닐 경우), 결측치를 채우기 위해 학습할 수 있다. 기계학습, 데이터 마이닝 등 다양한 방법이 있다고 함. 범주형 변수와 그렇지 않은 것을 구분하여 채워야 한다. 단일 값으로 지정하여 채우기 결측치 전후 값으로 채우기 특정 값으로 대체하기(replace) : 결측치가 아닌 경우에도 사용 가능 interpolate : 결측치를 선형으로 채움. 데이터와 데이터 사이의 빈 공간에 직선을 긋는다고 생각하면 됨. 다차원 함수 형태로도 가능하다고 함. k-최근접 이웃 알고리즘 이용한 사이킷런의 KNN Imputer로 채우기. 다양한 Imputer가 있다고 한다.참고 : 6.4. Imputation of missing values, Imputing missing values before building an estimator, sklearn.impute.SimpleImputer, [파이썬] 머신러닝 결측치/결측값 처리 : 싸이킷런 KNN Imputer로 KNN 알고리즘으로 결측값 채우기/대체/보간하기결측치 유형 값에 따른 분류 None/null : 진짜로 값이 없음. → 모든 자료형 NaN : 뭔가 있긴 있는데 해당 시스템이 지원하는 타입의 숫자가 아님. → int, float 자료형 NA : 유효하지 않음. → object 자료형 결측 유형에 따른 분류 완전 무작위 결측 : 결측치가 결측치인 이유가 없음. 입력할 때 실수했거나 오류가 났을 뿐임. 무작위 결측 : 다른 속성의 값에 따라 결측치가 정해질 수 있음(maybe) == 다른 속성의 값에 따라 결측치 발생 확률이 계산되긴 하는데, 값 자체의 상관관계는 알 수 없음. 비무작위 결측 : 어떠한 무작위 결측도 아님. 결측치가 발생한 값이 다른 값과 연관이 있음(certainly). 원 핫 인코딩이건.. 그냥 내가 전에 썼던 블로그 글 그대로 가져오겠다. 이것까지 새로 찾아볼 기운이 안 나거든요.(사유 : 컨디션 문제)* 아래 글은 클래스의 원 핫 인코딩에 대해서만 설명하고 있는데, 클래스가 아니라 속성에 원 핫 인코딩을 할 수도 있다. 이 또한 범주형 값일 때 가능하며 pandas.get_dummies()를 사용할 수 있다. 원 핫 인코딩, 원 핫 벡터 : 다른 건 보지 마 이게 정답이야 이것만 봐 좀 원 핫 인코딩은 예측해야 할 클래스가 선형 회귀가 아니고, 여러 개일 때 사용할 수 있는 방법이다. 예를 들어 0번부터 3번까지 클래스가 3개 있다고 하자. 프로그래머는 딥러닝 모델에게 이 클래스를 그대로 [0, 1, 2, 3]라고 전달할 수 있다. 그러나 보통은 원 핫 인코딩을 거쳐 [ [1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1] ] 이런 형태로 전달한다. 이렇게 정답 클래스의 인덱스만 1로 표시하고 나머지는 0으로 표시하는 것이 원 핫 인코딩이다. 그리고 원 핫 인코딩을 한 클래스 각각을 원 핫 벡터라고 한다. 원 핫 벡터의 길이 : 누가 여기서 가장 크냐? 방금 예시에서는 클래스가 0부터 3까지 있었다. 그럼 만약 클래스가 1과 3만 있는 데이터를 원 핫 인코딩 한다면 어떻게 될까? 사람 기준에서는 어차피 둘 중 하나이니 [ [1, 0], [0, 1] ] 이렇게만 만들면 될 것 같지만 실제로 원 핫 인코딩을 해보면 위의 예시와 똑같은 결과가 나온다. 이유는 원 핫 인코딩이 표시하는 것이 클래스의 상대적 순서가 아니라, 인덱스 자체이기 때문이다. 파이썬의 인덱스는 0부터 시작하니, 정수로 표시된 클래스들 중 가장 큰 수를 받은 클래스의 숫자 + 1이 원 핫 벡터의 길이가 되고, 동시에 그것이 출력층의 노드 개수가 된다(클래스의 인덱스를 음수로 주는 경우는 본 적이 없다). 이는 자연어 처리에서도 똑같이 적용된다만, 지금 정리할 개념은 아니니 언급만 해둔다. 원 핫 인코딩 왜 함? 원 핫 벡터에 사용되는 숫자와 클래스에 매겨지는 인덱스에 사용되는 숫자를 생각해 보자. 클래스 인덱스는 10진수로 매겨진다. 원 핫 벡터는 0과 1만 사용하니 2진수라고 할 수 있겠다. 10진수와 2진수의 차이가 뭘까? 10진수는 산수가 되고 2진수는 안 된다는 점이다. 10진수인 1과 2를 더하면 3이 되지만 원 핫 벡터는 모든 값을 0과 1로만 표시하면서 그런 계산을 불가능하게 만들었다. 이 부분이 원 핫 인코딩의 장점이자 단점이다. 사람은 데이터의 의미를 이해할 수 있으니 1번 클래스와 2번 클래스를 더하는 것과 3번 클래스는 무관하다는 사실을 인지할 수 있다. 하지만 모델은 그런 생각을 할 수 없다. 그렇기 때문에 클래스의 인덱스를 10진수로 주면 1 + 2 = 3이니까 1번 클래스와 2번 클래스를 더하면 3번 클래스와 같을 거라는 잘못된 학습을 할 수도 있다. 원 핫 인코딩은 이 문제를 방지한다. 이것이 장점이다. 반면 실제로 1번 클래스와 2번 클래스의 합이 3번 클래스와 관계가 있는 데이터도 있을 수 있다. 예를 들면 자연어 처리가 그러하다. 하나의 문장 내에서 각각의 단어는 무관하지 않다. “오늘 날씨”와 “내일 날씨”는 같은 “날씨”를 요구한다고 해도 다르게 해석되어야 한다. 원 핫 인코딩은 이런 관계성을 차단하여 클래스 사이의 유사성도 나타내지 못하게 된다는 것이 단점이다. 참고 자료 [데이터분석] 결측치/결측값(missing value) 처리를 위한 2가지 방법 [파이썬] 판다스(pandas) 팁14. 결측치/결측값 처리 : 제거하기/삭제하기(Deletion) [파이썬] 판다스(pandas) 팁19. 결측치/결측값 처리 : 채우기/보간하기/대체하기(Imputation) [데이터시각화] 파이썬 : 결측치/결측값(missing value) 시각화하는 5가지 방법 결측치(Missing Value) 처리" }, { "title": "[UROP] 2주 - 2. 다양한 regression", "url": "/satinbower-legacy/posts/it-project-urop-2-2/", "categories": "IT, Machine Learning", "tags": "프로젝트, 지식, IT, 회귀, regression", "date": "2022-06-02 00:00:00 +0900", "snippet": "* 노란 글씨 : 이해 잘 안 됨* 파란 글씨 : 이해 후 재서술분류 단순 선형 회귀 다중 선형 회귀 로지스틱 회귀 Cox 비례 회귀단순 선형 회귀독립 변수가 1개인 선형 회귀, 2차원 좌표 평면에 나타낼 수 있음. 독립 변수에 대한 함수(비수직 직선)로 가능한 정확하게 종속 변수를 예측함. 각 예측의 정확도는 오차의 제곱으로 측정한다. 오차의 제곱 값이 가능한 한 작도록 만드는 것이 목표이다. 현실의 사건들은 단 한 가지 요소만으로 결정되지 않기 때문에 잘 쓰이지는 않는다고 함.단순 선형 회귀는 몇 가지 가정을 전제로 한다.(원문과 표현의 차이가 있을 수 있음) 독립 변수 x는 상수로 간주한다 : x가 변하는 것까지 예측하기엔 너무 복잡하고 할 일이 많다. 오차항의 기댓값은 0이고, y의 조건부기댓값은 오차항을 제외한 부분과 같다 : 내가 이 말 때문에 원문에 있던 식까지 다 같이 보려고 했는데, 개념이 이어지면 이어질수록 통계학이 돼서 중간에 접었다.. 이해한 만큼만 말하자면 오차의 총합은 0이고, 기댓값도 0이기 때문에 y의 조건부기댓값에서 오차가 빠진다는 것 같다. 어차피 0이니까 계산에 의미가 없다는 말. 그리고 조건부기댓값이라 부르는 이유는 상수가 아닌 x를 상수로 간주했기 때문이라고 한다. 오차항의 분산은 σ^2이다 : 오차항의 분산이 상수로 정해져 있다고 한다. 그렇기 때문에 x에 대한 y 값이 퍼진 정도가 모든 구간에서 동일하고, 이 성질을 등분산성이라고 한다. 만약 그렇지 않다면 그것은 이분산성이라고 한다. 서로 다른 오차에 대해 공분산은 0이다 : 서로 다른 오차 사이에는 어떠한 상관관계도 존재하지 않아야 한다. 오차 사이에 관계가 있는 경우도 있다. 예를 들어 시계열 데이터. 이런 경우에는 오차의 패턴도 같이 고려해야 한다.열심히 따라 적긴 했는데 내가 공부했어야 할 방향과는 좀 다른 것 같다. 아까우니까 지우지는 않고 남기겠습니다..다중 선형 회귀단순 선형 회귀와 비슷하지만 한 가지 다른 점이 있다. 독립 변수를 여러 개 갖는다. 종속 변수는 그대로 1개이다. 좌표 공간에 나타내면 평면이 된다. 다중 선형 회귀는 약간의 전제가 필요하다. 서로 다른 독립 변수끼리는 독립적이어야 한다. 독립 변수와 종속 변수 사이의 관계를 찾는 것이 목적이기 때문에 독립 변수 사이에 관계가 존재할 경우 관계를 분석하기 어렵다고 한다. 그리고 오차가 정규분포를 이루어야 한다고 한다. 독립 변수와 종속 변수 사이에 관계가 있는지는 산점도를 보면 알 수 있다.로지스틱 회귀위키백과는 로지스틱 회귀를 “영국의 통계학자인 D. R. Cox가 1958년에 제안한 확률 모델로서 독립 변수의 선형 결합을 이용하여 사건의 발생 가능성을 예측하는데 사용되는 통계 기법”이라고 정의하고 있다. Cox라는 이름이 눈에 띈다. 이 주제 다음에 쓸 내용이 Cox 비례 회귀인데 이 사람이 그 사람인 것 같다.정의를 좀 자세히 보자. “독립 변수의 선형 결합”이 뭘까? 위키백과를 좀 더 읽어보니 다른 선형 회귀와 마찬가지로 독립 변수들이 갖는 선형의 경향을 말하는 것 같다. 그 다음은 “사건의 발생 가능성”이다. 앞부분만 봤을 때는 다른 회귀와 뭐가 다른가 싶었는데 그 차이가 여기 있었다. 가능성이라 함은 확률을 말하는 것일 테고, 확률은 0과 1 사이의 값만을 갖는다. 출력 범위가 제한된 회귀라는 말이다.로지스틱 회귀는 선형 회귀 분석과는 다르게 종속 변수가 범주형 데이터를 대상으로 하며 입력 데이터가 주어졌을 때 해당 데이터의 결과가 특정 분류로 나뉘기 때문에 일종의 분류 (classification) 기법으로도 볼 수 있다고 한다. 그럼 타이타닉 문제도 로지스틱 회귀로 풀 수 있겠네.보통 말하는 로지스틱 회귀는 종속 변수가 둘 중 하나의 값만을 갖는 유형이지만 종속 변수의 범주에 따라 다항, 분화, 서수 로지스틱 회귀도 있다고 한다. 이항형 로지스틱 회귀는 종속 변수가 단 두 가지 범주만을 갖고, 각 범주는 0과 1로 표시되며 두 범주에 대한 결과 값의 합은 1이 된다고 한다.로지스틱 회귀와 앞서 정리한 선형 회귀의 차이는 두 가지가 있다. 첫 번째는 종속 변수의 범위가 0 이상 1 이하로 제한된다는 것이고, 두 번째는 조건부확률 P(y | x)의 분포가 정규분포가 아닌 이항분포가 된다는 점이다. 종속 변수가 이진적이기 때문이라고 한다. 이 차이점에 해당하는 경우에 대해 로지스틱 회귀가 아닌 선형 회귀를 적용하면 결과 값의 범위가 y의 범위를 벗어나기 때문에 정확도가 떨어진다고 한다.다른 로지스틱 회귀를 다 공부하기엔 내가 오늘 과제가 있어서 시간이 좀 부족할 것 같고, 내가 하려는 프로젝트는 다항 로지스틱 회귀와 관련이 있을 것 같아서 다항 로지스틱 회귀에 대해서만 추가로 찾아봤다. 다항 로지스틱 회귀는 종속변수가 두 개의 범주로 제한되지 않으므로 로지스틱 회귀분석보다 일반적으로 사용할 수 있다고 한다. 예를 들면 관객이 좋아할만한 영화의 종류를 예측하는 데에 쓸 수 있다.다항 로지스틱 회귀를 하기 위한 고려사항이 있다. 종속변수는 범주형이어야 하고, 독립변수는 요인 또는 공분산 변수여야 한다. 요인과 공분산 변수가 뭔지는 통계학을 알아야 하는 것 같다.. 어쨌든 x는 어떠한 분포가 있는 값이어야 하고 y는 몇 가지 선택지로 나뉠 수 있어야 한다는 말로 이해해야겠다. 그리고 독립 변수의 범주끼리는 독립적이어야 한다고 하더라.Cox 비례 회귀이것은 생존 분석의 한 종류라고 한다. 생존 분석이란 사망이나 질병 같은 사건이 발생하기까지 걸리는 시간을 분석하는 분석 기법이다. Cox 회귀 분석의 종속 변수가 사건이 발생하기까지 걸리는 시간이다. 이 분석을 통해 생존율에 영향을 미치는 위험 인자를 알아낸다. 예를 들어 폐암 발병 시기에 성별과 흡연량이 미치는 영향 등을 연구할 수 있다고 한다. 오늘 정리한 회귀 방법 중 가장 생소한 내용이라 찾아본 자료들은 거의 이해하지 못했다.참고 자료 회귀 분석(Regression analysis) Simple linear regression - From Wikipedia, the free encyclopedia [회귀분석] 단순선형회귀분석(Simple Linear Regression) 개념 [머신러닝] 다중 선형 회귀(Multiple Linear Regression) Multiple Linear Regression (MLR) Definition 로지스틱 회귀 - 위키백과, 우리 모두의 백과사전. 다항 로지스틱 회귀분석 - IBM Documentation [R 통계분석] 13. 콕스 회귀분석, 콕스 비례-위험 모형(Cox Regression analysis, Cox Proportional-Hazard Model) Cox 회귀분석 분석 - IBM Documentation" }, { "title": "[UROP] 2주 - 1. Linear Regression 스터디", "url": "/satinbower-legacy/posts/it-project-urop-2-1/", "categories": "IT, Machine Learning", "tags": "프로젝트, 지식, IT, 선형회귀, 딥러닝, 과학", "date": "2022-05-30 00:00:00 +0900", "snippet": "* 노란 글씨 : 이해 잘 안 됨* 파란 글씨 : 이해 후 재서술* 보라 글씨 : 더 공부할 게 있음** 내가 자꾸 내 수준을 모르고 어려운 것만 찾는 것 같아서 이번엔 좀 초심 같은 느낌으로 아는 내용을 한 번 더 보는 것에 신경써봤다.선형 회귀어떤 변수의 값을 기반으로 다른 변수의 값을 예측하는 데 사용한다. 예측하고자 하는 변수를 종속 변수(y), 그 변수를 예측하는 데 사용하는 변수를 독립 변수(x)라고 한다. 선형 방정식(직선 또는 평면)을 이용해 독립 변수와 종속 변수 사이의 관계를 표현한다. 물론 당연히 두 가지 변수 사이에 선형의 관계가 존재해야 한다. 사전에 수집한 종속 변수(y) 데이터가 ‘정답’이 되므로 지도 학습에 속한다. 독립 변수가 한 개이면 단순 선형 회귀, 여러 개이면 다중 선형 회귀이다.선형 회귀로 알아내는 방정식은 가설(Hypothesis)이라고 부른다. 실제로 종속 변수의 값에 영향을 미치는 것은 사람이 임의로 정한 독립 변수 이외에도 수많은 무관해보이는 요소들이 있을 수 있기 때문에 “진짜” 회귀선을 찾을 수 없어서 가설이라 부른다고 한다. 간단히 함수 h라고 한다.손실 함수(오차 함수)가장 적당한 h 함수를 찾기 위한 기준의 역할을 하는 게 오차 함수이다. 기본적으로 원래 정답인 값과 예측한 정답의 차이를 오차로 보는데, 이 오차는 양수일수도 있고 음수일수도 있으니 제곱하거나 절댓값으로 사용한다. 오차를 제곱하여 최소화하는 오차 함수가 LSE, MSE 등이고, 절대값을 사용하는 게 MAE이다.선형 회귀는 어떤 상황에 적절한가 변수가 연속적인 경우 : 시간, 체중, 가격, 시험 점수 등 산점도를 사용하여 두 변수 사이에 관계가 있는지 알아보기 관찰은 독립적이어야 한다 : 어떤 한 변수를 관찰했을 때 다른 변수가 자동으로 정해지는 관계가 아니어야 한다. 데이터에 중요한 이상치(outlier)가 없어야 한다 : 이 말은 잘 모르겠다. 아웃라이어는 데이터 전처리로 골라낼 수 없는 건가? 등분산성 확인 : 최적 선형 회귀선을 따른 분산이 해당 선 전체에 걸쳐 유사하게 유지되는 통계적 개념이다. → 일단 등분산성이란 “모든 확률 변수가 같은 유한 분산을 가지는 성질을 가정한다. 등분산성은 분산분석(ANOVA)을 통해 서로 다른 두개 이상의 집단을 비교하고자 할때, 기본적으로 해당 집단들이 만족해야되는 조건 중 한가지로 분산이 같음을 의미하게 된다.(출처 위키백과)”라고 하는데, 무슨 말인지는 내가 통계 지식이 없어서 모르겠다. 어쨌든 독립 변수와 종속 변수 사이에 일정한 경향이 있어야 한다는 말이지? 최적 회귀선의 잔차(오차)는 정규 분포를 따른다 : 무슨 말인지는 대충 알겠는데 진짜 그렇게 돼? 난 그게 더 궁금해. 오차가 정규 분포로 나와 진짜로? 신기해라선형 회귀 사용 예 동향 및 매출 추정치 평가 가격 탄력성 분석 보험 회사 위험 평가 스포츠 분석참고 자료 Linear regression Univariate Linear Regression 등분산성 - 위키백과, 우리 모두의 백과사전." }, { "title": "[UROP] 1주 - 2. CNN 스터디", "url": "/satinbower-legacy/posts/it-project-urop-1-2-cnn/", "categories": "IT, Machine Learning", "tags": "프로젝트, 지식, IT, CNN, 딥러닝, 과학", "date": "2022-05-26 00:00:00 +0900", "snippet": " 노란 글씨 : 이해 잘 안 됨 파란 글씨 : 이해 후 재서술 보라색 글씨 : 더 찾아볼만한 개념개요\tCNN, Convolutional Neural Networks : 딥러닝에서 주로 이미지나 영상 데이터를 처리할 때 쓰이며, Convolution이라는 전처리 작업이 들어가는 Neural Network 모델.\t왜 CNN을 사용할까? - DNN에 문제가 있었기 때문\t\tDNN은 1차원 데이터만을 사용할 수 있다. 그러니 2차원 데이터를 DNN에 입력하려면 1차원으로 뭉개야 하고 그것으로 원본 데이터의 공간적, 지역적 정보가 손실된다. 그리고 추상화(abstractions, 다량의 데이터나 복잡한 자료들 속에서 핵심적인 내용 또는 기능을 요약하는 작업) 과정 없이 바로 연산하기 때문에 비효율적이다.\t\tCNN은 2차원 데이터를 그대로 사용할 수 있다. 원본 데이터의 공간적, 지역적 정보를 보존한 채로 그 이미지의 특성을 층층이 쌓아간다. CNN은 전체보다는 부분, 그리고 부분에서도 각 픽셀 사이의 연관성을 알아낸다.\t\t어떤 이미지로부터 필요한 정보를 알아낼 때(예: 이 사진이 새의 사진인가?), 반드시 이미지의 전체가 필요하지는 않다. 특징적인 일부분만 있으면 된다(예: 새의 부리). CNN이 이 특징 부분을 잘라주는 역할을 한다. 또한 특징 부분은 언제나 같은 위치에 있지는 않기 때문에 이미지의 부분부분을 잘 확인하는 게 전체를 보는 것보다 효율적이다.원리\t사전 개념 : 2차원 이미지는 픽셀 단위로 구성되어 있다. 가로 w, 세로 h인 이미지는 (w, h) 크기의 행렬로 나타낸다. 이 행렬을 CNN의 입력값으로 사용한다.\t커널 : 이미지의 특징을 걸러내기 위한 필터. 입력 이미지와 마찬가지로 (n, m) 크기의 행렬이다. 이것으로 이미지를 창문 닦듯이 훑어가며 행렬 간의 내적 연산을 한다.\t행렬 내적 : 같은 크기의 두 행렬을 놓고, 서로 같은 위치에 있는 요소끼리 곱해 모든 값을 더한다.\t커널이 지나가고 나면 : 보통은 입력 이미지보다 작고 (1, 1)보다는 큰 커널을 사용할 테고, 그렇게 되면 커널이 지나간 후 나오는 결과 이미지는 원본보다 작아지는 것이 당연하다. (1, 1) 크기의 커널을 사용하면 이미지의 크기는 줄어들지 않을 테지만 특징을 추출하는 효과도 없다!\t패딩 : 커널은 쓰고 싶지만 이미지의 크기는 줄이고 싶지 않을 수 있다. 그럴 때 사용하는 것이 패딩. 이미지의 주변에 0으로 채워진 테두리를 둘러 크기를 키워, 커널이 지나간 후 이미지가 줄어들어서 원래 크기가 되게 만든다.\tstride : 커널을 꼭 한 칸씩만 움직여야 한다는 법은 없다. 원한다면 두 칸 세 칸씩 움직여도 된다! 그 값을 지정하는 것이 stride. 이 값이 클수록 결과 이미지는 작아진다.\torder-3 tensor : 컬러 이미지는 R, G, B 세 가지 값으로 색이 나뉘기 때문에 3차원 행렬이 된다. 이런 모양을 order-3 tensor라고 부르는데 연산 방법은 2차원 행렬과 똑같다. 그러므로 결과 이미지는 마찬가지로 2차원 행렬이 된다.구조CNN은 모든 층과 노드가 연결되어 있던 DNN과는 구조가 좀 다르다. 근데 이 설명은 말로만 하면 어렵다. 자세한 설명은 아래 참고자료에서 찾자.\t컨볼루션 층 : 이 층에서는 앞서 설명한 커널을 이용한다. 커널은 한 번에 여러 개 사용할 수 있다. 한 층에 커널이 3개 있다면 결과 이미지도 3개, 5개 있다면 결과도 5개 나온다. 이 결과에 활성화 함수를 적용해 다음 층으로 값을 넘긴다.\t\t\t\t\t활성화 함수 : 요약하자면 선형 함수(linear function)인 컨볼루션에 비선형성(nonlinearity)을 추가하기 위해 사용한다고 한다. 내가 이해한 대로 다시 설명해보자. 우선 선형이라 함은 직선을 이른다. 수학에서 직선은 일차방정식이고, 일차방정식은 미분하면 상수가 된다. 오차 역전파는 미분이 기본인데 미분한 값이 상수가 되어버리면 입력값(x)과 출력값(y)의 관계성이 전혀 없으니 역전파의 의미가 없어진다. 참고한 글을 인용하자면 “입력 뉴런의 어떤 가중치가 더 나은 예측을 제공할 수 있는지 이해하는 것은 불가능합니다”라고 한다. 또한 이런 직선의 층이 이어져봐야 아무리 층이 많아도 결과적으로는 첫 번째 층의 선형 함수가 될 뿐이다. 그러니 (1) 오차 역전파를 수행하고, (2) 은닉층을 단순하게 만들지 않기 위해 비선형 활성화 함수가 필요하다.\t\t\t\t활성화 함수는 그럼 무슨 역할을 하나? 해당 층에서 계산한 값을 다음 층으로 넘길지 말지, 또는 어떤 값으로 바꾸어서 넘길지 정한다. 은닉층에 있는 각 노드의 on/off 스위치이다. 이 함수가 비선형 함수이면 위의 두 가지 문제가 해결된다. 미분해도 입력과 출력의 관계성이 사라지지 않기 때문에 역전파가 가능하고, 여러 개의 은닉층을 “쌓을 수 있다”고 한다(← 출력이 여러 레이어를 통과하는 입력의 비선형 조합이 되므로 뉴런의 여러 레이어를 쌓을 수 있다). 자료를 좀 더 찾아봤는데, 활성화 함수는 다음 층으로 넘길 신호의 세기를 결정한다고 한다. 중요한 신호는 세게, 그렇지 않은 신호는 약하게.\t\t풀링 층 : 풀링의 개념에 대해서는 지난 스터디에서 살펴본 바 있지만 다시 공부하자.\t\t\t\t\t풀링 : 풀링은 이전 층인 컨볼루션 층에서 나온 결과 이미지의 크기를 줄이는 것이 목적이다. 이때 줄인다는 그 “크기”는 컨볼루션의 결과로 나온 이미지의 개수가 아니라 행렬의 가로 세로 크기이다. 내가 참고한 글에서는 상관관계가 낮은 부분을 지워서 이미지의 크기를 줄인다고 했다. 풀링은 대표적으로 최댓값 풀링과 평균값 풀링이 있다. 풀 사이즈(이미지를 얼마나 줄일지에 따라 다름)에 따라 나눠진 구역 안에서 최댓값만을 남기는지, 평균값을 남기는지의 차이이다.\t\t\t\t필요한 만큼 컨볼루션+풀링 반복 : 과정을 거듭할수록 작고 두꺼운 데이터가 만들어진다. 행렬의 크기가 작고, 그 행렬들이 여러 개 겹쳐서 두꺼운 데이터라는 말이다.\tFlatten : 지금까지 만든 작고 두꺼운 이미지 데이터를 쭉 펼쳐 1차원 데이터로 만든다. 원본 이미지를 뭉개는 것과의 차이는, 원본 이미지는 아무 연산도 하지 않은 진짜 이미지 데이터였기 때문에 그걸 1차원으로 뭉개면 그나마 있던 특징도 다 흩어지지만, 컨볼루션 이후의 데이터는 이미지의 특징만을 모아놓은 데이터이기 때문에 형태를 바꾸어도 특징이 유지된다는 점이다. 그래서 1차원으로 바꿔도 된다.\tDense 층과 softmax : 결과 출력을 위한 층이다. Dense 층은 하나 이상 쓰면 된다.파라미터(Parameter)와 하이퍼파라미터(Hyper-parameter)\t지난 스터디 복기 : 파라미터는 모델 내부에서 알아서 학습하고 설정하는 값, 내가 건드릴 수 없음. 하이퍼파라미터는 내가 사전에 정해줘야 하는 값, 모델이 건드릴 수 없으니 다른 알고리즘을 이용하거나 경험적으로 적당히 골라야 함.\t학습 가능한 파라미터의 수\t\t\t\t\t컨볼루션 : 커널 크기 × 커널 개수 (× 사용한 텐서 개수)\t\t\t풀링 : 크기만 줄이기 때문에 파라미터 없음\t\t\tDense : 이전 층의 데이터 크기에 비례함\t\t\t결론 : 매우 많다.\t\t\t\t하이퍼파라미터\t\t\t\t\t컨볼루션 층 : 필터 개수와 크기, stride 값, 패딩 여부\t\t\t풀링 : 풀링 방식 선택, 풀 크기, Pool stride 값(overlapping)\t\t\tDense : 너비\t\t\t활성함수 : ReLU, softmax, 시그모이드 등\t\t\t오차함수 : 교차 엔트로피 계열, L1, L2\t\t\toptimizer : SGD, AdaGrad, RMSprop\t\t\t랜덤 초기화 : Gaussian or uniform, Scaling\t\t\t참고자료\t[딥러닝/머신러닝] CNN(Convolutional Neural Networks) 쉽게 이해하기\t위키백과 - 딥러닝\tWhat, Why and Which?? Activation Functions\tActivation Function(활성화 함수)" }, { "title": "[UROP] 1주 - 1. DNN 스터디", "url": "/satinbower-legacy/posts/it-project-urop-1-1-dnn/", "categories": "IT, Machine Learning", "tags": "프로젝트, 지식, IT, DNN, 딥러닝, 과학", "date": "2022-05-23 00:00:00 +0900", "snippet": "* 노란 글씨 : 이해 못 한 부분* 파란 글씨 : 내가 이해해서 추가한 부분인공지능, 머신러닝, 딥러닝\t인공지능 : 인간의 지능과 같은 기능을 하는 컴퓨터 시스템\t머신러닝 : 컴퓨터가 학습할 수 있도록 하는 알고리즘과 기술을 개발하는 분야\t딥러닝 : 여러 가지 비선형 변환기법의 조합을 통해 높은 수준의 추상화를 시도하는 기계학습 알고리즘의 집합\t→ 포함 관계 : 딥러닝 ⊂ 머신러닝 ⊂ 인공지능ANN, DNN, CNN\tANN, Artificial Neural Network : 인공신경망\t\t사람의 신경망 원리와 구조를 모방하여 만든 기계학습 알고리즘\t\t키워드 : 입력층, 출력층, 은닉층, 가중치, 바이어스\t\t문제 : 기울기 소실, 과적합, 학습 오래걸림 등 → 해결 가능함\t\tDNN, Deep Neural Network\t\t딥러닝 모델 내 은닉층을 늘려 학습의 결과를 향상시킨다. 은닉층을 2개 이상 지닌 학습 방법을 뜻함. 이것을 응용한 알고리즘으로 CNN, RNN, LSTM, GRU 등이 있음.\t\t→ DNN은 대부분 딥러닝 모델의 밑바탕이 되는 기본적인 구조이다.\t\tCNN, Convolution Neural Network : 합성곱신경망데이터의 특징을 추출해 그 패턴을 파악한다. 컨볼루션과 풀링의 조합으로 이루어진다. 정보 추출, 문장 분류, 얼굴 인식 등에 널리 사용됨.\t\t컨볼루션 : 커널을 이용해 일정 구역의 데이터의 특징을 추출해낸다. 이 결과로 만들어지는 층을 컨볼루션 레이어라고 한다. 파라미터의 개수를 효과적으로 줄일 수 있음.\t\t풀링 : 컨볼루션 이후 레이어의 사이즈를 줄임. 노이즈를 상쇄하고 미세한 부분에서 일관적이 특징을 제공한다고 함. 그러나 풀링이 어째서 그런 효과를 내는지는 모름.\t지도학습과 비지도학습\t지도학습 : 문제와 정답 모두 제공, 문제 유형에 따라 사용하는 손실 함수가 달라짐.\t비지도학습 : 문제만 제공. 정답이 정해진 문제가 아님. 데이터의 패턴을 분석해 특징이나 구조를 발견하도록 함.DNN의 개념과 원리\tDNN : 은닉층이 여러 개인 인공신경망\t과적합 : 모델이 학습 데이터에 너무 최적화되어 전체적인 특성에서 멀어지는 문제\t오차 역전파 : 출력층에서 입력층 방향으로 계산하며 가중치를 업데이트하는 방식\t경사하강법 : 함수의 기울기를 이용해 값이 극값에 이르도록 이동시키는 것.\t손실 함수(오차 함수) : 가중치에 따라 오차가 얼마나 커지고 작아지는지 평가하는 함수\t\t\t\t\t평균 제곱 오차(MSE) : 실제 값과 추정 값의 차이를 나타내며 회귀 문제에 사용\t\t\t교차 엔트로피 함수(CEE) : 두 분포 간의 차이를 나타내는 척도, 분류 문제에 사용\t\t\t\t활성화 함수 : DNN 모델이 비선형성을 표현할 수 있도록 도와준다\t→ 직선밖에 볼 줄 모르는 DNN 모델이 제대로 기능할 수 있도록 곡선을 직선으로 바꿔준다. 곡선을 왜곡해 직선처럼 보이게 한다. 퍼셉트론의 XOR 문제처럼.\t편향(bias)과 분산(variance)\t\t편향은 bias, 모델이 예측하는 값이 정답으로부터 얼마나 멀리 떨어져있는지 나타낸다. 분산은 variance, 모델이 예측하는 값들이 얼마나 서로 비슷한지 나타낸다. 모델의 예측값이 정답과 가까울수록 편향이 낮고, 예측값이 일정할수록 분산이 낮다.\t\t편향과 분산은 모델이 ‘복잡하게 생긴 정도’와 관련이 있다.\t\t아래 이미지는 회귀 모델의 정답(점)과 모델의 학습 결과(선)을 그래프로 나타낸 것이다. 셋 중 가장 나은 모델은 가운데 모델이다. 선이 정답과 가까우므로 편향 양호, 선이 지나치게 구불구불하지 않으니 분산도 양호하다.\t\t\t\t\t\t\t\t[이미지 1] 회귀 모델의 편향과 분산에 따른 결과 그림\t\t\t\t아래 이미지는 분류 모델을 위와 같은 방식으로 나타낸 것이다.\t\t위와 마찬가지로 가운데 모델이 가장 양호하다.\t\t\t\t\t\t\t\t[이미지 2] 분류 모델의 편향과 분산에 따른 결과 그림\t\t\t\t모델의 복잡도\t\t편향과 분산은 어느 한 쪽이 증가하면 다른 한 쪽이 감소하는 경향을 보인다.\t\t모델이 데이터를 반복 학습하는 수가 늘어날수록 모델의 복잡도가 커진다. 이때 학습 오차는 점점 감소하지만 테스트 오차는 같이 감소하다가 특정 시점 이후로 다시 증가하게 된다. 모델이 학습용 데이터를 외워서 학습하기 때문이다. 테스트 오차가 최소가 되는 지점에서 모델의 학습을 멈춰야 한다.\t\t학습 오차는 모델을 학습시킬 때 발생하는 오차이며, 이 오차를 줄이는 방향으로 모델을 변화시킨다. 반면 테스트 오차는 테스트용 데이터로 모델을 평가할 때 발생하는 오차이며, 모델에게는 영향을 주지 않고 학습 경과를 확인하기 위한 용도로만 사용된다.\t\tRegularization : 정규화 (≠ Normalization 표준화) ← 전제 : 지도학습\t\t과적합을 줄이는 방법 중 하나이다.\t\t모델이 가질 수 있는 분산에 제한을 부여함으로써 과적합을 방지한다. 직역은 정규화가 맞지만 normalization과의 구분을 위해 ‘규제’라고도 한다. 분산을 제한하면 편향이 증가할 수 있기 때문에 적당히 해야 한다.\t\t규제 원리 : 대부분 규제항(Regularization Term)을 이용한다. 모델의 복잡도가 올라갈수록 증가하는 함수(예: L2 함수)를 모델의 오차(cost) 함수에 규제항으로 더하여, 모델이 너무 복잡해지면 정확도와 관계 없이 오차(cost)가 증가하도록 한다.\t\t요점 : 딥러닝 모델은 학습 데이터에 익숙해지는 방향으로 학습한다. 가중치가 낮은 데이터는 모델에게 큰 영향을 미치지 못하지만 가중치가 큰 데이터는 모델에 영향을 줄 수 있다. 모델이 지나치게 학습 데이터에만 익숙해지면 일반화 성능이 떨어지기 때문에, 가중치가 큰 학습 데이터에 제약을 걸어 과적합을 줄인다.\t\t\t\t\t규제항 종류 : L1 norm, L2 norm\t\t\t\tL1 norm은 outlier에 비교적 덜 영향을 받으며 0인 지점에서 미분이 불가능하다는 단점이 있다. L2 norm은 outlier에 비교적 큰 영향을 받는다.\t\t\t\t\t\t\t\t\tnorm : 벡터의 길이(또는 크기)를 측정하는 방법이나 함수. 두 벡터 사이의 거리를 측정하는 방법이기도 하다.\t\t\t\t\tL1 norm : 두 벡터의 각 원소들의 차의 절댓값의 합. 여러 가지로 표현될 수 있음.\t\t\t\t\tL2 norm : 두 벡터의 직선 거리. 유일하게 표현됨.\t\t\t\t\tL1 loss : 오차의 절댓값의 합\t\t\t\t\tL2 loss : 오차의 제곱의 합\t\t\t\t\t선택 기준 : L1 norm은 표현이 유일하지 않기 때문에 feature selection이 가능하다. 그로 인해 Sparse model(coding)에 적합하며 convex optimization에 유용하게 쓰인다고 한다. 다만 미분 불가능한 점이 있기 때문에 기울기 기반 학습에 사용하려면 주의가 필요하다. L2 norm은 outlier에 영향을 잘 받으니 outlier를 배제하고 싶을 때 사용하면 좋을 것 같다.\t\t\t\t\t\t\t\t\t\t\t기울기 소실 문제\t\tDNN 모델은 은닉층이 여러 개이기 때문에 사용하는 활성화 함수에 따라 기울기가 0으로 수렴하여 경사하강법이 의미가 없어질 수 있음.\t\t해결 : ReLU 함수 사용\t\t학습 데이터의 입력량과 가중치 업데이트 시점에 따른 분류\t\t\t\t\tStochastic Gradient Descent(SGD) : 모델에게 한 번에 하나의 데이터만 먹이기. 매 데이터마다 가중치 업데이트함.\t\t\t\t개별 데이터로 가중치를 바로 업데이트함. 문제 공간이 매번 들어오는 입력 데이터로 바뀌는 셈인데, 그래서 전체 이미지에 대한 분류 문제가 굉장히 많은 개별 이미지에 대한 문제 공간의 집합이 됨. 배치 방식과 달리 입력된 값에 따라 가중치가 아주 다르게 나올 수도 있기 때문에 지역 최솟값에 빠질 가능성은 낮다.\t\t\t\t\t\tBatch Gradient Descent(BGD) : 배치 단위(모든 데이터)로 묶어서 먹임. 배치 내의 데이터들에 대한 오차의 평균으로 가중치 업데이트.\t\t\t\t모든 개별 데이터의 오차를 계산하고 그걸 또 평균내서 가중치를 업데이트하기 때문에 오래 걸린다. 모든 데이터를 순회하고 나서야 가중치가 업데이트되는 셈. 또한 지역 최솟값에서 빠져나오기 어렵다는 문제가 있다.\t\t\t\t\t\tMini-Batch : 위 두 가지 방식을 절충한 방식\t\t\t\t전체 데이터에서 일부를 묶어 오차를 계산하고 가중치 업데이트.\t\t\t\t\t\t\tBatch Normalization(배치 정규화)\t\t데이터를 모델에 입력하기 전에 정규화를 실행하는 것과 다르다. 모델 내부에서 은닉층의 가중치가 치우치는 것을 막기 위해(아래 [이미지 3]과 같이 되는 것을 막기 위해), 어떤 층에서 다음 층으로 가중치를 넘겨주기 전에 정규화를 하여 가중치의 범위를 제한한다. 케라스의 BatchNormalization 층을 말한다.\t\t\t\t\t\t\t\t[이미지 3] 학습이 진행될수록 가중치가 치우쳐가는 은닉층 그림\t\t\t\t가중치 초기값 설정\t\t가중치 초기값의 분포가 이후의 은닉층의 결과 값 분포에도 큰 영향을 준다. 층과 층 사이에 연결된 가중치에 상관 없이 은닉층의 결과값이 모두 같다면 아무리 노드가 많고 은닉층이 많아도 결국 노드 1개, 은닉층 1개와 다를 바 없어진다.\t\t이를 해결하기 위해 초기 가중치 설정에 대한 연구가 진행되고 있다. 현재 있는 방법으로는 Xavier, He 초기값 설정 방법 등이 있다.\t\toptimizer : 지역최솟값에 빠지지 않게 도와줌\t\t\t\t\tmomentum 방식 : SGD 방식에 기울기의 누적값을 적용한 개념이라고 한다. 관성과 비슷하다. 한 방향으로 학습이 진행될수록 가속도가 붙어 최솟값에 이르렀을 때에도 가던 방향대로 지나가 지역최솟값에 빠지지 않게 된다. 마찬가지로 학습이 점차 멈추기 되는 plateau도 해결할 수 있다. 전역 최솟값을 찾아도 학습을 계속한다는 단점이 있다. 이 단점을 극복하고자 Nestreov Momentum이라는 optimizer가 등장했다.\t\t\tAdaptive 방식\t\t\t\t\t\t\t\t\tAdaGrad : 가중치가 갑자기 크게 업데이트될 때 패널티를 주어 과적합을 방지. 단점은 제곱의 성질을 지니기 때문에 계속하다 보면 학습이 거의 진행되지 못하게 된다는 점. 이를 고치고자 RMSProp이라는 optimizer가 등장.\t\t\t\t\tRMSProp : AdaGrad에서 문제가 되었던 값(G)에 지수평균을 적용하여 비중을 조절했다.\t\t\t\t\t\t\t\t\t\tAdaptive + Momentum 방식\t\t\t\t\t\t\t\t\tAdam : RMSProp에 Momentum 적용.\t\t\t\t\t\t\t\t\t\t\tHyperparameter : DNN 모델을 학습시킬 때 사전에 정의해 주어야 하는 상수값. 예를 들어 학습률, 각 층의 노드 수, 배치사이즈 등이 있다. 이 값들을 학습시킬 수는 없지만 경험적으로 최적의 값을 추론할 수는 있다.\tDataset 구성 : 전체 데이터셋을 10이라 치면 학습용 데이터는 5, validation 데이터는 3, 테스트 데이터는 2로 설정한다고 한다. validation과 test의 차이는 학습 중간중간 평가하기 위해 사용하는 것(val)인지, 학습이 끝난 이후에 평가하기 위해 사용하는 것(test)인지 정도.DNN 구현\t개요\t\t\t\t\t기본 파라미터 설정 → 무슨 파라미터? → 가중치 설정, 배치 사이즈 설정, 규제항 결정 등을 말하는 것 같음\t\t\t분류, 회귀 DNN 모델 구현\t\t\t데이터 준비\t\t\t학습 및 성능 평가\t\t\t\t\t\t모듈\t\t1Dense(nodes,&nbsp;input_dim=ind,&nbsp;activation='relu')cs\t\tnodes : 이 은닉층의 노드 수\t\tinput_dim : 입력되는 노드의 수(== 입력값의 차원)\t\tactivation : 활성화 함수 지정\t\tDropout : 무작위로 일부 노드를 빼고 학습 진행. 과적합 방지 효과 있음.DNN 실습 데이터셋\tCIFAR-10\t\t\t\t\t총 10개의 클래스로 구성된 이미지 데이터셋\t\t\t(32, 32) 크기의 컬러 이미지\t\t\t5만 개의 학습용 데이터와 만 개의 테스트용 데이터\t\t\t\tCIFAR-100\t\t\t\t\t100개의 클래스로 구성되며, 각각의 클래스에는 600개의 이미지가 있고(학습:테스트 비율 5:1) 총 만 개의 이미지로 구성된 데이터셋\t\t\t100개의 클래스는 20개의 슈퍼클래스로 다시 분류됨\t\t\t참고자료\t[인공지능] ANN, DNN, CNN, RNN 개념과 차이\tDNN 원리\t딥러닝 모델 요약\t6. 규제, 정규화 (Regularization)\tBias and Variance (편향과 분산)\t딥러닝 용어 정리, L1 Regularization, L2 Regularization 의 이해, 용도와 차이 설명\t9. Mini-Batch (데이터가 많은 경우에는 학습을 어떻게 시키나요?)\t13. DNN(Deep Neural Network) 학습 최종정리" }, { "title": "카데인 알고리즘", "url": "/satinbower-legacy/posts/it-kadane-algorithm/", "categories": "IT, Algorithm", "tags": "지식, IT, 알고리즘, 동적계획법, 카데인알고리즘", "date": "2022-05-18 00:00:00 +0900", "snippet": "뭐 별 게 다 있어.. 프로그래머란 대체자 생각을 해보자. 어떤 배열에서 연속한 원소로 이루어진 부분 배열의 합의 최댓값을 찾고 싶다. 그런데 시간이 별로 없다. 이럴 때 쓰는 게 카데인 알고리즘이다. 이중 반복문으로 답을 찾는 브루트포스는 시간복잡도가 O(n²)이지만 이 알고리즘은 O(n)이다.목차1. 동적 계획법2. 카데인 알고리즘3. 백준 1912 연속합1. 동적 계획법카데인 알고리즘을 배우기 위해서는 동적 계획법의 개념부터 알아야 한다. 말이 계획이지 사실 그리 계획적이지는 않은 동적 계획법이란 요약하자면 ‘컨닝페이퍼 만들기’이다.하나의 큰 문제를 아주 작은 부분으로 떼어낸다. 그리고 이 작은 문제를 해결한 다음 답을 적어둔다(→ 컨닝페이퍼). 이 답은 다른 작은 문제를 해결하는 데 사용한다. 작은 문제들을 해결해나가다 보면 어느샌가 큰 문제의 답이 나와있다. 그러나 재귀는 아니다. 말로만 설명하다 보니 좀 추상적인 것 같은데 정말로 동적 계획법은 이게 다다. 내가 이해한 대로 말하자면 딱 이렇게 이렇게 해라, 하고 코드가 정해진 알고리즘이 아니고 특정 부류의 문제에 대한 행동 지침 정도로 보면 된다. 내가 이 개념을 이해하는 데 몇 달은 걸렸으니 지금 이 설명을 보고 이해가 안 간다면 충분히 그럴 수 있으니 걱정하지 않아도 된다! 이런 건 다 감으로 익히는 거지 책만 본다고 될 일은 아니다.2. 카데인 알고리즘처음부터 말했듯이 이 알고리즘이 해결할 수 있는 문제는 “어떤 배열에서 연속된 원소로 이루어진 부분 배열의 합의 최댓값 구하기”이다. 이제부터 내가 그 과정을 설명할 것이다. 참고 링크는 이 문장을 클릭하면 된다.먼저 요약하자면, 앞에서부터(혹은 취향에 따라 뒤에서부터) 부분배열의 합이 더 큰지, 지금 검사하는 원소가 더 큰지 비교해서 가장 큰 값을 남기는 것이다. 이때 부분배열의 합을 구하는 방식은 “가장 긴 부분수열 찾기” 문제와 비슷하다(난 이거 풀이 글 쓴 줄 알았는데 아니더라.. 나중에 쓰겠습니다). 예를 들어보자.여기 작고 귀여운 배열이 있다. 설명하기에 앞서 답부터 스포일러하자면 12 + 21 = 33이다.10, -4, 3, 1, 5, 6, -35, 12, 21, -1그리고 여기에 저 원본 배열과 크기가 같은 빈 배열을 하나 더 만든다. 이것을 부분합 배열이라고 부르겠다.0, 0, 0, 0, 0, 0, 0, 0, 0, 0이제부터 부분 배열의 합을 계산하기 시작하면 된다.먼저 0번 원소부터 보자. 부분 배열은 0번 원소 1개가 다이니 부분 배열의 합도 10이다. 부분합 배열의 0번 원소에 10을 대입한다.10, 0, 0, 0, 0, 0, 0, 0, 0, 0이제 원본 배열의 다음 원소를 보자. 여기서 해야 할 것은 직전에 계산했던 부분배열의 끝에 이번 원소를 추가할 것인지, 추가하지 않고 새로운 부분 배열을 시작할 것인지 정하는 것이다. 우선 직전에 계산했던 부분 배열의 합은 10이고 여기에 이번 원소를 추가한다면 10 - 4 = 6이 된다. 그리고 이번 원소는 -4이다. 부분합 배열에는 6과 -4 중 큰 값을 대입하면 된다. 그러니까 6을 대입할 것이고, 이전에 계산했던 부분 배열의 뒤에 이번 원소를 추가했다는 뜻이다.10, 6, 0, 0, 0, 0, 0, 0, 0, 0이번에 검사할 원소는 2번, 3이다. 방금 한 계산과 마찬가지로 직전에 계산한 부분배열의 합에 더하는 게 더 큰지, 이 원소를 가지고 새로운 부분 배열을 시작하는 게 더 큰지 보면 된다. 추가한다면 6 + 3 = 9이고, 그렇지 않다면 3이다. 추가하는 게 더 크기 때문에 부분합 배열의 2번 원소에 9를 대입한다.10, 6, 9, 0, 0, 0, 0, 0, 0, 0이와 같은 방식으로 6번 원소까지 계산했다고 치자. 중간 과정을 생략하는 이유는 전부 부분 배열에 추가하는 게 더 커서 똑같은 설명만 할 것이기 때문이다. 6번 원소까지 계산하고 나면 부분합 배열은 아래와 같이 될 것이다.10, 6, 9, 10, 15, 21, -14, 0, 0, 0이제 검사할 원소는 7번이다. 이번에는 상황이 다르다. 직전에 계산된 부분 배열에 원소를 추가하느니 여기서부터 새 부분 배열을 시작하는 게 낫다. 식으로 쓰면 (-14 + 12)와 12의 대소비교를 하는 것과 같다. 그러므로 부분합 배열에는 7번 원소인 12를 그대로 대입한다. 이전까지 계산된 부분 배열을 버리고 새 부분 배열을 시작한 것이다.10, 6, 9, 10, 15, 21, -14, 12, 0, 0이 이후로 부분합 배열을 채우는 과정은 생략하겠다. 이미 했던 설명을 반복할 뿐이다. 결과는 다음과 같다.10, 6, 9, 10, 15, 21, -14, 12, 33, 32마지막으로 할 일은 부분합 배열에서 최댓값을 찾아 답을 구하는 것이다. 선형 탐색을 해도 되고, 라이브러리가 제공하는 정렬 함수를 써도 되고, 지금까지의 계산 과정에서 같이 비교해서 그때그때 최댓값을 찾아둬도 된다. 어쨌든 답은 처음에 말한 대로 33이다.3. 백준 1912 연속합위 알고리즘을 활용해 풀 수 있는 문제이다. 예시도 이 문제의 예제에서 가져왔다. 과정은 다 알고 있으니 코드부터 보자. 포인터를 쓰다보니 재미들려서 이번에도 포인터 배열을 사용하긴 했지만 혹시 포인터에 대해 모른다면 그냥 크기를 자유자재로 만들 수 있는 배열을 만든 거라고 생각하면 된다.팁 : 배열같은 특정 공간 내에서 최댓값 또는 최솟값을 찾고자 할 때는 해당 공간 내의 원소로 최대/최솟값 변수를 초기화하는 게 좋다. 그렇게 하면 공간 내의 값의 범위를 신경쓰지 않아도 된다.개인적 취향 : 간단한 크기 비교와 대입만 할 거라면 if 대신 삼항연산자를 쓰는 것도 좋다. 줄 수가 줄어든다. 출력할 때에도 마찬가지로 어떤 조건에 따라 둘 중 하나의 값을 골라서 출력하는 상황이라면 삼항연산자를 활용해 한 줄에 선택과 출력을 모두 할 수 있다.#include &lt;iostream&gt;using namespace std;int main(){ // 빠른 입출력 ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int n, maxi; // 각각 입력받을 숫자의 개수와 답으로 출력할 최댓값 int* p; // 원본 배열을 저장할 포인터 int* subp; // 부분합 배열을 저장할 포인터 cin &gt;&gt; n; // 숫자 개수 입력받기 p = new int[n]; // 포인터 배열 선언, 크기는 n subp = new int[n]; // 포인터 배열 선언, 크기는 n for (int i = 0; i &lt; n; i++) cin &gt;&gt; *(p + i); // 원본 배열 입력받기 *(subp + 0) = *(p + 0); // 부분합 배열의 0번 원소에 원본 배열의 0번 원소 대입 maxi = *(subp + 0); // 최댓값 초기화 for (int i = 1; i &lt; n; i++) { *(subp + i) = (*(p + i) + *(subp + i - 1) &gt; *(p + i)) ? *(p + i) + *(subp + i - 1) : *(p + i); // 삼항연산자로 대입했다. 의미는 이전에 설명한 논리와 같다. if (*(subp + i) &gt; maxi) // 매번 최댓값을 비교해 업데이트 maxi = *(subp + i); } cout &lt;&lt; maxi; delete[] p; // 포인터 배열 해제 delete[] subp; // 포인터 배열 해제 return 0;}" }, { "title": "다른 사람의 코드 보고 배우기", "url": "/satinbower-legacy/posts/it-compare-code/", "categories": "IT, Machine Learning", "tags": "IT", "date": "2022-03-07 00:00:00 +0900", "snippet": "코드가 꽤 길어서 다른 사람 코드는 나만 봤음비교 대상- 유리 분류 : https://www.kaggle.com/uciml/glass– 내 코드 : https://www.kaggle.com/dapin1490/glass- 성별 예측 : https://www.kaggle.com/hb20007/gender-classification– 내 코드 : https://www.kaggle.com/dapin1490/glass유리 분류 모델 개선하기파악한 문제점 : 은닉층 수와 노드 수, 배치 사이즈를 너무 적게 쓴다. 손이 작다!개선 가능한 사항 : 속성 삭제 기준 바꾸기, 전체적인 수 증가, 체크포인트 사용.상세 수정 사항K겹 교차검증 사용 → 미사용(실행하는 데 시간이 너무 오래 걸린다)체크포인트 미사용 → 사용속성 삭제 기준 : 상관 관계 “값”이 작은 것 → 상관 관계 “절댓값”이 작은 것저것만 해도 모델 정확도가 0.98 정도 나와서 은닉층 노드 등 다른 인자는 바꾸지 않았다.결과정확도 약 0.86 → 0.98배운 것체크포인트로 언제나 최고의 모델을 간직하세요! 여러 번 실행하기 귀찮다고 K겹 교차검증을 남용하지 맙시다!성별 예측 모델 개선하기파악한 문제점 : 손이 작다!개선 가능한 사항 : 은닉층 수, 노드 수, 배치 사이즈 증가. 체크포인트 사용. 속성의 원 핫 인코딩.상세 수정 사항속성 값 원 핫 인코딩(pd.get_dummies) 미사용 → 사용K겹 교차검증 사용 → 미사용dense_1 : 노드 수 8 → 60, input_dim = 4 → 16dense_2 : 노드 수 4 → 35에포크 수 : 100 → 1000배치 사이즈 : 10 → 30조기 종료 대기 : 10 → 100결과정확도 약 0.52 → 약 0.60배운 것클래스뿐만 아니라 속성에도 원 핫 인코딩을 할 수 있다! 그 효과 또한 클래스에 원 핫 인코딩을 할 때와 같다. 같은 속성에 속하는 값이라도 서로 연관이 전혀 없을 때 사용할 수 있다.내가 계산하는 것도 아닌데 숫자 좀 크게 크게 쓰자. 아무도 데이터셋의 사이즈가 작다고 은닉층 노드까지 적어져야 한다고 말하지 않았다.덤그냥 봐도 속성과 클래스의 상관 관계가 확실한 데이터셋은 잘만 만지는데 내가 관계 없다고 믿으면 뭘 해도 정확도가 안 나오는 것 같다.. 분명 이게 그런 게 아닐텐데? 근데 진짜 저 성별 분류 셋 빼고는 다 잘하거든요. 그리고 내가 유일하게 관계성을 못믿는 게 저 성별 분류 셋이야. 이게 대체 불신이 먼저인지 저조한 성과가 먼저인지 닭이 먼저인지 달걀이 먼저인지." }, { "title": "딥러닝 모델에게 데이터 떠먹이는 방법 (3)", "url": "/satinbower-legacy/posts/it-deeplearning-data-3/", "categories": "IT, Machine Learning", "tags": "지식, IT, 딥러닝", "date": "2022-03-05 00:01:00 +0900", "snippet": "우리는 이걸 데이터 전처리라고 부르기로 했어요.참고사용한 데이터셋 : https://www.kaggle.com/uciml/glass 내 코드 보기 : https://www.kaggle.com/dapin1490/glass/notebook 노션에서 정리 보기 : https://dapin1490.notion.site/DIY-ae97a364485946ae832f52e8022bf202 알림 : 내가 이해한 대로 설명하는 것이니 틀린 부분이 있을 수 있다. 지적 환영!지난 글 보기딥러닝 모델에게 데이터 떠먹이는 방법 (1) - 첨도와 왜도, 상관 관계 - K겹 교차검증은 원 핫 벡터를 인자로 전달할 수 없다딥러닝 모델에게 데이터 떠먹이는 방법 (2)- 데이터의 상태가 이상하다! - 랜덤 언더, 오버 샘플링 - SMOTE 오버 샘플링 - ADASYN 오버 샘플링이번 글 목차1. 클래스 별 차등 가중치 부여하기2. 꼭 결측치가 있어야만 속성을 삭제할 수 있는 건 아니다1. 클래스 별 차등 가중치 부여하기예부터 들어보자. 여기 걸리는 사람은 많지만 죽는 사람은 적은 어떤 병이 있다. 의사는 환자의 상태를 보고 이 환자가 살지 죽을지 예측하고 싶다. 사람이 일일이 데이터를 보고 예측하기는 어려우니 딥러닝 모델의 도움을 받기로 했다. 클래스는 “생존”과 “사망” 두 가지 뿐이지만 샘플 수의 비율은 8:2 정도로 불균형하다고 하자. 이제 모델을 만들어야 한다. 어떻게 해야 할까?환자가 생존하는 데이터는 충분히 많다. 예측이 어렵지 않을 것이다. 그러나 환자가 사망하는 데이터는 적다. 그래도 가능한 정확하게 예측해야만 한다. 이럴 때 쓸 수 있는 게 사용자가 클래스 별로 서로 다른 가중치를 직접 부여하는 방법이다. 샘플이 많아 예측하기 쉬운 클래스에는 가중치를 작게 주고, 샘플이 적어 예측하기 어려운 클래스에는 가중치를 크게 준다. 이 가중치는 모델의 예측이 틀렸을 때 받는 일종의 패널티라고 생각하면 이해하기 좋다. 여기서는 8:2라고 했으니 가중치는 0.2 : 0.8 정도로 줄 수 있다. 샘플 수의 비율과 반대되는 비율로 준다고 생각하면 된다. 물론 반드시 그래야 하는 것은 아니고, 모델을 직접 실행하여 정확도를 보고 조정할 수 있다.코드로 보자. 모델을 선언하여 층을 추가한 이후의 코드로, 컴파일과 fit 부분만 가져왔다. 이 모델의 데이터셋은 아쉽게도 내가 쓴 예시대로 환자의 생존률 예측은 아니고 이 글의 가장 처음에 나와 있는 유리 분류 데이터셋이다.# 차등 가중치를 딕셔너리 자료형으로 지정c_weight = {0:1, 1:0.2, 2:0.2, 3:0.65, 4:1, 5:0.75, 6:0.8, 7:0.55}# 컴파일, 모델 실행# class_weight 인자에 지정한 가중치를 전달한다model.compile(loss=\"categorical_crossentropy\", optimizer=\"adam\", metrics=['accuracy'])model.fit(X[train], Y_one_tr, validation_split=0.3, epochs=1000, batch_size=60, verbose=1, class_weight=c_weight)주의사항이 있다. 원 핫 인코딩을 했다면 원 핫 벡터의 길이만큼 모든 인덱스에 가중치를 직접 주어야 한다. 해당 클래스의 샘플이 실제로 존재하지 않더라도 가중치는 주어야 한다. 클래스가 두 가지 뿐이라면 ‘class_weight=0.25’ 처럼 써서 가중치를 비율로 지정할 수 있다.가중치 값은 모델의 정확도를 보고 조정하는 것이긴 하지만, 0이나 1에 너무 가까우면 정확도가 오히려 떨어지는 것 같았다. 다만 이 코드에서 0번과 4번 클래스에 가중치가 1로 주어진 이유는 실제로 그 클래스가 존재하지 않기 때문이었다.2. 꼭 결측치가 있어야만 속성을 삭제할 수 있는 건 아니다설명을 시작하기에 앞서 단어 하나만 알고 가자. 결측치란 측정되지 않아 비어 있는 부분(null)이 존재하는 데이터를 말한다. 사전을 찾아보니 영어로는 missing value, 말 그대로의 뜻이다.이번에도 예시로 생각해보자. 알기 쉽게 크고 극단적인 것으로 하겠다.여기 지구 전체의 일기 데이터가 있다고 하자. 남극의 한 연구원은 이 데이터를 가지고 남극의 날씨와 펭귄의 번식 횟수 사이에 상관 관계가 있는지 알아보고 싶다. 이 연구원은 데이터를 전부 다 사용할까?나는 남극에 가본 적도 없고 기후에 대해 아는 것도 고등학교 수준으로 한 지구과학이 다라서 남극의 날씨에 어떤 요소가 영향을 주는지는 알 수 없지만, 지구 전체의 데이터가 전부 필요할 거라는 생각은 들지 않는다. 딥러닝 모델은 예측에 필요하지 않은 데이터를 스스로 골라내는 기능이 없으니 사람이 골라줘야 한다. 데이터를 골라내는 방법은 속성 삭제와 샘플 삭제 두 가지가 있는데 지금은 속성 삭제에 대해서만 보겠다. 샘플 삭제에 대해 내가 아는 것을 간단히 언급하자면, 정보가 수집되지 않았거나 누락되어 빈 칸이 너무 많은 샘플을 주로 삭제한다고 한다. 다시 말해 총 속성이 10가지 정도 있을 때 그중 7가지 속성에 대한 값이 누락된 그런 샘플을 삭제한다는 말이다.개별 케이스를 지우는 샘플 삭제와 달리 속성 삭제는 예측에 고려할 요소 하나를 통째로 삭제한다. 당연히 사람이 감으로 마구니를 찾아 제거하는 것이 아니고 먼저 어떤 속성을 삭제할지 정할 필요가 있다. 어떤 속성이 클래스와 관련이 적은지 어떻게 알 수 있을까?파이썬에서는 다양한 라이브러리를 사용할 수 있다. 그중에는 데이터의 통계를 보고, 그것을 시각화하는 데 유용하게 사용할 수 있는 라이브러리가 있다.import numpy as np # 넘파이 : 행렬이나 일반적으로 대규모 다차원 배열을 쉽게 처리 할 수 있도록 지원하는 파이썬의 라이브러리, 출처 위키백과import pandas as pd # 판다스 : 데이터 분석. 데이터 불러오기를 할 때에도 사용import matplotlib.pyplot as plt # 그래프 그리기import seaborn as sns # 그래프 그리기더 많은 정보는 이 링크에서 확인할 수 있다. 내가 첨도와 왜도, 상관 관계를 공부할 때 많은 참고가 되었던 문서다. 나는 아직까지 여러 라이브러리를 자유자재로 활용할 실력은 되지 못하니 아는 만큼만 보여주겠다.데이터가 어떤 상태이고 어떻게 구성되었는지 보기 위해 알아보는 요소 중 “상관 관계”라는 것이 있다. 판다스 라이브러리의 함수를 사용하면 어떤 속성과 어떤 속성이 서로 얼마나 관련이 있는지를 실수로 표현할 수 있는데, 이 값이 -1에 가까울수록 반비례 관계이고, 1에 가까울수록 정비례 관계이다. 그러니 어떤 방향으로든 절댓값이 클수록 관계성이 크다는 말이다. 코드는 아래와 같이 쓴다. 여기서 클래스는 ‘Type’ 속성이다.# 데이터셋에 존재하는 모든 속성 사이의 상관 관계를 보여준다print(\"\\n속성 간 상관 관계\")print(data.corr())# 특정 속성과 나머지 속성 사이의 상관 관계만을 보여준다.print(\"\\n클래스와 각 속성의 상관 관계\")print(data.corr()['Type'])결과는 다음 이미지와 같이 나온다. [이미지 1] 전체 속성 상관 관계 [이미지 2] 클래스와 각 속성간의 상관 관계 속성들이 서로 얼마나 관계가 있는지 알려주는 건 좋은데, 죄다 소수인데다 자릿수도 많으니 영 보기가 불편하다. 여기 이 이미지와 똑같은 정보를 알록달록한 이미지로 볼 수 있는 방법이 있다. 위에 써있는 네 가지 라이브러리 중 아래 두 가지 라이브러리를 사용하면 가능하다. 히스토그램과 히트맵을 볼 수 있는데, 나는 히트맵에 대해서만 설명하겠다. 히트맵은 간단히 열화상 카메라처럼 상관 관계 값이 클 수록 사용자가 지정한 색이 진하게 표시되고 값이 작을수록 색이 연해지는 그래프라고 보면 된다. 코드를 보자.# 필요 라이브러리import matplotlib.pyplot as pltimport seaborn as snsprint(\"\\n상관 관계 시각화\")plt.figure(figsize=(10, 8)) # 히트맵 각 칸의 크기를 정한다. 가로, 세로 순서이다.sns.heatmap(data.corr(), annot=True, cmap=\"YlGnBu\", vmax=1)# data.corr()는 히트맵에 들어갈 값이다. cmap은 히트맵의 색깔 테마를 정한다. vmax는 색이 얼마에 가까워질수록 진해질지 그 최댓값을 정한다.plt.show() # 히트맵 보여주기결과 이미지도 있다. [이미지 3] 상관 관계 히트맵지금 봐야 할 것은 맨 아랫줄이다. 너무 밑에 있어서 불편하다면 맨 오른쪽 세로줄을 봐도 된다. 같은 값이 쓰여 있다.축을 보면 각 속성의 이름이 쓰여 있다. 히트맵의 칸들은 좌표처럼 가로축의 속성과 세로축의 속성 사이의 상관 관계 값을 나타낸다. 아까도 말했듯 1에 가까울수록 정비례 관계이고 이 히트맵은 vmax가 1로 지정되어 있기 때문에 진한 파란색을 띄는 칸을 찾으면 금방 보인다. ‘Na’, ‘Al’, ‘Ba’ 속성의 색이 유독 진한 것을 볼 수 있다. 그리고 ‘Mg’ 속성의 색이 아주 연한 것도 보인다.아직까지 나는 어떤 기준을 갖고 속성을 삭제하는 게 적절한지는 모른다. 여러 데이터셋으로 이런저런 실험을 하면서 알아가는 중이다.. 이 데이터셋에서 나는 상관 관계 값이 음수인 속성을 모두 삭제했었다. 우연히 그 방법이 잘 통했는지 정확도가 20%p나 올랐었다.다음은 그 코드이다. ‘log_K’와 ‘log_Ca’ 속성은 신경쓰지 않아도 된다. 첨도와 왜도가 높은 속성에 로그를 취했던 것인데 지금 중요한 부분은 아니다.# 상관 관계가 반비례인 속성은 삭제하고 정비례에 가까운 속성만 남긴다data.drop(['Mg', 'log_K', 'log_Ca', 'Fe'], axis=1, inplace=True)# 지정한 속성을 삭제한다print(\"\\nafter drop\")print(data.info()) # 삭제 후 데이터 정보 확인속성을 삭제하는 코드도 위에 링크한 문서에서 더 자세히 배울 수 있다.내가 할 말은 다 끝났는데, 글이 길어져 무슨 말을 하려고 했던 건지 까먹었을 것 같으니 정리해보자. 데이터셋에는 결측치라는 것이 존재할 수 있다. 어떠한 문제로 인해 데이터에 구멍이 난 것인데, 그것을 채울 수 없거나 채우지 않는 게 낫다면 구멍난 부분을 삭제할 수 있다. 이때 특정 샘플만 구멍이 많다면 그 샘플을 삭제하고, 많은 샘플이 공통으로 구멍난 속성이 있다면 그 속성을 삭제한다.하지만 속성 삭제라는 건 반드시 결측치가 있어야만 해도 된다고 정해진 것은 아니다. 어떤 속성이 예측에 방해가 될 정도로 클래스와 관계가 없거나, 원하는 방향이 아니라면 그 속성을 삭제하고 모델을 학습시키는 게 도움이 될 수 있다. 삭제할 속성을 고를 때는 히트맵을 참고할 수 있다. 당연히 어떤 속성을 삭제하는 게 옳다고 답이 정해진 문제는 아니니 적당히 골라야 한다!" }, { "title": "딥러닝 모델에게 데이터 떠먹이는 방법 (2)", "url": "/satinbower-legacy/posts/it-deeplearning-data-2/", "categories": "IT, Machine Learning", "tags": "지식, IT, 딥러닝, 샘플링", "date": "2022-03-05 00:00:00 +0900", "snippet": "우리는 이걸 데이터 전처리라고 부르기로 했어요.참고사용한 데이터셋 : https://www.kaggle.com/uciml/glass 내 코드 보기 : https://www.kaggle.com/dapin1490/glass/notebook 노션에서 정리 보기 : https://dapin1490.notion.site/DIY-ae97a364485946ae832f52e8022bf202 알림 : 내가 이해한 대로 설명하는 것이니 틀린 부분이 있을 수 있다. 지적 환영!지난 글 보기딥러닝 모델에게 데이터 떠먹이는 방법 (1) - 첨도와 왜도, 상관 관계 - K겹 교차검증은 원 핫 벡터를 인자로 전달할 수 없다이번 글 목차0. 데이터의 상태가 이상하다!1. 랜덤 언더, 오버 샘플링2. SMOTE 오버 샘플링3. ADASYN 오버 샘플링다음 글 보기딥러닝 모델에게 데이터 떠먹이는 방법 (3) - 클래스 별 차등 가중치 부여하기 - 꼭 결측치가 있어야만 속성을 삭제할 수 있는 건 아니다0. 데이터의 상태가 이상하다!여기 서로 다른 두 데이터셋의 클래스 분포를 보여주는 히스토그램이 있다. 왼쪽은 유리 분류 데이터셋, 오른쪽은 별 유형 분류 데이터셋이다. 딱 봐도 비교되는 느낌이 온다. 왼쪽보다 오른쪽이 막대의 높이가 일정하다. 왜 저 히스토그램들을 비교해야 할까? [이미지 1] 유리 분류 [이미지 2] 별 유형 분류 사람이 무언가 배우려면 충분한 경험이 필요한 것처럼 딥러닝 모델도 정확한 학습을 하려면 충분한 데이터(샘플)가 필요하고, 수험생이 공부를 할 때 특정 과목에만 집중하면 전체적인 성적이 떨어지는 것처럼 딥러닝 모델도 특정 클래스의 샘플만 너무 많으면 정확도가 떨어진다. 데이터를 준비하는 것은 사람이 하는 일이니 이런 문제를 미리 확인하고 다듬어줘야 한다. 그 방법은 여러 가지가 있겠지만 이번에는 언더, 오버 샘플링에 대해 설명한다.1. 랜덤 언더, 오버 샘플링언더 샘플링은 샘플이 많은 클래스의 데이터를 일부만 뽑아내어 샘플이 적은 클래스와 균형을 맞추는 방법이고, 오버 샘플링은 샘플이 적은 클래스의 데이터를 더 뽑아내어 샘플이 많은 클래스와 균형을 맞추는 방법이다. 공통점은 샘플의 수를 조작하여 클래스의 균형을 맞춘다는 점이고, 차이점은 어떤 샘플의 수를 조작하는지이다.언더 샘플링은 설명만 봐도 어떻게 하는지 알 것 같다. 필요한 샘플 수보다 데이터셋에 있는 샘플 수가 더 많으니 사용자는 그중에서 고르기만 하면 된다. 소제목에서 알 수 있듯이 이번에는 랜덤으로 고르게 된다. 코드를 봐야 써먹을 테니 일단 코드를 보자.import imblearn # 샘플링 관련 라이브러리print(\"\\nimblearn 버전 확인\\n{}\".format(imblearn.__version__))# under-sampling# 참고 https://dining-developer.tistory.com/27from imblearn.under_sampling import RandomUnderSamplerX_re, Y_re = RandomUnderSampler(random_state=0).fit_resample(X, Y)# 결과 : 정확도 35% 미만나도 인터넷 검색으로 배웠기 때문에 출처가 있다. 참고 링크는 이 문장을 클릭하면 된다. 이 코드는 내가 유리 데이터셋에 실제로 적용했던 것이다. 코드 마지막의 주석을 보면 알겠지만 정확도는 사람이 눈 뜨고 찍었다고 해도 믿을 만한 수치이다(어떠한 샘플링도 사용하지 않았을 때 이 모델의 정확도는 40% ~ 58% 정도 나왔다). 유감스럽게도 이 방법에는 크나큰 단점이 존재한다. 오로지 랜덤으로 샘플을 뽑아내고 기존의 샘플 중 일부만 사용하는 방법이라, 유용하고 중요한 데이터가 사용되지 않을 수 있고 전체 데이터셋의 크기가 작아지게 된다. 그러므로 정확도는 보장할 수 없다.오버 샘플링은 어떨까? 기대했을지는 모르지만 아쉽게도 크게 다르지 않다. 코드부터 보자.import imblearn # 샘플링 관련 라이브러리print(\"\\nimblearn 버전 확인\\n{}\".format(imblearn.__version__))# over-sampling# 참고 https://ichi.pro/ko/imblearn-laibeuleolilo-bulgyunhyeong-deiteo-seteu-cheoli-245596308465908from imblearn.over_sampling import RandomOverSamplerX, Y = RandomOverSampler(random_state=0).fit_resample(X, Y)# 결과 : 정확도 약 30%참고 링크는 이 문장을 클릭하면 된다. 이 코드도 내가 적용해봤던 것이다. 정확도는 언더 샘플링과 비슷하게 사람이 눈 뜨고 찍는 수준이다. 이 방법의 단점은 아까와는 조금 다르다. 모든 데이터를 다 사용하긴 하는데, 샘플이 적은 클래스의 데이터를 일부 중복하여 사용하기 때문에 과적합에 취약하다. 사람으로 치면 공부는 많이 하는데, 똑같은 몇 문제만 수십 번을 보는 학생이다. 이 학생은 변형과 활용 문제에 약할 것이라고 예상할 수 있듯이 모델도 똑같이 약해진다.이 문단은 내 생각이니 틀렸다면 지적해주길 바라며, 읽지 않고 넘어가도 무방하다. 여기까지만 보면 랜덤 언더/오버 샘플링은 쓸모가 없는 방법인 것 같다. 그럼 이 방법들이 왜 있을까? 내 경험에 비추어 보았을 때, 보통 이렇게 간단하고 효과가 나쁜 수단들은 다른 복잡하고 효과가 좋은 수단의 프로토타입인 경우가 많았다. 작년에 인공지능의 역사에 대해 조금 배웠는데, 초기의 인공지능은 미연시 게임처럼 논리로 구성된 선택지가 사람에 의해 프로그래밍되고 그 선택지대로만 행동했다고 한다. 사람 두 명과 인공지능 하나로 구성되어 인공지능의 “사람 같음”을 평가하는 튜링 테스트는 당연히 통과하지 못했다. 실패하긴 했지만 그런 시도가 계속해서 있었기 때문에 지금의 챗봇과 여러 인공지능이 있다. 말이 길어지니 좀 거창해졌는데, 랜덤 언더/오버 샘플링도 다른 샘플링 기법의 배경 지식 정도로 생각하면 된다고 생각한다.2. SMOTE 오버 샘플링아까는 아무 데이터나 중복해서 뽑았기 때문에 정확도가 낮았으니 이번에는 좀 다르게 데이터를 뽑아보자. 머릿속에 깨끗한 평면을 하나 놓자. 그리고 클래스 별 각각의 샘플을 서로 구분되는 색의 점으로 찍는다고 생각해보자. 특정 클래스의 샘플이 적으니 그 색깔로 찍힌 점도 적을 것이다. SMOTE는 이 소수 클래스의 점들 사이에 선을 긋는다. 그리고 이 선들 위에 새로운 점을 찍어 원본과 비슷하지만 똑같지는 않은 데이터를 오버 샘플링한다. 이전의 방법들보다 과적합에 덜 취약하다.내가 할 설명은 끝났으니 코드를 보자.import imblearn # 샘플링 관련 라이브러리print(\"\\nimblearn 버전 확인\\n{}\".format(imblearn.__version__))# SMOTE 오버 샘플링# 참고 https://ichi.pro/ko/imblearn-laibeuleolilo-bulgyunhyeong-deiteo-seteu-cheoli-245596308465908from imblearn.over_sampling import SMOTEX, Y = SMOTE(random_state=0).fit_resample(X, Y)# 결과 : 정확도 60% 이하. 기존의 모델에서 약간 개선되긴 하였으나 부족함.참고 링크는 이 문장을 클릭하면 된다. 위에서도 언급하긴 했지만 내가 이 기법들을 공부할 당시 어떠한 샘플링도 사용하지 않은 내 모델의 정확도는 40~58%였다. 그 상태에서 60%가 나왔으니 미묘한 개선은 개선이지만, 영 부족하다. 아직 내가 아는 것이 적어 이 방법을 온전히 활용하지 못한 것 같다.3. ADASYN 오버 샘플링ADASYN은 SMOTE의 개량형이라고 보면 된다. 선을 긋는 것까지는 SMOTE와 같은데, 이 위에 새로운 점을 찍을 때 임의의 작은 값을 더해주어 좀 더 사실적이고 분산된 샘플을 생성한다고 한다. 코드를 보자.import imblearn # 샘플링 관련 라이브러리print(\"\\nimblearn 버전 확인\\n{}\".format(imblearn.__version__))# ADASYN 오버 샘플링# 참고 https://dining-developer.tistory.com/27from imblearn.over_sampling import ADASYNstrategy = {1:70, 2:76, 3:30, 5:30, 6:30, 7:29}X, Y = ADASYN(sampling_strategy=strategy).fit_resample(X, Y)# 결과 : 정확도 50% 미만.참고 링크는 이 문장을 클릭하면 된다. 유감스럽게도 내 모델에서는 SMOTE보다 정확도가 떨어졌다. 저 코드를 쓸 때 약간의 문제가 있었는데, 코드 자체는 어떻게든 실행이 되게 만들었지만 이번에도 역시 내가 잘못 사용한 것 같다.위의 코드를 보면 SMOTE 코드와 달리 sampling_strategy라는 인자가 들어간 것을 확인할 수 있다. 이 인자는 각 클래스의 샘플들을 어떤 비율로 오버 샘플링할지 정해주는 것인데, 클래스가 단 둘뿐이라면 sampling_strategy 인자에 직접 실수 형태로 전달하여 비율을 지정할 수 있고, 그렇지 않다면 위와 같이 각 클래스 별로 개수를 정해줘야 한다. 이때 개수는 해당 클래스의 원래 샘플 개수와 같거나 더 많아야만 하며 이유는 알지 못했지만 모든 클래스의 샘플 수를 똑같이 지정하면 오류가 난다." }, { "title": "딥러닝 모델에게 데이터 떠먹이는 방법 (1)", "url": "/satinbower-legacy/posts/it-deeplearning-data-1/", "categories": "IT, Machine Learning", "tags": "지식, IT, 딥러닝", "date": "2022-02-28 00:00:00 +0900", "snippet": "우리는 이걸 데이터 전처리라고 부르기로 했어요.이 글의 목적캐글에서 유리 종류 구분하는 모델 만들면서 공부했던 것들을 여기에 정리해보겠다. 데이터를 어떻게든 다듬어서 정확도를 올려보겠다고 별 걸 다 공부했는데 그건 다 효과가 없었고 속성 몇 개 지웠더니 정확도가 20%p나 올라버려서 허무했지. 전체 코드 보기 : https://www.kaggle.com/dapin1490/glass/notebook 노션에도 정리해 두었으니 많이들 봐주시라구요 참고 : 내가 이해한 대로 설명하는 것이니 틀린 부분이 있을 수 있다. 지적 환영!이번 글 목차1. 첨도와 왜도, 상관 관계2. K겹 교차검증은 원 핫 벡터를 인자로 전달할 수 없다다음 글 보기딥러닝 모델에게 데이터 떠먹이는 방법 (2) 데이터의 상태가 이상하다! 랜덤 언더, 오버 샘플링 SMOTE 오버 샘플링 ADASYN 오버 샘플링딥러닝 모델에게 데이터 떠먹이는 방법 (3) 클래스 별 차등 가중치 부여하기 꼭 결측치가 있어야만 속성을 삭제할 수 있는 건 아니다1. 첨도와 왜도, 상관 관계- 필요 라이브러리import numpy as npimport pandas as pdimport seaborn as sns- 첨도 : 데이터가 얼마나 한 지점에 몰려 있나? 를 나타낸다. 이 값이 클수록 데이터가 많이 몰려있다는 의미이고, 값이 작으면 데이터가 많이 퍼져있다는 뜻이다.# 데이터셋의 속성 별 첨도 확인하기print(data.kurtosis())# 속성 'K'의 히스토그램 보기import matplotlib.pyplot as plt # 그래프 보기import seaborn as sns # 그래프 보기sns.histplot(data['K'])plt.show()첨도가 54.7쯤 되면 아래와 같은 히스토그램을 볼 수 있다. 세로축의 Count는 값의 개수, 가로축의 K는 이 속성의 이름이다. 딱 봐도 대략 0.1과 0.7쯤에 거의 모든 값이 몰려 있는 것을 확인할 수 있다. [이미지 1] 첨도가 약 54.7인 속성의 히스토그램- 왜도 : 데이터가 얼마나 한 쪽에 치우쳐 있나? 를 나타낸다. 이 값이 양수이면 왼쪽에 치우쳐 있고(= 오른쪽 꼬리가 길고), 음수이면 오른쪽에 치우쳐 있다(= 왼쪽 꼬리가 길다). 요약하자면 절댓값이 클수록 꼬리가 길다.# 속성 별 왜도 확인하기print(data.skew())위에서 확인했던 첨도가 약 54.7인 속성 ‘K’의 왜도는 약 6.6이다. 양수이고, 오른쪽에 자잘한 값이 길게 늘어지는 것을 [이미지 1]에서 확인할 수 있다.- 첨도와 왜도는 뭐가 다르냐?얼핏 보면 첨도나 왜도나 같은 말을 하는 것처럼 보일 수 있다. 하지만 잘 생각해 보면 분명한 차이가 있다. 정규분포를 가지고 이해해보자. 참고용으로 가져온 아래 그래프에서 빨간 그래프와 파란 그래프만을 본다. 빨간 그래프는 평균이 0, 분산이 1인 표준 정규 분포 그래프이다. 파란 그래프는 평균은 같지만 분산이 더 작다. 이 두 그래프의 첨도와 왜도는 어떻게 다를까? [이미지 2] 정규 분포 그래프, 출처 위키백과편의상 빨간 그래프를 A, 파란 그래프를 B라고 부르자. 첨도는 B가 더 크고, 왜도는 같다. 여기서 첨도와 왜도의 차이를 알 수 있다. 첨도는 값이 몰려 있는 지점이 어디든, 몰려 있기만 하면 무조건 커지는 값이다. 왜도는 값이 얼마나 몰려 있는지에 영향을 받을 수는 있지만 그게 가장 중요한 요인은 되지 못한다. 아무리 값이 한 지점에 몰린다 해도 좌우 대칭을 유지한다면 왜도는 영향을 받지 않는다. 왜도는 아까 괄호에 덧붙인 설명 그대로, 어느 쪽 꼬리가 더 긴지 나타내는 지표이다.- 상관 관계 : 난 증가할 건데 넌 어느 쪽으로 가니? 라는 질문으로 이해할 수 있겠다. -1과 1 사이의 값을 가지며, -1에 가까울수록 반비례, 1에 가까울수록 정비례 관계이다. 첨도나 왜도와는 달리 무조건 값이 크다고 나쁜 것도 아니고 작다고 꼭 좋은 것도 아니다. 다만 알 수 있는 것은 절댓값이 작을 수록 상관 관계가 적다는 것이다.# 클래스를 포함한 모든 속성 간의 상관 관계 수치로 확인하기print(data.corr())# 상관 관계 히트맵 보기import matplotlib.pyplot as plt # 그래프 보기import seaborn as sns # 그래프 보기plt.figure(figsize=(10, 8))sns.heatmap(data.corr(), annot=True, cmap=\"YlGnBu\", vmax=1)plt.show()상관 관계는 숫자로 확인할 수도 있긴 하지만 히트맵으로 보면 훨씬 보기 좋다. 아래 히트맵은 상관 관계가 1에 가까울수록 진한 색을 띈다. Type가 클래스이니 맨아랫줄을 보거나 가장 오른쪽 줄을 보면 클래스와 다른 속성 간의 상관 관계를 알 수 있다. 클래스와 정비례 방향으로 상관 관계가 가장 높은 것은 속성 ‘Al’이고, 반비례 방향으로 상관 관계가 가장 높은 것은 속성 ‘Mg’이다. 어느 방향으로든 상관 관계가 가장 낮은 것은 속성 ‘Ca’이다. [이미지 3] 상관 관계 시각화(히트맵)2. K겹 교차검증은 원 핫 벡터를 인자로 전달할 수 없다- K겹 교차검증 : 이번엔 내가 테스트 데이터 할게 다음엔 네가 테스트 데이터 해 딥러닝 모델을 훈련시키고 그 성과를 확인하려면 테스트를 시켜야 한다. 보통은 전체 데이터셋에서 테스트 데이터를 따로 분할해 놓고 쓰거나, 모델을 실행할 때 validation_split 인자를 주어 학습 과정에서 알아서 나누어 쓰도록 한다(두 가지 방법을 한 번에 사용하기도 한다). 그런데 세상이 아무리 정보가 넘쳐나는 세상이 되었다고 한들 학습에 필요한 데이터가 부족한 문제는 얼마든지 있을 수 있다. K겹 교차검증은 이럴 때 사용할 수 있다. 그림부터 보고 이해하자. [이미지 4] K겹 교차검증, 출처 &lt;모두의 딥러닝&gt;먼저 데이터셋을 프로그래머가 정한 개수(K개)로 나눈다. 그리고 그 중 하나씩을 테스트 데이터로 사용하며 총 K회 모델을 훈련시킨다. 각각의 테스트 결과로 나온 정확도를 평균내서 모델의 성능을 평가하는 방법이다. 모델을 아주 잘못 만든 게 아닌 이상 보통은 개별 결과가 서로 크게 차이나지 않는다.- K겹 교차검증 코드 보기 : 코드 자체는 좀 간략하게 줄이려고 했는데 주석이 많아서 길어 보인다.# 라이브러리 불러오기from keras.models import Sequential # 모델 선언, 구조 결정from keras.layers import Dense # 모델에 층 추가from sklearn.model_selection import StratifiedKFold # K겹 교차검증# 교차검증 셋 분할n_fold = 2 # 2개로 분할# 분할 수는 최소 2개 이상 설정해야 한다.# 1개로 설정할 거면 교차검증의 의미가 없으며, 오류가 난다.# 난 그냥 모델 여러 번 실행해서 정확도 보기가 귀찮아서 이 방법을 쓴 거라 1로 해도 되는지 실행해봤다..skf = StratifiedKFold(n_splits=n_fold, shuffle=True, random_state=seed)# n_splits=n_fold : 데이터를 몇 개로 나눌 것인지 정함# shuffle=True : 데이터를 섞어서 분할# random_state=seed : 랜덤 시드 설정# 빈 accuracy 배열 : K개의 테스트 정확도를 저장함acc = []# my modelfor train, test in skf.split(X, Y): model = Sequential() model.add(Dense(15, input_dim=5, activation=\"relu\")) model.add(Dense(13, activation=\"relu\")) model.add(Dense(8, activation=\"softmax\")) # model compile model.compile(loss=\"categorical_crossentropy\", optimizer=\"adam\", metrics=['accuracy']) model.fit(X[train], Y[train], validation_split=0.3, epochs=1000, batch_size=60, verbose=1) # validation_split=0.3 : 안 써도 된다. 학습 데이터 중 30%를 학습 중 모델의 테스트용으로 쓴다는 뜻이다. k_acc = \"%.4f\" % (model.evaluate(X[test], Y[test])[1]) acc.append(k_acc)# 결과 출력# 주의 사항 : 일반적인 리스트가 아니기 때문에 mean()은 사용 불가하다.print(\"\\n %.f fold accuracy:\" % n_fold, acc)- 원 핫 인코딩, 원 핫 벡터 : 다른 건 보지 마 이게 정답이야 이것만 봐 좀 원 핫 인코딩은 예측해야 할 클래스가 선형 회귀가 아니고, 여러 개일 때 사용할 수 있는 방법이다. 예를 들어 0번부터 3번까지 클래스가 3개 있다고 하자. 프로그래머는 딥러닝 모델에게 이 클래스를 그대로 [0, 1, 2, 3]라고 전달할 수 있다. 그러나 보통은 원 핫 인코딩을 거쳐 [ [1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1] ] 이런 형태로 전달한다. 이렇게 정답 클래스의 인덱스만 1로 표시하고 나머지는 0으로 표시하는 것이 원 핫 인코딩이다. 그리고 원 핫 인코딩을 한 클래스 각각을 원 핫 벡터라고 한다.- 원 핫 벡터의 길이 : 누가 여기서 가장 크냐? 방금 예시에서는 클래스가 0부터 3까지 있었다. 그럼 만약 클래스가 1과 3만 있는 데이터를 원 핫 인코딩 한다면 어떻게 될까? 사람 기준에서는 어차피 둘 중 하나이니 [ [1, 0], [0, 1] ] 이렇게만 만들면 될 것 같지만 실제로 원 핫 인코딩을 해보면 위의 예시와 똑같은 결과가 나온다. 이유는 원 핫 인코딩이 표시하는 것이 클래스의 상대적 순서가 아니라, 인덱스 자체이기 때문이다. 파이썬의 인덱스는 0부터 시작하니, 정수로 표시된 클래스들 중 가장 큰 수를 받은 클래스의 숫자 + 1이 원 핫 벡터의 길이가 되고, 동시에 그것이 출력층의 노드 개수가 된다(클래스의 인덱스를 음수로 주는 경우는 본 적이 없다). 이는 자연어 처리에서도 똑같이 적용된다만, 지금 정리할 개념은 아니니 언급만 해둔다.- 원 핫 인코딩 왜 함? 원 핫 벡터에 사용되는 숫자와 클래스에 매겨지는 인덱스에 사용되는 숫자를 생각해 보자. 클래스 인덱스는 10진수로 매겨진다. 원 핫 벡터는 0과 1만 사용하니 2진수라고 할 수 있겠다. 10진수와 2진수의 차이가 뭘까? 10진수는 산수가 되고 2진수는 안 된다는 점이다. 10진수인 1과 2를 더하면 3이 되지만 원 핫 벡터는 모든 값을 0과 1로만 표시하면서 그런 계산을 불가능하게 만들었다. 이 부분이 원 핫 인코딩의 장점이자 단점이다.사람은 데이터의 의미를 이해할 수 있으니 1번 클래스와 2번 클래스를 더하는 것과 3번 클래스는 무관하다는 사실을 인지할 수 있다. 하지만 모델은 그런 생각을 할 수 없다. 그렇기 때문에 클래스의 인덱스를 10진수로 주면 1 + 2 = 3이니까 1번 클래스와 2번 클래스를 더하면 3번 클래스와 같을 거라는 잘못된 학습을 할 수도 있다. 원 핫 인코딩은 이 문제를 방지한다. 이것이 장점이다.반면 실제로 1번 클래스와 2번 클래스의 합이 3번 클래스와 관계가 있는 데이터도 있을 수 있다. 예를 들면 자연어 처리가 그러하다. 하나의 문장 내에서 각각의 단어는 무관하지 않다. “오늘 날씨”와 “내일 날씨”는 같은 “날씨”를 요구한다고 해도 다르게 해석되어야 한다. 원 핫 인코딩은 이런 관계성을 차단하여 클래스 사이의 유사성도 나타내지 못하게 된다는 것이 단점이다.- K겹 교차검증에 원 핫 인코딩을 못쓴다고? K겹 교차검증은 데이터 전체를 우선 K개의 세트로 분할한 후 모델에 주어 학습시킨다. 이때 클래스는 원 핫 벡터 형태로 넘겨줄 수 없다. 이유까지 아는 것은 아니고, 오류가 떠서 알게 된 사실이다.그렇다면 K겹 교차검증을 하려거든 원 핫 인코딩을 포기해야 할까? 다행히도 그렇지는 않다. 데이터셋을 먼저 분할하여 반복문 내에 진입한 후, 그 안에서 원 핫 인코딩을 실행하면 된다. 그게 다다!- K겹 교차검증과 원 핫 인코딩 : 이제와서 밝히지만 위의 K겹 교차검증 코드는 이 코드에서 원 핫 인코딩 부분만 지운 것이라 그대로 실행하면 오류가 발생할 수 있다. 그건 참고로만 보자. 이 코드는 실행 가능하다.# make modelfrom keras.models import Sequential # 모델 선언, 구조 결정from keras.layers import Dense # 모델에 층 추가from sklearn.model_selection import StratifiedKFold # K겹 교차검증# 교차검증 셋 분할n_fold = 2skf = StratifiedKFold(n_splits=n_fold, shuffle=True, random_state=seed)# 빈 accuracy 배열acc = []from keras.utils import np_utils # 원 핫 인코딩# my modelfor train, test in skf.split(X, Y): # 분할되어 들어온 클래스 데이터를 원 핫 인코딩 한다. Y_one_tr = np_utils.to_categorical(Y[train]) Y_one_te = np_utils.to_categorical(Y[test]) # 이후는 전과 같다. model = Sequential() model.add(Dense(15, input_dim=5, activation=\"relu\")) model.add(Dense(13, activation=\"relu\")) model.add(Dense(8, activation=\"softmax\")) # model compile model.compile(loss=\"categorical_crossentropy\", optimizer=\"adam\", metrics=['accuracy']) model.fit(X[train], Y_one_tr, validation_split=0.3, epochs=1000, batch_size=60, verbose=1) k_acc = \"%.4f\" % (model.evaluate(X[test], Y_one_te)[1]) acc.append(k_acc)# 결과 출력print(\"\\n %.f fold accuracy:\" % n_fold, acc)" }, { "title": "퀵 정렬", "url": "/satinbower-legacy/posts/it-quick-sort/", "categories": "IT, Algorithm", "tags": "지식, IT, 알고리즘, 퀵정렬", "date": "2022-02-06 00:00:00 +0900", "snippet": "올림피우스는 결승점의 절반을 가고, 그 나머지 절반의 절반을 가고, 또 그 절반을 가고… 더보기데이터를 빠르게 반으로 갈라버리는 퀵 정렬을 배워보자. 부제목에 쓰인 이야기는 제논의 역설 중 하나이다. ‘아킬레우스와 거북이의 경주’도 있는데 재밌으니 한번 찾아보자.- 알아야 할 것0. 재귀 → 백트래킹1. 분할 정복2. 퀵 정렬1. 분할 정복요약 : 그대로 해결할 수 없는 문제를 작은 문제로 분할하여 문제를 해결하는 방법이나 알고리즘이다. (출처 위키백과) 어려운 문제를 풀어야 할 때, 그 문제와 같은 형식으로 아주 쉬운 문제를 만들어 먼저 해결 방법을 익히고 어려운 문제를 풀어본 적이 있는가? 내가 어릴 때 읽었던 수학 소설책에서 나왔던 방법이다. 제목이 &lt;피타고라스 구출작전&gt;이었나? 같은 시리즈의 책도 한 권 더 있었는데 정확히 어느 쪽에서 나온 얘기인지는 기억나지 않는다. 그래도 어릴 때부터 지금까지 내가 잊지 않고 문제가 막히면 한번씩은 생각해보는 좋은 방법이다. 분할 정복은 이 방법과 비슷하다. 큰 문제 하나를 작은 문제 여러 개로 만들어 각각 해결한 다음 하나의 큰 답으로 만들어낸다.2. 퀵 정렬제논의 역설에서 올림피우스는 결승점에 도달하지 못했을지도 모르지만 퀵 정렬은 결승점에 도달할 수 있는 알고리즘이다. 그 과정을 설명하자면 다음과 같다. 여기 크기가 아주 크고 다양한 값이 뒤섞인 배열이 있다. 이 배열을 빠르게 정리하고 싶다. 우선 배열 내에서 기준이 될 값(pivot 피벗이라고 한다)을 하나 정한다. 배열의 처음과 끝에서부터 하나씩 좁혀오며 기준 값과 크기를 비교한다. 처음에서부터 오는 값을 i, 끝에서부터 오는 값을 j라고 하자. i가 기준 값보다 크고, j가 기준 값보다 작을 때 두 값을 뒤바꾼다. 이 과정을 i가 j보다 뒤에 있게 될 때까지 계속한다. i와 j는 대칭되게 이동하지 않을 수 있다. i가 j보다 뒤로 갔다면 전체 배열을 반으로 나눈다. 반으로 나눈 두 배열을 arr1, arr2라고 하자. arr1과 arr2에서 각각 기준 값을 정하고 2번의 과정을 반복한다. 끝나면 두 배열을 다시 각각 반으로 나눈다. 반으로 나누어진 배열의 크기가 1이 될 때까지 2번과 3번을 반복한다. 크기가 1인 배열은 항상 정렬되어 있는 것과 같으므로 그 때 정렬이 끝난다.글만 보면 아쉽기도 하고, 위키백과에 좋은 이미지가 있어서 가져왔다. 다만 기준 값을 고르는 위치가 내가 뒤에 설명할 예시 코드와는 다르다는 점은 알아둬야 한다. 내 코드는 배열의 중간에 있는 값을 피벗으로 정한다. 이미지는 이해를 돕는 참고용으로만 보자! [이미지 1] 퀵 정렬 애니메이션, 출처 위키백과3. 그래서 이걸 코드로 어떻게 쓰는데요이번에도 직접 코드를 써볼 수 있을까 해서 해봤는데 영 신통치 않았다.. 그래서 다른 예시 참고해서 고쳐왔다. 참고한 블로그는 이쪽 : https://dpdpwl.tistory.com/46깃허브 : [C++/퀵 정렬 예시 코드.cpp], [파이썬/퀵 정렬 예시 코드.py][C++ 예시 코드]부연설명 : swap 함수를 사용하지 않을 생각이라면 &lt;algorithm&gt; 클래스는 가져오지 않고, swap 없이 임시 변수를 하나 더 두어 서로 자리를 바꾸어도 된다. 프로그래머 두 명이 자리를 바꾸려면 의자 세 개가 필요하다는 말 처럼.#include &lt;iostream&gt;#include &lt;algorithm&gt; // swap 함수를 사용하기 위함using namespace std;// 퀵 정렬 함수void qsort(int list[], int i, int j);int main(){ int s = 12; // 배열 크기 int ar[] = { 5, 9, 6, 9, 2, 9, 1, 3, 7, 10, 4, 8 }; // 정렬할 배열 qsort(ar, 0, s - 1); // 정렬 함수 호출 for (int i = 0; i &lt; s; i++) // 정렬한 배열 출력 cout &lt;&lt; ar[i] &lt;&lt; \" \"; return 0;}// 퀵 정렬 함수void qsort(int list[], int i, int j) // 배열은 기본적으로 참조 전달이기 때문에 &amp;를 붙이면 안 된다{ int p = (i + j) / 2; // 기준 값 피벗 int ni = i; // 다음 호출에 쓸 i int nj = j; // 다음 호출에 쓸 j if (i &gt;= j) // 배열 크기가 1이라면 정렬 끝, 리턴 return; while (i &lt; j) { // i와 j가 만나면 중단 while (list[i] &lt; list[p]) // i 쪽에서 기준 값보다 큰 값 찾기 i++; while (list[j] &gt; list[p]) // j 쪽에서 기준 값보다 작은 값 찾기 j--; if (i &lt;= j) { // i가 왼쪽에 있고 j가 오른쪽에 있을 때에만 실행, 겹쳐도 된다. swap(list[i], list[j]); // i와 j 자리에 있는 두 요소를 서로 바꿈 // 사용한 i와 j를 바꿔주지 않으면 무한루프가 생김 i++; j--; } } // 나누어진 배열 양쪽에 대한 재귀 호출 qsort(list, ni, j); qsort(list, i, nj);}[파이썬 소스 코드]참고 : 파이썬은 프로그래머 두 명이 의자 두 개만으로도 자리를 바꿀 수 있는 언어이기 때문에 굳이 swap 함수 같은 것이 필요하지 않다.# 퀵 정렬 함수def qsort(lis, i, j): p = (i + j) // 2 # 기준 값 피벗 next_i = i # 다음 호출에 쓸 i next_j = j # 다음 호출에 쓸 j if i &gt;= j: # 배열 크기가 1이라면 정렬 끝, 리턴 return while i &lt; j: # i와 j가 만나면 중단 while lis[i] &lt; lis[p]: # i 쪽에서 기준 값보다 큰 값 찾기 i += 1 while lis[j] &gt; lis[p]: # j 쪽에서 기준 값보다 작은 값 찾기 j -= 1 if i &lt;= j: # i가 왼쪽에 있고 j가 오른쪽에 있을 때에만 실행, 겹쳐도 된다. lis[i], lis[j] = lis[j], lis[i] # i와 j 자리에 있는 두 요소를 서로 바꿈 # 사용한 i와 j를 바꿔주지 않으면 무한루프가 생김 i += 1 j -= 1 # 나누어진 배열 양쪽에 대한 재귀 호출 qsort(lis, next_i, j) qsort(lis, i, next_j)ar = [5, 9, 6, 9, 2, 9, 1, 3, 7, 10, 4, 8] # 정렬할 배열s = len(ar) # 배열 크기qsort(ar, 0, s - 1) # 정렬 함수 호출print(ar) # 정렬한 배열 출력" }, { "title": "카운팅 정렬(+ 선택 정렬)", "url": "/satinbower-legacy/posts/it-counting-sort/", "categories": "IT, Algorithm", "tags": "지식, IT, 정렬, 알고리즘, 카운팅정렬", "date": "2022-01-29 00:00:00 +0900", "snippet": "이 수는 몇 개 있으니까 여기 놓고 저 수는 몇 개 있으니까 저기 놓고… 더보기많고 많은 정렬 알고리즘 중 정렬할 수의 범위가 한정적일 때 쓸 수 있는 카운팅 정렬을 공부해 보자. 선택 정렬은 덤이다.1. 정렬 알고리즘위키백과에 따르면 ‘원소들을 번호순이나 사전 순서와 같이 일정한 순서대로 열거하는 알고리즘’이라고 한다. 선택 정렬, 버블 정렬, 퀵 정렬 등등 종류가 꽤 많다. 데이터를 의미있게 만드는 데 유용하게 쓴다.정렬 알고리즘은 출력 형식이 정해져 있다. 비내림차순일 것 : 어떤 배열 A의 원소 ai와 aj에 대해 i &lt; j일 때, ai ≤ aj이어야만 한다. 입력을 재배열하여 만든 순열일 것1-1. 시간 복잡도정의 : 문제를 해결하는데 걸리는 시간과 입력의 함수 관계 크기가 n인 입력에 대하여 문제 해결에 걸리는 시간을 식으로 나타내는 것으로 주로 빅-오 표기법을 사용하는데, 이 표기법은 계수와 낮은 차수의 항을 제외시킨다. 예를 들어 크기가 n인 입력에 대해 어떤 알고리즘에 필요한 시간이 최대 an2 + bn(a ≠ 0)이라고 한다면, 이 알고리즘의 시간 복잡도는 O(n2)이라고 표기하는 것이다. (출처 위키백과)2. 카운팅 정렬요약 : 주어진 수열에서 각각의 숫자가 종류별로 몇 개씩 등장하는지 센 다음, 그 개수에 맞추어 원소를 새로 나열한다. 등장하는 수의 범위가 제한적일 때 사용할 수 있다.여기 0부터 9까지의 숫자를 대충 흩뿌린 배열이 하나 있다. 순서도 맞지 않고, 중복도 있다. 없는 숫자도 있을 수 있다. 총 원소 개수는 15개이다.ar = [ 3, 4, 2, 6, 8, 2, 9, 0, 4, 8, 7, 5, 2, 4, 0 ]이제 0부터 9까지 원소가 총 10개인 배열을 만들어 위의 배열에 나오는 원소들의 개수를 세자. 예를 들어 3은 1개, 8은 2개 이런 식으로 세는 것이다. 셈한 수의 개수는 아까 만든 크기가 10인 배열에 저장한다. 다 세면 다음과 같다.cn = [ 2, 0, 3, 1, 3, 1, 1, 1, 2, 1 ]다음으로 이 개수들을 누적하여 합한다. 0번 원소는 그대로 두고, 1번 원소는 (0번 + 1번), 2번 원소는 (0번 + 1번 + 2번) 이런 식으로 더하면 된다. 이렇게 누적된 개수는 각 숫자가 마지막으로 나열될 위치의 인덱스 + 1과 같다. 다시 말해 각 숫자가 마지막으로 몇 번째 자리에 나와야 하는지를 의미하게 된다.cn = [ 2, 2, 5, 6, 9, 10, 11, 12, 14, 15 ]이제 이 수들에 맞춰 정렬하지 않은 배열을 새 배열에 넣으면 된다. 배열의 인덱스보다 1 크게 저장되어 있으니 먼저 1을 빼고 나온 수의 인덱스에 맞추어 넣으면 된다. 수를 넣기 전에 매번 1을 빼기 때문에 남은 누적 인덱스의 업데이트도 겸하는 셈이다. 정렬된 배열은 아래와 같다.sorted_ar = [ 0, 0, 2, 2, 2, 3, 4, 4, 4, 5, 6, 7, 8, 8, 9 ]내가 공부를 위해 찾아봤던 블로그에서 좋은 자료를 인용해 두어서 같이 올린다. 카운팅 정렬의 과정을 애니메이션으로 만들었다. 링크 : 참고한 블로그, 카운팅 정렬 애니메이션2-1. 굳이 원소 개수를 누적해서 자리를 계산하는 이유내가 생각해낸 의문은 아니고(궁금해하기도 전에), 참고했던 블로그에 설명되어 있던 것이다. 아까 cn 배열에 원소 개수를 세었을 때, 각각의 원소 개수만큼 바로 반복문에 넣어 출력해도 될 것 같은데 왜 그러지 않고 굳이 누적하여 새 배열에 넣었을까?아까와 같은 예시에서는 원소 개수만으로 반복문을 넣어 출력하는 방법이 통할지도 모른다. 빠진 숫자가 거의 없고 전체적으로 개수가 고르게 퍼져 있으니 카운팅 정렬을 하나, 원소 개수대로 출력하나 큰 차이는 없을 것이다. 그러나 만약 1부터 100까지의 숫자가 들어갈 수 있고, 포함된 원소는 아래와 같은 배열을 정렬한다면 어떨까?ar2 = [ 1, 100, 95, 96, 95, 99, 2, 100, 97, 98 ]개수를 세고 나면 개수 배열에는 값이 0인 원소가 대부분일 것이다. 이 배열을 원소의 값만큼, 즉 각 숫자의 개수만큼 매번 반복문을 넣어 출력하도록 한다면 개수가 0개인 3부터 94까지는 무의미한 반복문을 실행하게 될 것이다. 프로그램의 입장에서는 배열의 값이 0이라는 것만으로는 반복문을 들어가야 하는지, 그냥 지나쳐도 되는지 알 수 없다. 우선 반복문의 시작인 for문이 써있는 줄을 들어가 보고, 반복에 사용하는 변수가 반복 조건에 맞지 않는 것을 확인한 다음에 이후 실행할 코드로 넘어간다. 그러니 이 예시에서는 92번의 무의미한 반복문 방문이 생긴다.반면 인덱스를 누적하여 계산하고 그에 따라 새 배열에 원소를 삽입하면, 개수 배열의 어느 원소를 방문할지는 정렬해야 할 원래 배열의 원소에 따라 정해지기 때문에 개수 배열의 3번부터 94번 원소까지는 아예 건드릴 일이 없다. 이로써 92번의 무의미한 실행을 방지했다.(22.02.03 수정) 일단은 시간적 효율을 생각해서 저렇게 정렬하면 안 되는 것처럼 설명하긴 했지만, 시간을 좀 더 쓰는 대신 메모리가 아주 부족한 상황에서 정렬을 해야 한다면 저런 방법이 해결책이 될 수도 있다. 너무 정석에 얽매이지 말자..3. 선택 정렬요약 : 전체 배열에서 가장 작은 것을 골라 맨 앞에 앉히고 남은 배열을 다시 비교한다. 비교할 배열이 없을 때까지 반복한다.여기 아까 썼던 배열이 있다.ar = [ 3, 4, 2, 6, 8, 2, 9, 0, 4, 8, 7, 5, 2, 4, 0 ]이제 마치 맨땅에 헤딩하듯이 아래와 같은 과정을 수행할 것이다. 첫 번째 원소를 잡고 두 번째부터 끝까지 일일이 비교해가며 전체 배열에서 가장 작은 수를 찾는다. 검사가 끝나면 가장 작은 수와 첫 번째 원소의 자리를 바꾼다. 두 번째 원소를 잡고 세 번째부터 끝까지 일일이 비교해가며 전체 배열에서 가장 작은 수를 찾는다. 검사가 끝나면 가장 작은 수와 두 번째 원소의 자리를 바꾼다. 세 번째 원소를 잡고 네 번째부터 끝까지 일일이 비교해가며 전체 배열에서 가장 작은 수를 찾는다. 검사가 끝나면 가장 작은 수와 세 번째 원소의 자리를 바꾼다. (중략) 14번째 원소를 잡고 15번째부터 끝까지 비교한다만 15번째가 끝이니 둘 중 작은 수를 찾는다. 그리고 작은 수와 14번째 원소의 자리를 바꾼다. 정렬이 끝났다.카운팅 정렬에 비하면 비효율적이지만 아무튼 정렬은 되는 방법이다. 선택 정렬의 시간 복잡도는 O(n²)이다. 위의 예시대로 코드를 작성해, 서로 다른 두 원소를 비교하는 선택문 실행 횟수만 세어보면 105번이 나온다. 직접 세어보긴 했지만 이 횟수를 구하는 공식도 인터넷에 검색하면 금방 알 수 있다. 전체 원소 개수를 n이라고 할 때, n(n - 1)/2이다.4. 덤내가 왠지 할 수 있을 것만 같은 자신감이 들어서 첫 번째 예시의 배열을 선택 정렬로 정렬하는 코드와 같은 것을 카운팅 정렬로 정렬하는 코드를 모두 써보았다. 그리고 선택 정렬은 서로 다른 두 원소를 비교한 횟수를, 카운팅 정렬은 반복문의 총 실행 횟수를 세었다. 실행 결과 선택 정렬은 105번이 나왔고, 카운팅 정렬은 39번이 나왔다. 입력되는 값의 범위를 알아야 하고, 그 범위가 지나치게 크지 않아야 한다는 제약이 있지만 내가 다음에 풀게 될 문제를 해결하기엔 충분한 알고리즘이다. 백준 10989 수 정렬하기 3 문제다. 혹시 될까 해서 sort 함수(C++)를 써봤는데 역시나 틀렸었다. 소스 코드 링크를 올려둘 테니 직접 실행해보고 싶다면 복사해서 붙여넣어보자.[C++ 소스 코드] (1) 선택 정렬 (2) 카운팅 정렬[파이썬 소스 코드] (1) 선택 정렬 (2) 카운팅 정렬" }, { "title": "백트래킹", "url": "/satinbower-legacy/posts/it-backtracking/", "categories": "IT, Algorithm", "tags": "지식, IT, 백트래킹, 알고리즘, 재귀", "date": "2022-01-29 00:00:00 +0900", "snippet": "2580 스도쿠 미해결로 인해 풀이 대신 공부함문제 참고(출처 : 백준)15649 N과 M (1), 15650 N과 M (2), 15651 N과 M (3), 15652 N과 M (4) 9663 N-Queen, 2580 스도쿠목차- 재귀와 호출 스택 - 깊이 우선 탐색 - 백트래킹재귀와 호출 스택가볍게 “재귀”의 정의부터 읽어보고 시작하자. 출처는 네이버 사전이다. 재귀 再歸 원래의 자리로 되돌아가거나 되돌아옴. 주어진 문제를 해결하기 위하여 하나의 함수에서 자신을 다시 호출하여 작업을 수행하는 방식. 어떤 루틴이나 프러시저가 자기 자신을 반복적으로 호출하여 문제를 풀어 나가는 알고리즘으로, 이를 이용하기 위해서는 스택을 사용한다. 간단한 루틴을 풀 수 있지만, 처리 속도가 느리고 횟수가 지나치게 많으면 프로그램이 정지하기도 한다. 예상치 못하게 내가 할 설명을 네이버에게 뺏겼다. 하지만 저 말도 괜히 있어보이고 어렵게 생겼으니 내 특기인 없어보이지만 이해는 되는 말로 다시 설명하겠다.재귀, 또는 재귀 함수라고 해도 된다. 함수가 자기 자신 내에서 스스로를 다시 호출하면 그것을 재귀 함수라고 부른다. 가볍게 활용해볼만한 예시로는 팩토리얼, 피보나치 수 등이 있다. 사람의 말로 길게 설명하는 것보다 예시 하나 보고 한 줄 한 줄 뜯어보는 게 훨씬 이해가 빠를 테니 내가 쓴 코드부터 보자.문제 참고 : 백준 10872 팩토리얼 깃허브 : C++ 소스 코드 사용 언어 : C++ (파이썬과 자바는 아직 추가 계획이 없다)#include &lt;iostream&gt;using namespace std;int fac(int n); // 팩토리얼 함수int main(){ int n; cin &gt;&gt; n; cout &lt;&lt; fac(n); return 0;}int fac(int n){ if (n &lt;= 1) // n이 1보다 작거나 같다면 1을 반환한다. n이 0일 때도 포함한다, 0! = 1이다. return 1; else // n이 1보다 크다면 1이 될 때까지 (n - 1)로 다시 함수를 호출한다. return n * fac(n - 1);}main() 부분에서는 딱히 볼 것이 없다. 입력을 받고 함수를 호출해 반환된 값을 출력하는 것뿐이다. 봐야 할 것은 함수에 쓰인 코드이다. 함수 내부는 크게 둘로 나뉜다. 인자로 전달된 n이 1 이하인 경우와 1을 초과하는 경우.(1) n이 1 이하인 경우 이 함수의 의미는 전달받은 정수의 팩토리얼 값을 계산하는 것이기 때문에 그 숫자가 0이거나 1이라면 계산할 필요가 없다. 어차피 답은 1이고 새삼스럽게 더 곱한다고 뭔가 대단한 1이 되지도 않는다.(2) n이 1을 초과하는 경우 == n이 1보다 큰 경우 (1)의 경우와 달리 곱해야 할 수가 있는 상황이다. 하지만 지금 받은 수는 n 하나뿐이다. 이때 반복문을 쓰지 않고 할 수 있는 것이 재귀 호출이다. n을 알았다면 n보다 1 작은 수도 알 수 있다. 그러면 (n - 1)의 팩토리얼 값에 n을 곱하면 n!의 값을 알 수 있다. 다시 말해 n은 마지막에 숟가락만 얹을 테니 나머지 계산은 (n - 1)에게 미룬다는 것이다. n은 (n - 1)에게 계산을 미루고, 그 (n - 1)은 다음 호출에서 다시 n이 되어 또다른 (n - 1)에게 계산을 미룬다. 이 폭탄 돌리기의 현장에서 실제로 의미있는 값을 반환할 줄 아는 건 0과 1밖에 없다. 그러므로 재귀 호출은 n이 1보다 작거나 같아질 때까지 이어진다. 나는 이 값(1 또는 0)을 반환점이라고 부른다. 실제로 학계에서 의미가 있는 말인지는 모르겠다만, 내 편의상 그렇게 부르고 있다.내가 1을 반환점이라고 부르는 것은 이유가 있다. 지금까지 빚처럼 쌓여만 오던 함수 호출을 청산하기 시작하는 지점이기 때문이다. 계속 n이라고만 하면 헷갈리니까 가볍게 4!을 구한다고 생각하고 그 과정을 따라가 보자. 먼저 사용자는 4!의 값을 받기 위해 fac(4)를 호출한다. 함수 내부에서 4는 1보다 크기 때문에 else로 넘어가 4 * fac(3)을 반환한다. 이때 fac(3)의 값은 모르는 상태이기 때문에 프로그램은 결과를 반환하기 전에 fac(3)를 호출한다. fac(3)가 호출되었기 때문에 이번에도 else로 넘어간다. fac(3)은 3 * fac(2)를 반환하고 싶다. 하지만 fac(2)의 값을 모른다. 그러니 다시 호출한다. fac(2)는 2 * fac(1)을 반환하고 싶다. 하지만 fac(2)는 fac(1)의 값을 모른다. 재차 호출한다. fac(1)은 자신의 값을 안다. 1을 반환한다. 방금 호출이 왔던 2 * fac(1)로 돌아간다. 값을 알아냈으니 2 * 1인 2를 반환한다. 3 * fac(2)로 돌아간다. 3 * 2인 6을 반환한다. 4 * fac(3)으로 돌아간다. 4 * 6인 24를 반환한다. 이 값은 사용자에게 전달된다.줄줄이 이어지는 함수 호출은 n이 1이 되어서야 끝을 맺고 지금껏 지나온 모든 호출들을 청산했다. 이 과정까지는 이제 무슨 말인지 알 수 있다. 하지만 의문이 남는다. 함수가 한 차례 끝나기도 전에 다시 호출하면 이전의 값들은 어떻게 알고 그 값을 그대로 되돌려주는가?혹시 모르니 스택에 대해 잠깐 알아보고 가자. 이 글의 주요 개념은 아니니 깊이 알 건 없고, 프링글스 통이라고 생각하면 된다. 감자칩이 약간의 틈을 두고 켜켜이 쌓인 프링글스 통의 과자를 먹으려면 위에서부터 하나씩 집어먹어야 한다. 맨 아래에 있는 과자를 먼저 꺼내먹으라고 만든 구조는 당연히 아니다. 스택도 이와 비슷하다. 어떤 값들이 차례로 저장되어 들어오고, 사용자는 필요할 때 그것을 다시 꺼내 쓴다. 이때 마지막으로 들어온 데이터가 가장 먼저 꺼내진다. 지금 알아야 할 스택의 개념은 이 정도면 됐다. 앞으로 설명할 호출 스택이란 프로그램을 실행하면서 쌓인 함수 호출 등을 저장하는 스택인 것이다.(이 문단의 내용은 내가 어떠한 자료를 참고하여 공부한 것이 아니고 디버깅 중 호출 스택을 보며 알아낸 것이기 때문에 부족하거나 부적절한 내용이 있을 수 있다. 만약 있다면 알려주길 바란다.) 함수의 호출은 우리가 생각하는 것처럼 단편적이거나 평면적인 과정이 아니다. 모든 완료되지 않은 호출은 ‘호출 스택’이라는 것에 저장된다. 컴파일러마다 화면이 다르니 정확히 어디서 확인할 수 있는지는 알려줄 수 없다. 대신 내가 쓰는 비주얼 스튜디오 화면[이미지 1]을 보여줄 테니 참고하자. 캡쳐한 시점은 입력 값으로 4를 입력해 fac(4)가 호출되고 재귀를 거쳐 fac(1)에서 1이 반환되기 직전이다. 빨간 선으로 조금 구겨진 네모가 쳐진 곳이 호출 스택이 나타나는 부분이다. 호출 스택에 보이는 것은 호출이 온 줄의 번호 뿐이지만 호출된 순간의 변수 상태도 같이 저장된다. 그렇기 때문에 함수 내에서 자기 자신을 재차 호출해도 앞선 호출에 저장된 값을 덮어쓰지 않는다. 나는 이걸 몰라서 재귀함수에 대해 한참을 이해하지 못하고 있었다. [이미지 1] 재귀 함수 fac(4) 호출 스택- 깊이 우선 탐색백트래킹에 대해 배우려면 먼저 깊이 우선 탐색이라는 것을 알아야 한다. 이것도 개념만 놓고 본다면 그리 어렵지 않다. 가볍게 ‘탐색’에 대해서부터 알아보자. 어떠한 알고리즘을 이용해 원하는 값을 찾는 것과 그 방법 등을 크게 일러 탐색이라고 한다. 그 종류는 꽤나 다양한데 단순히 원하는 값이 나올 때까지 모든 값을 하나씩 까보는 방법도 있고, 여러 갈래로 갈라지는 분기를 하나씩 들러 찾아보는 방법도 있다. 이중 깊이 우선 탐색은 여러 갈래로 갈라지는 분기를 앞에서부터 하나씩, 끝까지 가보고 원하는 값인지 아닌지 판단하는 방법이다. 자매품으로 너비 우선 탐색이 있는데, 이 방법은 갈 수 있는 분기를 모두 하나씩 들러보면서 내려간다. 둘 모두 주로 트리나 그래프라는 자료구조에서 활용한다. 그래프라는 것은 수학에서 사용하는 x 축과 y 축이 있는 그것은 아니고, 쾨니히스베르크의 다리를 검색하면 나오는 이미지 같은 것을 말한다.깊이 우선 탐색에 대해 조금 더 알아보자. 한빛 아카데미 출판, &lt;소프트웨어 세상을 여는 컴퓨터 과학&gt;에 의하면 깊이 우선 탐색은 “시작 정점에서 시작하여 그 정점과 연결된 방문하지 않은 한 정점을 방문하고, 다음에는 방문한 정점에서 다시 연결된 방문하지 않은 한 정점 순으로 방문한다. 진행하다가 더 이상 진행할 수 없으면 왔던 길을 되돌아가면서 아직 방문하지 않은 한 정점을 방문한다.”라고 한다.예를 들어 보자. 여기 1부터 3까지의 자연수가 있다. 사용자는 중복 없이 사전 순으로 이 수들을 두 개씩 뽑아 짝을 짓고 싶다. 이때 사용할 수 있는 방법이 깊이 우선 탐색이고, 여기에 백트래킹도 포함된다. 일단은 깊이 우선 탐색만 생각해보자. 가장 먼저 1을 하나 뽑는다. 1의 짝으로 올 수 있는 숫자는 2, 3이 있다. 먼저 2를 뽑아 하나의 짝을 완성한다. → (1, 2) 다시 1을 하나 뽑는다. 이번에 1의 짝으로 올 수 있는 숫자는 3뿐이다. → (1, 3) 1로 만들 수 있는 짝은 다 만들었으니 이번에는 2를 뽑는다. 2의 짝으로 올 수 있는 숫자는 1과 3이다. 1을 먼저 뽑는다. → (2, 1) 이후의 과정은 생략한다. → (2, 3), (3, 1), (3, 2)간단하고 빠른 설명을 위해 소박한 예시를 들어 깊이라는 말이 잘 체감되지 않을 수 있다. 좀 더 예시가 필요하다면 위의 예시에서 숫자를 더 크게 잡아보거나 스스로 그럴싸한 예시를 고민해 보자. 직접 문제를 만들어보는 것도 공부에 도움된다.- 백트래킹백트래킹은 깊이 우선 탐색의 개정판 같은 것이다. 앞서 알아본 깊이 우선 탐색은 답을 찾기 위해 전진만 할 줄 알았지, 지금 가는 길이 답이 아니라는 것을 알았을 때 되돌아갈 줄은 몰랐다. 백트래킹은 깊이 우선 탐색이 뒷걸음질을 치게 만드는 알고리즘이다. 참고할만한 문제는 글의 서두에 적어두었으니 다른 사람의 풀이를 찾아봐도 좋고 혼자 도전해도 좋으니 한번 풀어보자. 나도 보고 배웠으니 여기서 풀이할 마음 없다.비교하기 좋게 예시를 재활용하자. 숫자가 너무 적으면 결과도 적으니 이번엔 1부터 4까지의 자연수를 중복 없이, 오름차순으로 2개씩 뽑아보겠다. 당연히 사전순으로 뽑는다. 1을 뽑는다. 1의 짝으로 올 수 있는 수는 2, 3, 4이다. 2를 먼저 뽑는다. → (1, 2) 뽑았던 2를 도로 내려놓고 다른 수를 뽑는다. 남은 것은 3과 4이니 3을 뽑는다. → (1, 3) 3을 도로 내려놓고 다른 수를 뽑는다. 4가 남았다. → (1, 4) 4를 내려놓고 나니 1의 짝으로 남은 수가 없다. 1도 내려놓는다. 1은 끝났으니 2를 뽑는다. 1은 2보다 작으니 치워놓고, 2의 짝으로 가능한 수는 3, 4이다. 3을 뽑는다. → (2, 3) 3을 내려놓고 남은 수는 4이다. → (2, 4) 4를 내려놓고 나면 남은 수가 없다. 2도 내려놓는다. 이하 생략 → (3, 4)이 알고리즘에서 핵심적인 역할을 하는 것이 재귀 호출이다. 숫자 하나를 뽑아 놓은 상태에서 숫자를 뽑는 함수를 재차 호출해 다음 수를 뽑는다. 뽑기가 끝나면 결과를 출력하고 뽑은 수를 돌려놓는다. 호출이 끝나 돌아올 때는 해당 줄로 똑같이 되돌아와서 그 다음 줄을 바로 실행하기 때문에 재귀 호출이 있는 부분 위에서는 수를 뽑고, 재귀 호출 아래에서 뽑은 수를 돌려놓는 코드를 쓰면 위와 같은 과정이 가능하다. 문제를 풀이할 생각은 없다고 했지만 아무래도 예시가 없으면 아쉬우니 조금만 보자. 15650 N과 M (2) 문제에 사용한 함수이다.사용 언어 : C++, 파이썬 파이썬 코드 : [파이썬 소스 코드] [C++ 소스 코드 일부]void pr(int n, int m) // n개의 수 중에서 중복 없이 오름차순으로 m개의 수를 뽑음{ if (v.size() == m) // 필요한 만큼 수를 뽑았을 때 실행 { // 뽑은 수를 출력한다. for (int i = 0; i &lt; v.size(); i++) cout &lt;&lt; v[i] &lt;&lt; \" \"; cout &lt;&lt; \"\\n\"; return; // 실행이 끝나고 이전 호출로 되돌아간다. } // 아직 수를 충분히 뽑지 못했을 때 for (int i = 0; i &lt; n; i++) // 숫자의 총 개수만큼 반복 : 첫 번째 숫자부터 끝까지 하나씩 조건에 맞는지 시도해본다 { if (nvi[i] || (i + 1) &lt; idx) // 이미 뽑은 숫자이거나 직전에 뽑은 숫자보다 작은 숫자일 경우 continue; // 숫자를 뽑지 않고 넘긴다 v.push_back(i + 1); // 넘기지 않았다면 숫자를 뽑는다. idx = i + 1; // 오름차순으로 하기 위해 지금 뽑은 숫자를 기록한다. nvi[i] = 1; // 중복 방지를 위해 뽑았다는 것도 표시해 둔다. pr(n, m); // 재귀 호출 v.pop_back(); // 호출에서 되돌아왔을 때 실행한다. 뽑은 숫자를 하나 버린다. idx = 0; // 기록한 숫자를 지운다. nvi[i] = 0; // 뽑았다는 표시도 지운다. }}내가 이 알고리즘이 어려웠던 이유는 재귀호출 이후 되돌아올 때 이전의 변수 상태까지 같이 되돌아간다는 것을 알지 못했기 때문이었다. 지금은 그건 알지만 그냥 문제가 어렵다.. 이론을 아는 것과 활용이 되는 건 꽤 다른 문제다.숫자 뽑기 예시에서는 뽑아둔 숫자를 다 사용한 후 다시 버리기 위해 재귀 호출 뒤의 코드에 숫자를 지우는 부분이 들어갔지만 굳이 그런 과정이 필요 없는 경우에는 return;을 쓰기도 한다. 그리고 재귀를 설명할 때 내가 “반환점”을 언급한 적이 있는데, 꼭 모든 재귀 함수와 백트래킹이 반환점을 돌아서 가지는 않는다. 일례로 9663 N-Queen 문제는 함수에 전달하는 첫 인자로 0을 넘긴다고 풀이한다. n에서부터 0까지 가는 과정이 필요하지 않기 때문에 하지 않는 것이라고 본다. 2580 스도쿠 문제도 비슷하게 시작하지만, 아직까지는 그 풀이를 이해하지 못하기도 했고, 내가 쓴 풀이에 미련이 남아 더이상 진행할 수가 없다. 내 풀이를 잊을 때까지 시간이 좀 필요하다..참고 도서 &lt;소프트웨어 세상을 여는 컴퓨터 과학&gt;, 김종훈 지음, 한빛 아카데미 출판" }, { "title": "자 내가 자바를 공부한다", "url": "/satinbower-legacy/posts/it-java-study/", "categories": "IT, java", "tags": "지식, IT", "date": "2021-11-22 00:00:00 +0900", "snippet": "오늘 공부할 내용은 객체와 클래스야 키보드를 가지고 설명할 거니까 어디 한번 들어나 보시라구요일단 객체란 무엇이냐. 영어로는 object, 넓게 보면 세상 모든 사물이 객체야. 나도 객체고 우리집 고양이도 객체고 내 키보드도 객체지. 다들 각자 고유한 특성과 행동이 있어. 나는 말을 하고 고양이는 털갈이를 하고 키보드는 wasd를 눌러. 자바에서는 이 개념이 프로그램에 적용된다는 거야.잠깐 빠져나와서 캡슐화라는 것도 알아보자. 캡슐약 알지? 먹으면 왠지 목에 걸린 것만 같은 그 약의 속을 까본 사람들도 아마 있을 거야. 캡슐약에 캡슐은 안에 있는 약을 담아두기 위해 있어. 그게 있는 한 우리는 캡슐약 안에 약가루가 들었는지 밀가루가 들었는지 알 수 없어. 그리고 가루가 수분과 닿아 변질되는 것도 막아주지. 이런 식으로 외부와 단절된 ‘커버’를 만들어 씌우는 게 캡슐화야. 키보드를 쓸 때는 자판을 누르지 그 안에 어떤 부품이 있는지 굳이 신경쓰지 않잖아. 키보드가 하나의 객체고 자판이 그 객체를 감싼 캡슐이 될 수 있어.이건 좀 다른 얘기이긴 한데 나는 저 캡슐화가 추상화랑도 연관이 있다고 생각해. 추상화는 복잡한 것을 단순하게 보이게 만드는 거야. 게임이 어떤 소스코드로 만들어졌는지는 개발자만 알면 되고 플레이어는 내 캐릭터만 잘 움직이면 그만이잖아? 이럴 때 플레이어를 위해 소스코드는 보이지 않고, 게임의 화면이 보이고 조작도 쉽게 할 수 있도록 하는 게 추상화야. w를 누르면 앞으로 간다, 라고 하는 건 플레이어에게 보이는 추상화된 프로그램이고 개발자는 이걸 코드로 써둔 거지. 잘 전달이 됐을까 모르겠네 이건 원래 설명하려던 내용은 아니니까 여기서 끊자.지금까지 객체와 캡슐화(+추상화)에 대해 설명했어. 이번엔 클래스에 대해 말할 거야.클래스는 객체의 모양을 정한 틀이야. 키보드가 키보드 모양인 건 만드는 사람이 그렇게 정하고 틀을 만든 거지? 키보드의 틀(클래스)대로 만들어진 실제 상품이 키보드(객체)인 거야. 자바에서는 여기에 ‘필드‘와 ‘메소드‘라는 것이 들어가는데, 이건 각각 키보드 자판 하나하나의 이름과 그 자판들로 누르는 단축키가 수행하는 기능이라고 생각하면 돼. 예를 들어, 엔터키는 게임에서 주로 확인키로 사용되지? Enter라는 이름이 필드고 이걸 눌렀을 때 확인키로 작동하는 게 메소드야. 메소드는 파이썬이나 C++에서는 함수라고 불러. 난 파이썬을 가장 먼저 배워서 함수라는 말이 더 이해하기 쉬웠어.여기서 다시 캡슐화가 등장해. 키보드에 키캡이 다 끼워진 상태에서는 내부를 볼 수 없고 손 댈 수도 없지? 이 키캡이 키보드의 캡슐화인 거야. 키캡은 사용자가 직접 분해할 수 있지만 이건 예시이고 비유일 뿐이니까 거기까지는 생각하지 말자.사실 내가 공부한 객체와 클래스에 대한 설명은 이게 끝이야. 근데 아직 공부할 게 남아서 조금만 더 설명할게. 이번엔 상속이라는 거야. 어렵지 않으니까 봐봐.상속은 &lt;상속자들&gt;의 그 상속이야. 사전적 정의는 그렇다고. 어떤 방식인지 설명하기 전에, 생물의 분류에 대해서는 알고 있어? ‘동물 &gt;&gt; 포유류 &gt;&gt; 사람’ 이런 분류 말이야. 상속은 이렇게 연결되는 여러 개체 사이에서 적용되는 거야. 저 예시로 설명해볼게.(1) 동물은 종속영양생물*이야. 뜻은 몰라도 되고(각주 추가했어) 동물이 갖는 특징이라고만 생각하면 돼. (2) 포유류는 새끼에게 젖을 먹이는 동물이야. (3) 사람은 언어를 사용해. 이 세 가지 사실(1 ~ 3)을 놓고 상속관계를 생각해보자. 일단 동물이 이 중에서 가장 큰 범주에 있지? 그러니까 동물은 나머지 둘보다 상위 개체야. 포유류는 “동물이고 포유류”인 거니까 동물의 특성도 함께 가져. 이때 포유류가 동물의 하위 개체야. 하위 개체는 상위 개체의 특성도 모두 가져. 하지만 사람에 대해서는 상위 개체가 되기 때문에 사람의 특성은 갖지 않아. 사람은 셋 중 가장 하위에 있는 개체야. 그러므로 내가 서술한 세 가지 특성을 모두 가져. 이렇게 특성이 위에서 아래로 내려가는 걸 상속이라고 하는 거야. 자바에서도 클래스로 이런 관계를 구현할 수 있어.다형성까지만 설명하고 끝낼게. 사람이라고 해서 모든 사람이 똑같지는 않지? ‘사람’이라는 클래스에 속하면서도 각자 가진 이름이 다르고 할 수 있는 것도 다를 거야. 홍길동과 고길동이라는 사람에 대해 생각해보자. 홍길동은 ‘사람’ 클래스에 속하고 아마도 조선시대의 한국어를 했겠지? 이 ‘한국어‘가 홍길동이 갖는 메소드이고 그 구현 방식은 ver.조선시대라고 할 수 있어. 고길동은 ‘사람’ 클래스에 속하고 현대의 ‘한국어‘를 해. 고길동도 ‘한국어’라는 메소드를 갖지만 구현은 ver.현대로 된 거야. 여기서 메소드는 똑같이 ‘한국어’인데 그게 조선시대 말과 현대의 말로 다르게 구현된 게 다형성이야. 같은 메소드가 클래스나 객체에 따라 다르게 작동하고 나타나는 거야. 내가 설명할 수 있는 건 여기까지. 남은 공부 하러 갈게… 다음 기회에 또 보자구요.* 종속영양생물 : 스스로 영양소를 만들지 못하고 외부로부터 흡수하는 생물참고문헌 - 황기태, 명품 자바 에센셜, 경기: 생능출판사, 2014.교수님보다 잘 가르쳐 관심 있고 돈도 있으면 사봐사담 : 설명을 약간 수정하고 다듬었음. 내가 요새 또 자바가 많이 어려워서.. 이거라도 봐야겠더라고..원본 : 내 트위터(삭제됨) https://twitter.com/dapin1490/status/1448508851108544515?s=20" }, { "title": "딥러닝의 탄생과 활용", "url": "/satinbower-legacy/posts/it-deep-learning/", "categories": "IT, Machine Learning", "tags": "지식, IT, 딥러닝", "date": "2021-11-22 00:00:00 +0900", "snippet": "게임과 인공지능* 대학 과제로 작성된 글이며, IT 계열 전공 1학년생 수준으로 쓰였음을 알림.목차1. 서론2-1. 인공지능2-2. 딥러닝3. 게임과 인공지능1. 서론코로나19의 영향으로 비대면 콘텐츠가 나날이 늘어나고 있는 요즘, 많은 이들이 한 번쯤 게임을 즐겨본 적이 있을 것이다. 게임은 RPG, 액션, 퍼즐 등 다양한 장르에 걸쳐 있으며 실제 시장에 출시된 작품은 셀 수조차 없이 많다. 이 중에는 인공지능이 사용되는 부분도 있다. 이 글에서는 게임에 사용된 인공지능과 딥러닝 사례를 통해 인공지능에 대해 알아보며 딥러닝이란 무엇인지 소개할 것이다.2-1. 인공지능인공지능이란 간단히는 컴퓨터나 다른 도구를 사용하여 인위적으로 만든 지능, 조금 다르게 말하자면 지금 이 순간 사람이 잘하는 것을 컴퓨터가 할 수 있도록 하는 연구와 그 결과물을 말한다. 영어로는 Artificial Intelligence라고 하며 보통 AI라고 부른다. 말 그대로 인공적인 지능인 만큼 인공지능은 지능적인 행동을 할 것을 기대받는데, 이때 지능적인 행동은 인지, 추론, 학습, 의사소통, 복합적인 상황에서 행동하기 등을 말한다. 언젠가는 단지 지능적인 행동을 넘어 사람만큼, 혹은 사람보다 주어진 일을 잘하고 행동을 이해하는 인공지능을 만드는 것이 인공지능 연구의 목표이다.인공지능은 몇 가지 기준에 따라 여러 가지로 분류할 수 있다. 이 글에서는 기호 기반 AI와 비기호 AI에 대해 알아보도록 하겠다. 우선 기호 기반 AI는 고전적인 AI로 사전 지식과 대전제에 기반한 논리와 미리 설계된 행동을 바탕으로 한다. 사람이 지식을 넣어주지 않으면 지능적인 행동을 할 수 없다. 또한 기호 기반 AI의 지식 접근 방식은 탑다운(top-down)이라고 하는데, 어떠한 대전제로부터 하위의 것을 이끌어내는 방식이다. 지식을 인간의 문장 수준으로 입력하고, 그것을 LISP이라는 언어로 리스트로 만들어 기호처리를 함으로써 이루어진다.비기호 AI는 기호 기반 AI에 비해 비교적 현대적인 AI이다. 지능적 행동은 기호적 과정이 아니라 비기호적 처리의 결과로 나타나는 것이라는 입장을 갖는다. 생물체의 지능 작용을 모방하여 만든 신경망이 여기에 속하며 생물학적 AI라고도 한다. 지식에 대한 접근 방식도 기호 기반 AI와 상반되게 나타나는데, 인간이 완성된 지식을 제공하지 않고 AI가 학습하게 하며 개별적 경험으로부터 일반화된 개념을 찾는 바텀업(bottom-up) 방식을 취한다. 이를 통해 인간이 설계하지 않은 행위가 나타나도록 한다. 이것을 창발 행위라고 한다. 비기호 AI는 가장 낮은 수준의 지식으로 기호 대신 신호를 사용한다.앞선 설명만으로 보면 기호 기반 AI보다 비기호 AI(이후 생물학적 AI라고 칭한다)가 훨씬 좋은 것으로 보일 수 있다. 그러나 둘은 방식이 다를 뿐 어느 하나가 정답은 아니라는 것을 두 AI의 역사를 간단히 짚어보며 알아보도록 하겠다.먼저 기호 기반 AI의 역사부터 살펴보자. 우리가 지금 익숙하게 부르고 있는 인공지능(Artificial Intelligence)이라는 말은 1956년 기호 기반 AI 측에서 만들어졌다. 위에서 언급한 LISP이라는 프로그래밍 언어도 1958년에 만들어졌으며 이외에 PROLOG(1970)라는 언어도 있다. 주요한 업적 중 하나는 1973년 MYCIN이라는 전문가 시스템을 만든 것인데, 전문가 시스템이란 특정 분야에 대해서만은 사람보다 뛰어난 인공지능을 만들자는 취지에 따라 개발된 인공지능의 일종이다. MYCIN은 감염성 질병을 진단하고, 항생제를 처방하고, 그 추론을 자세히 설명할 수 있는 대화형 프로그램인데, 제한된 테스트에서는 그 성능이 전문의 수준과 같았다고 한다. 1982년부터 1992년까지는 5세대 컴퓨터 시스템 프로젝트를 시도했다. 유감스럽게도 성공하지 못하였고 현재의 컴퓨터는 4세대이다. 1994년에는 지능형 에이전트 연구가 있었다. 지능형 에이전트란 주어진 환경 내에서 어느 정도 자율적으로 위임자를 대신하여 능동적으로 임무를 수행할 수 있는 지능형 프로그램을 말한다. 누군가를 위해 어떠한 일을 대신 한다는 점이 전문가 시스템과 비슷하지만 전문가 시스템보다 좀 더 보편적이고 낮은 수준의 일을 하도록 만들어졌다. 그러나 같은 프로그램으로도 사용자에 따라 다른 일을 할 수 있고 환경이 변화하면 그에 따라 행동도 같이 변화할 수 있다는 특징이 있다.다음은 생물학적 AI의 역사이다. 1943년에 맥클로피츠의 ‘뉴런’이라는 말이 처음 나왔다. 이어 1959년 퍼셉트론이라는 개념이 등장했고 여기까지가 신경망의 아주 기초적인 부분이다. 이후로 한동안 생물학적 AI 분야에서는 이 인공지능으로 일기예보도 가능할 것이라 생각하였으나 성과는 그리 좋지 못하였다. 1975년에는 유전자 알고리즘이 개발되었다. 유전자 알고리즘은 생물의 유전과 진화 메커니즘을 공학적으로 모델화하여 문제 해결이나 시스템의 학습 등에 응용하려고 한 것으로, 풀어야 할 문제의 해를 특정한 자료구조로 표현한 후 조금씩 변형하여 더 좋은 해를 만들어내는 방식이다. 1986년에는 연결주의가 등장했다. 연결주의는 인공 신경망을 이용하여 심리적 현상이나 기제를 과학적 절차로 구체적으로 구현하는 인지 과학 분야의 접근법이다. 사전 지식을 전혀 주지 않은 ‘백지’ 상태로 경험을 통해 학습하는 것이 특징이다.2-2. 딥러닝딥러닝에 관해 설명하기에 앞서 머신러닝이란 무엇인지 간단히 알아보겠다. 머신러닝은 AI의 하위 분야 중 하나인데, 여러 개의 예시 데이터에서 일반적인 규칙을 찾아내는 자동화된 절차로 구성된다. 이를 예시 데이터로부터 규칙을 학습했다고 말한다. 학습 방식은 예제와 답을 모두 주는 지도 학습과 답은 가르쳐주지 않고 예제만 제공하는 비지도 학습이 있다. 이 과정을 인공 신경망을 사용하여 수행하는 것이 딥러닝이다.인공 신경망은 생물체의 신경망을 모방한 것으로 인공 뉴런들의 결합으로 만들어진 네트워크가 학습을 통해 결합의 세기를 바꾸어 문제 해결 능력을 갖는 모델 전반을 가리키는 말이지만, 이 글에서는 퍼셉트론을 이용한 모델을 중심으로 알아볼 것이다.인공 신경망과 딥러닝은 1943년 맥클로와 피츠가 만든 계산학 모델을 그 시점으로 한다. 1954년 MIT에서 팔리와 웨슬리 클라크가 이 모델을 처음으로 사용하였다. 1958년에는 로젠블라트가 퍼셉트론을 만들었다. 다만 이 당시에는 단층 퍼셉트론을 사용하였기 때문에 XOR 연산은 불가하였다. 1969년 발표된 민스키와 페퍼트의 논문으로 인해 한동안 신경망 연구가 침체되었으나 1975년 오차 역전파 알고리즘이 만들어지고 그동안 기술의 발전으로 컴퓨터의 성능이 좋아지면서 그 세(勢)가 회복되었다. 1980년대 중반에는 연결주의가 각광을 받았다. 2000년대 딥러닝이 출현하면서 역사는 지금에 이르렀다.딥러닝에 사용되는 신경망 구조는 다양하다. 인공지능 수업에서 배운 다층 퍼셉트론을 이용한 신경망도 그중 하나이다. 이 글에서는 심층 신경망과 합성곱 신경망, 순환 신경망에 대해 알아볼 것이다.우선 심층 신경망은 입력층과 출력층 사이에 여러 개의 은닉층을 갖는 다층 퍼셉트론으로 이루어진 신경망이며 후에 서술할 다른 신경망의 바탕이 된다. 학습은 오류 역전파 알고리즘으로 한다. 이 알고리즘은 입력값과 출력값을 이미 알고 있는 상태에서 사용한다. 신경망에 사용된 각각의 노드를 모두 퍼셉트론으로 간주하고, 초기 가중치는 무작위로 주어진다. 각 노드에서 활성함수를 거쳐 나온 값은 다음 노드의 입력값이 되며 활성함수는 주로 시그모이드 함수를 쓴다. 신경망을 거쳐 나온 결과값과 사용자가 원하는 값 사이의 오차를 구해 이것을 0에 근사시키는 것이 목표이다. 이를 위해 경사 하강법을 쓴다. 경사 하강법은 오차 함수의 기울기가 0이 되는 쪽으로 가중치를 조정하는 방법이다. 다만 이 방법은 항상 전역 최솟값을 구하지는 못한다는 단점이 있다. 전역 최솟값이 아닌 극솟값이라도 마찬가지로 기울기는 0이기 때문에 알고리즘은 이를 구분할 수 없다.합성곱 신경망은 주로 시각적 영상을 분석하는 데 사용되는 심층 신경망의 일종이다. 크게 합성곱 층(Convolution layer)과 풀링 층(Pooling layer)으로 구성된다. 합성곱 층에서는 처리해야 할 이미지에 대해서 합성곱 연산이라는 것을 하는데, 커널이라는 n*m 크기의 행렬로 높이와 너비가 a*b인 이미지를 훑으면서 커널과 겹치는 부분의 이미지와 커널 원소 값을 곱해서 모두 더한 값을 출력으로 하는 연산이다. 이미지의 좌상단부터 시작해 오른쪽으로 우하단까지 진행한다. 커널은 보통 3*3 또는 5*5를 쓴다. 이 연산을 통해 나온 결과를 특성 맵이라고 부른다. 물론 커널의 크기도, 커널이 이동할 범위도 사용자가 직접 정할 수 있으나 이 글에서는 3*3 커널을 한 칸씩 움직이는 경우를 기준으로 설명하겠다. 앞서 설명한 바와 같이 합성곱 연산을 거치고 나면 이미지의 크기가 작아질 수밖에 없게 되는데 이를 방지하기 위해 패딩(padding)을 사용할 수 있다. 입력에 사용될 이미지의 가장자리에 사용할 커널의 크기에 맞게 테두리를 추가하는 것이다. 주로 0으로 채워 넣는 제로 패딩을 사용한다. 3*3 커널을 한 칸씩 움직이는 경우에는 패딩 또한 한 칸만 추가하면 된다. 심층 신경망으로 이 연산을 수행할 때에는 입력 이미지가 입력층이 되고 커널이 가중치, 특성 맵이 결과값이 된다.풀링 층에서는 합성곱 층에서 나온 특성 맵을 다운샘플링하여 특성 맵의 크기를 줄이는 연산이 수행된다. 그 방식은 보통 최대 풀링과 평균 풀링 두 가지가 있다. 풀링에서도 합성곱 연산과 마찬가지로 커널을 갖는데, 특성 맵에서 커널 만큼의 영역 중 최댓값을 찾아 출력한다면 최대 풀링, 평균값을 계산하여 출력한다면 평균 풀링이 된다. 풀링 연산에서 가중치는 없다.순환 신경망은 입력과 출력을 시퀀스(Sequence) 단위로 처리하는 모델이다. 시퀀스 모델은 여러 가지가 있으나 이 글에서는 RNN(Recurrent Neural Network)에 관해 설명하겠다. 이전까지 설명한 신경망 모델들은 모두 입력과 출력이 하나의 방향으로만 진행되었다. 이를 피드 포워드(Feed Forward)라고 한다. 순환 신경망은 이와 달리 자신의 출력을 결과 방향으로 보내는 동시에 노드에 저장해 두었다가 다시 자신의 입력으로 사용한다. 이렇게 자신의 값을 기억하는 노드를 메모리 셀이라고 부르며 기억한 값은 은닉 상태(hidden state)라고 하고 이 때문에 입력값에 대해 한 개, 은닉 상태에 대해 한 개씩 총 두 개의 가중치를 갖는다. 또한 이 모델에서는 그 특성상 시점(t)의 구분이 있다. 이 모델을 나타내는 모식도는 아래와 같다. x는 입력, y는 출력이며 편향은 생략되었다. [그림 1] 순환 신경망 모식도[그림 1]에서 초록색 셀이 메모리 셀이며 그 위에 그려진 자신의 셀에서 나와 되돌아가는 화살표가 은닉 상태를 나타낸다. 이 모델은 입력과 출력의 길이를 다르게 설계해 다양한 용도로 사용할 수 있다. 예를 들어 여러 개의 입력에 대해 하나의 출력을 내는 경우 문서의 긍정/부정 판별 또는 스팸 메일 판별을 수행하게 할 수 있고, 하나의 입력에 대해 여러 개의 출력을 내는 경우 하나의 이미지 입력에 대해 그것의 제목을 출력하도록 할 수 있다.3. 게임과 인공지능이제 인공지능이 실제로 활용된 사례를 보도록 하겠다. 이 글에서 소개할 사례는 크게 네 가지로 각각 넷마블의 콜럼버스 프로젝트와 마젤란 프로젝트, 구글의 게임 플레이 테스트용 인공지능, 엔씨소프트의 게임 &lt;블레이드 &amp; 소울&gt;의 ‘무한의 탑’ 던전에 사용된 비무 AI이다. 글의 말미에는 게임 이외에도 대중에게 잘 알려진 성공 사례에 대해 알아보겠다.넷마블 콜럼버스 프로젝트는 넷마블의 글로벌 이용자 데이터를 기반으로 하는 AI 프로젝트이다. 프로젝트의 목표는 게임 내 이용자의 유입부터 이탈까지 그 생애 구간에 대한 분석과 관리를 통해 게임 PLC(Product Life Cycle, 제품 수명 주기) 개선을 이루어내는 것이다. 특히 이상징후 탐지를 진행하는데, 이것은 게임 로그를 딥러닝 알고리즘으로 학습해 게임 내에서 발생한 이상 상황을 빠르게 탐지하고 그것을 자동으로 담당자에게 보고하는 시스템이다. 탐지된 이상 상황은 시뮬레이션으로 재현되어 실제로 가능한 플레이인지, 게임 시스템을 악용하여 불법적인 이득을 취하는 어뷰징인지 시스템이 자동으로 검증한다. 2020년 기준 넷마블은 이 시스템을 다양한 악용 사례 및 핵 프로그램 확산 방지, 게임의 안정적인 운영과 게임 지표 왜곡 방지 등에 활용하고 있다. 넷마블 측에서는 이 기술을 적용하고 어뷰징 탐지율이 최대 10배 가까이 높아졌다고 하였다. 게임은 많은 사람이 상호작용하며 여러 가지 일이 발생할 수 있는 매체인 만큼, 부적절한 방식으로 게임을 플레이하는 사람을 훨씬 빠르고 정확하게 찾아낼 수 있는 이 기술은 앞으로도 게임 운영에 적잖은 도움이 될 수 있으리라 생각한다. 더불어 이상 상황을 탐지하며 얻은 데이터는 플레이어들의 이용 경향을 파악하고 추후 콘텐츠를 기획하는 데에도 참고가 될 것으로 보인다.콜럼버스 프로젝트가 이미 만들어진 게임의 운영에 도움을 주었다면 마젤란 프로젝트는 게임의 유지/보수와 업데이트를 맡았다. 이 프로젝트는 지능형 게임을 만드는 데 중점을 두었다고 하는데, 여기서 지능형 게임이란 AI 플레이어가 인간 플레이어의 패턴을 학습해 지속적으로 재미 요소를 제공하는 것을 말한다. 이를 통해 게임 몰입도 향상 효과를 얻을 수 있다. AI 플레이어는 또한 게임 밸런스 조정과 QA(Quality Assurance) 등 관련 업무에 도움을 준다. 넷마블은 이 프로젝트를 통해 게임 테스트 자동화 시스템을 도입했다. 그 효과로 버그 발견 확률이 높아지고, 수정 후 테스트 작업에서도 속도가 최대 40% 개선되었다고 한다. 이 기술은 콘텐츠 제작 비용 감소와 제작 기간 단축 등에도 유용하였으며 보스 및 던전 난이도 측정에도 활용한다고 한다. 넷마블은 2020년 기준 서비스 중인 일부 게임에 이 기술을 적용하고 있다.게임을 해봤다면 버그에 대해서도 들어본 바가 있을 것이다. 개발자와 플레이어 모두에게 버그는 대부분 골칫덩이라는 건 당연한 사실이다. 여기 그런 개발자를 위한 AI가 있다. 구글 AI 연구팀이 오픈소스로 배포한 비디오 게임 개발 테스트용 AI 솔루션이다. 이전에도 AI는 종종 게임 테스트에 활용되곤 했지만 보통 강화학습 알고리즘을 사용했고, 이는 많은 데이터를 필요로 하고 개발자에게 높은 수준의 머신러닝 지식을 요구한다는 단점이 있었다. 하지만 구글에서 배포한 이 AI는 모방학습 알고리즘을 사용하여, 개발자가 머신러닝에 대한 전문지식이 부족하더라도 단지 스스로 게임을 플레이해 보이는 것만으로 문제점을 찾을 수 있다. 이것을 이용하여 개발자는 인간 테스터가 좀 더 복잡하고 어려운 문제에 집중하도록 도울 수 있다. 지원되는 장르는 아케이드, 액션/어드벤처 및 레이싱 게임이다. 이 사례는 앞서 언급한 것들과 달리 오픈소스로 배포되어 활용성이 상당히 높다. 마젤란 프로젝트와 그 기능이 비슷하지만 범용성이 높고 사용이 용이하다는 점에서 앞으로도 많은 개발자들이 이용할 것으로 보인다.&lt;블레이드 &amp; 소울&gt;(이하 블소라고 칭한다)은 2012년 서비스를 시작한 엔씨소프트의 게임이다. 동양 판타지를 시작으로 하여 중세 서양 판타지로 나아가는 세계관을 그 특징으로 한다. 그 장르가 RPG인 만큼 던전은 빠질 수 없는 요소인데, 이 중 ‘무한의 탑’이라는 던전에 AI 기술이 사용되었다. 지난 2016년 엔씨소프트에서는 블소에서 신규 콘텐츠 ‘무한의 탑’ 업데이트를 진행했다. 1인용 던전이며 각 층마다 각기 다른 기술을 사용하는 NPC(Non-Player Character)가 적으로 등장하는데, 이 NPC가 정해진 패턴만을 반복하지 않고 플레이어 간 대전에서 발생한 다양한 상황을 바탕으로 플레이어에게 대응하는 AI라고 한다. 해당 NPC는 플레이어와 동일한 기술을 사용하며, 플레이어의 실력과 플레이한 난이도에 따라 다음 층의 높이와 NPC의 실력이 달라진다. 엔씨소프트 측에서는 이 콘텐츠가 플레이어 간 대전이 아님에도 마치 사람과 전투를 하는 듯한 긴장감과 재미를 제공할 것으로 기대하였으나 유감스럽게도 NPC의 스킬 쿨타임이 무시되는 버그가 발생하거나 NPC가 오히려 이런저런 버그를 악용하는 문제로 플레이어들에게 원성이 자자한 콘텐츠이다. 플레이어로부터 배우고 성장하는 NPC를 만들겠다는 그 의도는 높이 평가하지만 콘텐츠 출시 후 발견된 여러 문제와 버그를 고쳤다는 소식을 볼 수 없었던 것은 유감스럽다. 그러나 그것은 지속적인 업데이트의 부재로 생긴 문제이고, 이 NPC를 만들었던 기술은 앞으로도 활용 가능성이 높으리라 생각한다.이전부터 인공지능은 다양한 분야에서 활용되어왔으며 지금도 그러하고 있다. 인간 바둑 기사를 이긴 알파고나 체스 인공지능 딥블루, 현재 번역기로 널리 사용되고 있는 파파고 등이 그 예시이다. 알파고는 구글의 딥마인드에서 딥러닝과 강화학습 기술로 개발하였으며 2018년 12월에 바둑을 포함한 보드게임에 적용할 수 있는 범용 인공지능 알파 제로(Alpha Zero)도 발표되었다. 딥블루는 IBM이 만들었으며 체스에서 가능한 다음 수들을 탐색하여 인간과 대결하였다. 일반적으로 알려진 ‘딥블루’가 인간을 이겼다는 명성과는 달리, ‘딥블루’는 인간을 이기지 못했고 이후 개발된 딥블루의 개량형 ‘디퍼 블루(Deeper Blue)’가 정식으로 체스 세계 챔피언을 이겼다. 파파고는 네이버에서 개발한 무료 번역 서비스로 네이버가 자체 개발한 인공 신경망을 그 기반으로 한다. 아직까지도 완벽하다고는 할 수 없지만 출시 이후 수많은 사람들의 이용과 번역 도움으로 꾸준히 발전해나가고 있다. 비교적 옛날에 개발된 딥블루와 디퍼 블루는 지속적인 발전을 기대하기 어렵지만 ‘최초의 승리’였다는 점에서 그 의의를 갖는다고 생각한다. 그리고 알파고는 딥블루의 뒤를 이어 인간을 이겼다는 의의와 함께 바둑이라는, 체스보다 훨씬 복잡한 문제를 풀어내었다는 기술의 발전상까지 확인할 수 있는 지표라고 본다. 또한 이후 더 보편적인 보드게임에 적용할 수 있는 알파 제로도 발표되었다고 하니 승리에서 그치지 않고 더 나아간 것을 볼 수 있다. 파파고는 빈번한 이용은 물론 지금도 간혹 예상치 못한 번역으로 사람들 사이에서 회자되고 있다. 일례로 이전에 속칭 ‘야민정음’이라고 하는 것을 파파고가 번역해냈다며 놀라워하는 SNS 게시물이 사람들의 이목을 끈 적이 있다.* 참고문헌 인공지능(이 과제가 출제된 강의임) 강의 자료 “MYCIN” AI Study http://www.aistudy.co.kr/demo/MYCIN.htm “Intelligent Agents” STUDYLIB https://studylib.net/doc/9074467/intelligent-agents “지능형 에이전트” 위키백과, 우리 모두의 백과사전. https://ko.wikipedia.org/wiki/지능형_에이전트 “유전자 알고리즘 : 정환묵” AI Study http://www.aistudy.co.kr/biology/genetic/genetic_jeong.htm “연결주의” 위키백과, 우리 모두의 백과사전. https://ko.wikipedia.org/wiki/연결주의 “딥 러닝이란 무엇인가요?” Basler https://www.baslerweb.com/ko/vision-campus/markets-and-applications/what-is-deep-learning/ “딥 러닝” 위키백과, 우리 모두의 백과사전. https://ko.wikipedia.org/wiki/딥_러닝 “딥러닝 기초 - 오차역전파(back propagation) 알고리즘” goofcode’s blog https://goofcode.github.io/back-propagation “인공 신경망” 위키백과, 우리 모두의 백과사전. https://ko.wikipedia.org/wiki/인공_신경망 “합성곱 신경망” 위키백과, 우리 모두의 백과사전. https://ko.wikipedia.org/wiki/합성곱_신경망 “딥 러닝을 이용한 자연어 처리 입문” WikiDocs https://wikidocs.net/book/2155 “넷마블 ‘콜롬버스·마젤란’ 프로젝트 아시나요” BUSINESS WATCH http://news.bizwatch.co.kr/article/mobile/2020/10/30/0021 “블레이드&amp;소울, ‘무한의 탑’ 업데이트…강력한 AI NPC 등장” smartPC사랑 https://www.ilovepc.co.kr/news/articleView.html?idxno=12283 “[AI 리뷰] 인공지능을 통해 게임 플레이 에이전트를 빠르게 학습하고, 배포할 수 있는 솔루션 오픈소스로 공개” 인공지능신문 http://www.aitimes.kr/news/articleView.html?idxno=21550 “BARO AI Academy“ facebook https://pixel.facebook.com/baro.aiacademy/posts/382616146530069 ”알파고“ 위키백과, 우리 모두의 백과사전. https://ko.wikipedia.org/wiki/알파고사담 : 나 이거 쓸 때는 나름 노력한다고 여기저기 찾고 고민하면서 열심히 쓴 건데.. 복붙하니까 금방이네. 좀 허무하고 그렇다. 오늘 인공지능 기말고사 보고 종강해서 강의자료 정리하다 발견해서 올림. 내가 소설을 써도 이만큼 많이 쓴 적이 없는데 그럼 남겨야 하지 않겠니 이게 또 어디서 쓸 데가 있을 줄 알고.원래 이 과제가 이런저런 지식 서술도 기본 요구사항이었지만 학생 본인 의견도 쓰라고 했거든? 그래서 나도 어떻게든 말을 만들어서 붙이긴 했는데 솔직히 근거 없고 뻔히 입발린 말이라서 그건 적당히 지우고 올린다." }, { "title": "웨어러블 디바이스, 스마트 워치만 있나?", "url": "/satinbower-legacy/posts/it-wearable-device/", "categories": "IT, 기타", "tags": "지식, IT", "date": "2021-11-17 00:00:00 +0900", "snippet": "과제 - 기사 작성최근 몇 년 사이 자연스럽게 우리 일상의 일부가 된 스마트 워치, 얼마 전 이것으로 반려묘의 심박수를 측정하는 영상이 사람들의 이목을 끌어 화제가 되었다. 스마트 워치는 시계 형태로 손목에 착용하여 사용하는 웨어러블 디바이스의 일종이다. 이러한 기기들은 초기에는 기본적인 계산기 기능과 번역기 기능 등을 갖추었고, 현재는 효과적으로 입거나 착용하는 컴퓨터로서의 역할을 할 것으로 기대되고 있다.과학기술일자리진흥원의 보고서[1]에 따르면 웨어러블 디바이스란 신체에 부착하여 컴퓨팅 행위를 할 수 있는 모든 전자기기를 지칭하며, 일부 컴퓨팅 기능을 수행할 수 있는 어플리케이션까지 포함하는 것이라고 정의하고 있다. 또한 사용자가 이동 및 활동 중에도 자유롭게 사용할 수 있게 신체나 의복에 착용 가능하도록 작고 가볍게 개발되어 신체의 가장 가까운 곳에서 사용자와 소통 가능한 차세대 전자기기를 의미한다고 한다. 웨어러블 디바이스는 스마트 워치 외에도 반려동물, 헬스케어 ∙ 의료, 인포테인먼트 분야 및 산업 ∙ 군사 목적까지 다양하게 활용되고 있다. 유형 또한 액세서리형, 직물/의류 일체형, 신체부착형, 생체이식형 4가지로 나눌 수 있는데, 우리가 아는 대부분의 웨어러블 디바이스는 이 중 액세서리형에 속한다.웨어러블 디바이스를 이루는 기술에는 센싱 기술, 처리 기술, 유무선 통신 및 네트워크 인프라 기술 등이 있다. 센싱 기술은 사용자나 주변환경의 물리/화학적 변화를 감지하고 구분 ∙ 계측하여 신호로 알려주는 소재 및 부품 기술이다. 인간의 오감 기능 및 인체정보를 측정하는 센서와 초음파, 전기, 회전 등을 감지하는 기술로 구성된다. 이 기술로 사용자의 심박수나 혈당 등을 측정할 수 있다. 처리 기술은 센서를 통해 입력된 데이터를 기기 자체에 내장된 소프트웨어로 축적하여 분석 및 연산처리를 하는 기술이다. 소형 마이크로 프로세서기술, 신축유연 회로기판 기술 등으로 구성된다. 이 기술로 인체정보를 모니터링하거나 사용자 인식 데이터 보안, 저전력 실시간 영상 처리 등을 할 수 있다. 유무선 통신 및 네트워크 인프라 기술은 IoT의 유무선 통신 및 네트워크 장치로 Wi-Fi, 3G/4G/LTE, 위성통신 등 인간과 사물, 서비스를 연결할 수 있는 모든 유무선 네트워크를 의미하는 기술이다. Wi-Fi, ZigBee(지그비) 등의 근거리 무선통신과 3.9G, 4G 이동통신 기술, 이더넷, 광대역 통신망 등의 유선통신 기술로 구성되고 기능한다. 이 중 센싱 기술과 유무선 통신 및 네트워크 인프라 기술은 사물인터넷 3대 주요 기술 중 두 가지이기도 하다.위에서 사람용 스마트 워치로 반려묘의 심박수를 측정한 사례를 언급했는데, 웨어러블 디바이스 중에는 반려동물을 위한 제품도 있다. 반려동물의 위치를 실시간으로 추적하는 GPS 기능, 분 단위 활동, 수면의 질, 이동거리, 소모된 칼로리, 전반적인 건강관리와 행동을 추적하는 기능 등을 지원한다. 주로 목줄이나 목줄에 부착하는 형태로 개발된다. 시장 내 주요 기업은 미국의 WHISTLE LABS, FITBARK, 오스트리아의 TRACTIVE 등이 있다. WHISTLE LABS에서는 GPS 반려동물 목걸이와 모바일 애플리케이션을 결합한 GPS 반려동물 추적기와 활동 모니터링을 제공한다. 반려동물의 활동을 측정하고 일상적인 행동과 장기적인 추세를 추적하며 건강한 습관을 만드는 데 도움을 준다. FITBARK는 무선 반려동물 건강 및 행동 모니터링 장치를 제공하고 있으며, 반려동물의 활동, 수면, 칼로리 소비 및 전반적인 건강을 제어할 수 있는 스마트 목줄 센서와 소프트웨어 인프라를 제공한다. 이 제품은 보호자에게 수집한 정보를 제공하며 수의사와 이를 공유할 수 있다. TRACTIVE는 개와 고양이를 위한 GPS를 지원하는 기업으로 위치 추적 및 활동 모니터링 장치를 개발 및 제공하고 있다. Tractive GPS 반려동물 추적기는 견고하고 방수 기능이 있는 추적기로 보호자가 실시간으로 반려동물을 추적할 수 있고, 가상 울타리, 위치 기록, 친구 및 가족과의 위치공유와 같은 기능을 제공하지만 이를 위해 모바일 네트워크가 필요하다.앞서 말했듯 웨어러블 디바이스의 산업 분야는 의료/헬스케어, 패션/엔터테인먼트, 산업/군사 등 생각보다 다양하다. 기술 발전과 인식 변화, 수요 증가에 따라 시장 전망도 밝다. 한국산업기술평가관리원의 한 보고서[2]에 따르면 세계시장 모든 분야에서 2021년까지 높은 성장이 기대되며, 21년에는 의료/헬스케어 분야가 가장 큰 시장을 차지할 것으로 예상된다고 한다. 또한 웨어러블 디바이스 특성상 다품종 소량생산 형태로 시장이 형성될 전망으로 각 산업별로 특화된 중소 ∙ 중견기업들이 경쟁력을 가지고 성장할 수 있다. 한편 패션 웨어러블 디바이스의 등장으로 웨어러블 디바이스가 ‘패션 아이템’으로 떠오르면서 전자기기에 큰 관심이 없던 소비자까지 시장에 유입되어 패션 등 타 산업 브랜드와의 협업도 필요하다. 그러나 아직까지는 소비자들에게 스마트폰 등의 보조기기라는 인식이 강하며, 이러한 인식을 벗어나기 위하여 IoT(사물인터넷), 인공지능(AI) 기술과의 접목 등을 통한 웨어러블 디바이스의 발전이 필요하며, 웨어러블 디바이스 사용과정에 일어날 수 있는 보안 및 프라이버시 침해 논란 등을 법적으로 어떻게 해결해 나갈지도 필수적으로 고려해야 할 사항이다. 웨어러블 디바이스 산업은 개선의 여지가 많은 만큼 발전 가능성도 높아 지속적인 관심이 필요하다.참고문헌 신윤미, \"웨어러블 디바이스 기술동향보고서\", 과학기술일자리진흥원 S&amp;T Market Report vol.61 (2018) 한상철 외 2인, \"웨어러블 스마트 기기 기술동향과 산업전망\", 한국산업기술평가관리원 KEIT PD 이슈리포트 vol.16-03 (2016) \"스마트워치.\" 위키백과, 우리 모두의 백과사전. 2021년 5월 14일 수정, 2021년 10월 10일 접속, https://ko.wikipedia.org/wiki/스마트워치. \"사물인터넷(IoT).\" ITstory. 2017년 4월 21일 수정, 2021년 10월 16일 접속, https://copycode.tistory.com/70 연구개발특구진흥재단, \"애완동물용 웨어러블 시장\", 글로벌 시장동향 보고서, no.53 (2021)사담중간고사 대체 과제라서 제출 기간 한참 지난 후에 올림. 쓰기는 10월에 썼다. 쓰는 것만 해도 기력 달려서 사실상 초고 상태라는 게 아쉽지만 기말 과제도 있어서 수정할 일은 없을 것 같다. 과제 내고 나서 그걸 어디에 올리지 말라고는 안 했고 혹시나 평가에 뭐가 걸릴까 해서 기다리다 올리는 거니까 괜찮길 바람. 참고문헌 양식은 카피킬러 출처표기법 보고 썼다. 출처 쓰는 게 제일 어렵더라." } ]
